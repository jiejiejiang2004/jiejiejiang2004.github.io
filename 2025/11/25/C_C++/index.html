<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 8.1.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=-apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif:300,300italic,400,400italic,700,700italic|Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">



<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"jiejiejiang2004.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":true,"preload":true},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="基本编译流程 C&#x2F;C++程序的编译通常分为四个阶段：   预处理（Preprocessing）  处理以#开头的预处理指令 包含头文件（#include） 展开宏定义（#define） 条件编译（#if, #ifdef, #ifndef, #else, #endif）  示例命令（预处理阶段）： 12gcc -E source.c -o source.i  # C文件g++ -E source.c">
<meta property="og:type" content="article">
<meta property="og:title" content="C &amp;&amp; C++ 基础">
<meta property="og:url" content="https://jiejiejiang2004.github.io/2025/11/25/C_C++/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="基本编译流程 C&#x2F;C++程序的编译通常分为四个阶段：   预处理（Preprocessing）  处理以#开头的预处理指令 包含头文件（#include） 展开宏定义（#define） 条件编译（#if, #ifdef, #ifndef, #else, #endif）  示例命令（预处理阶段）： 12gcc -E source.c -o source.i  # C文件g++ -E source.c">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-11-24T16:00:00.000Z">
<meta property="article:modified_time" content="2025-12-03T17:49:42.881Z">
<meta property="article:author" content="jiejiejiang">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://jiejiejiang2004.github.io/2025/11/25/C_C++/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>C && C++ 基础 | Hexo</title><meta name="robots" content="noindex">
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}.beian img{display:inline-block!important}</style><link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hexo</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-schedule">

    <a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>日程表</a>

  </li>
        <li class="menu-item menu-item-sitemap">

    <a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>站点地图</a>

  </li>
        <li class="menu-item menu-item-rss">

    <a href="/atom.xml" rel="section"><i class="fa fa-rss fa-fw"></i>RSS</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

  
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://jiejiejiang2004.github.io/2025/11/25/C_C++/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="jiejiejiang">
      <meta itemprop="description" content="现在开始，还来得及">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          C && C++ 基础
        </h1>

        <div class="post-meta">

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-11-25 00:00:00" itemprop="dateCreated datePublished" datetime="2025-11-25T00:00:00+08:00">2025-11-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-12-04 01:49:42" itemprop="dateModified" datetime="2025-12-04T01:49:42+08:00">2025-12-04</time>
              </span>

          
            <span id="/2025/11/25/C_C++/" class="post-meta-item leancloud_visitors" data-flag-title="C && C++ 基础" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2025/11/25/C_C++/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2025/11/25/C_C++/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>48k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2:56</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1>基本编译流程</h1>
<p>C/C++程序的编译通常分为四个阶段：</p>
<ol>
<li>
<p><strong>预处理（Preprocessing）</strong></p>
<ul>
<li>处理以<code>#</code>开头的预处理指令</li>
<li>包含头文件（<code>#include</code>）</li>
<li>展开宏定义（<code>#define</code>）</li>
<li>条件编译（<code>#if</code>, <code>#ifdef</code>, <code>#ifndef</code>, <code>#else</code>, <code>#endif</code>）</li>
</ul>
<p>示例命令（预处理阶段）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -E source.c -o source.i  <span class="comment"># C文件</span></span><br><span class="line">g++ -E source.cpp -o source.i  <span class="comment"># C++文件</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>编译（Compilation）</strong></p>
<ul>
<li>将预处理后的代码转换为汇编语言</li>
<li>进行语法检查和优化</li>
</ul>
<p>示例命令（编译阶段）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -S source.i -o source.s  <span class="comment"># C文件</span></span><br><span class="line">g++ -S source.i -o source.s  <span class="comment"># C++文件</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>汇编（Assembly）</strong></p>
<ul>
<li>将汇编代码转换为机器码（目标文件）</li>
<li>生成<code>.o</code>（Linux/macOS）或<code>.obj</code>（Windows）文件</li>
</ul>
<p>示例命令（汇编阶段）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -c source.s -o source.o  <span class="comment"># C文件</span></span><br><span class="line">g++ -c source.s -o source.o  <span class="comment"># C++文件</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>链接（Linking）</strong></p>
<ul>
<li>将目标文件与库文件链接，生成可执行文件</li>
<li>解析外部引用</li>
</ul>
<p>示例命令（链接阶段）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc source.o -o program  <span class="comment"># C程序</span></span><br><span class="line">g++ source.o -o program  <span class="comment"># C++程序</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>完整编译命令（一步完成）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc source.c -o program  <span class="comment"># C程序</span></span><br><span class="line">g++ source.cpp -o program  <span class="comment"># C++程序</span></span><br></pre></td></tr></table></figure>
<h4 id="简单程序编译与运行示例">简单程序编译与运行示例</h4>
<p>C程序示例：</p>
<ol>
<li>创建文件 <code>hello.c</code>：</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入一个整数：&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;num);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;你输入的整数是：%d\n&quot;</span>, num);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>编译：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc hello.c -o hello</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>运行：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Linux/macOS</span></span><br><span class="line">./hello</span><br><span class="line"></span><br><span class="line"><span class="comment"># Windows</span></span><br><span class="line">hello.exe</span><br></pre></td></tr></table></figure>
<p>C++程序示例：</p>
<ol>
<li>创建文件 <code>hello.cpp</code>：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;请输入一个整数：&quot;</span>;</span><br><span class="line">    std::cin &gt;&gt; num;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;你输入的整数是：&quot;</span> &lt;&lt; num &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>编译：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ hello.cpp -o hello</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>运行（与C程序相同）</li>
</ol>
<h2 id="2-C语言基础">2. C语言基础</h2>
<h3 id="2-1-基本语法与数据类型">2.1 基本语法与数据类型</h3>
<h4 id="程序结构：main函数、语句、注释">程序结构：main函数、语句、注释</h4>
<h5 id="C程序基本结构">C程序基本结构</h5>
<p>C程序由一个或多个函数组成，其中必须包含一个名为<code>main</code>的函数，这是程序执行的入口点。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  <span class="comment">// 头文件包含</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main函数 - 程序入口</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 声明变量</span></span><br><span class="line">    <span class="type">int</span> x = <span class="number">5</span>, y = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> result;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 语句 - 执行计算</span></span><br><span class="line">    result = add(x, y);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输出结果</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;结果是: %d\n&quot;</span>, result);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">// 返回值，表示程序正常结束</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数定义</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="语句">语句</h5>
<p>C语言中的语句以分号<code>;</code>结尾，主要包括：</p>
<ul>
<li>表达式语句：如赋值语句 <code>x = 5;</code></li>
<li>控制语句：如条件语句、循环语句</li>
<li>函数调用语句：如 <code>printf(&quot;Hello&quot;);</code></li>
<li>复合语句：用花括号<code>{}</code>括起来的一组语句</li>
<li>空语句：单独的分号<code>;</code></li>
</ul>
<h5 id="注释">注释</h5>
<p>注释用于解释代码，提高可读性，编译器会忽略注释内容。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是单行注释</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 这是</span></span><br><span class="line"><span class="comment">   多行</span></span><br><span class="line"><span class="comment">   注释 */</span></span><br></pre></td></tr></table></figure>
<h4 id="标识符与关键字">标识符与关键字</h4>
<h5 id="标识符">标识符</h5>
<p>标识符是用来命名变量、函数、数组等的名称。命名规则：</p>
<ul>
<li>只能由字母、数字和下划线组成</li>
<li>不能以数字开头</li>
<li>区分大小写</li>
<li>不能使用关键字</li>
<li>建议使用有意义的名称，便于理解</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 有效的标识符</span></span><br><span class="line"><span class="type">int</span> count;</span><br><span class="line"><span class="type">float</span> average_score;</span><br><span class="line"><span class="type">char</span> studentName;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无效的标识符</span></span><br><span class="line"><span class="type">int</span> <span class="number">123</span>abc;  <span class="comment">// 不能以数字开头</span></span><br><span class="line"><span class="type">float</span> my-salary;  <span class="comment">// 不能包含连字符</span></span><br><span class="line"><span class="type">int</span> <span class="keyword">if</span>;  <span class="comment">// 不能使用关键字</span></span><br></pre></td></tr></table></figure>
<h5 id="关键字">关键字</h5>
<p>关键字是C语言预定义的具有特殊含义的单词，不能用作标识符。C标准定义了32个关键字：</p>
<table>
<thead>
<tr>
<th>关键字类别</th>
<th>关键字</th>
</tr>
</thead>
<tbody>
<tr>
<td>数据类型</td>
<td>int, char, float, double, void, short, long, unsigned, signed</td>
</tr>
<tr>
<td>控制语句</td>
<td>if, else, switch, case, default, for, while, do, break, continue, goto, return</td>
</tr>
<tr>
<td>存储类别</td>
<td>auto, static, extern, register</td>
</tr>
<tr>
<td>其他</td>
<td>struct, union, enum, typedef, const, volatile, sizeof</td>
</tr>
</tbody>
</table>
<h4 id="基本数据类型">基本数据类型</h4>
<p>C语言提供了几种基本数据类型：</p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>描述</th>
<th>字节数(典型)</th>
<th>取值范围</th>
</tr>
</thead>
<tbody>
<tr>
<td>char</td>
<td>字符型</td>
<td>1</td>
<td>-128 到 127 或 0 到 255</td>
</tr>
<tr>
<td>int</td>
<td>整型</td>
<td>4</td>
<td>-2,147,483,648 到 2,147,483,647</td>
</tr>
<tr>
<td>float</td>
<td>单精度浮点型</td>
<td>4</td>
<td>约 ±3.4e-38 到 ±3.4e+38</td>
</tr>
<tr>
<td>double</td>
<td>双精度浮点型</td>
<td>8</td>
<td>约 ±1.7e-308 到 ±1.7e+308</td>
</tr>
<tr>
<td>void</td>
<td>无类型</td>
<td>0</td>
<td>不表示具体值</td>
</tr>
</tbody>
</table>
<p>示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> c = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line"><span class="type">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="type">float</span> f = <span class="number">3.14f</span>;  <span class="comment">// 注意f后缀表示float类型</span></span><br><span class="line"> <span class="type">double</span> d = <span class="number">3.14159265</span>;</span><br></pre></td></tr></table></figure>
<h4 id="类型修饰符">类型修饰符</h4>
<p>类型修饰符用于修饰基本数据类型，改变其取值范围或存储方式：</p>
<h5 id="signed">signed</h5>
<p>表示有符号类型，可以表示正数、负数和零。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">signed</span> <span class="type">int</span> num = <span class="number">-10</span>;  <span class="comment">// 等价于 int num = -10;</span></span><br></pre></td></tr></table></figure>
<h5 id="unsigned">unsigned</h5>
<p>表示无符号类型，只能表示非负数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> count = <span class="number">100</span>;  <span class="comment">// 范围：0 到 4,294,967,295</span></span><br></pre></td></tr></table></figure>
<h5 id="short">short</h5>
<p>修饰int，表示短整型，通常占2个字节。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">short</span> s = <span class="number">32767</span>;  <span class="comment">// 最大值</span></span><br></pre></td></tr></table></figure>
<h5 id="long">long</h5>
<p>修饰int，表示长整型，通常占4或8个字节。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> l = <span class="number">2147483647</span>;  <span class="comment">// 典型最大值</span></span><br></pre></td></tr></table></figure>
<p>组合使用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> big_num = <span class="number">18446744073709551615ULL</span>;</span><br></pre></td></tr></table></figure>
<h4 id="常量与变量定义">常量与变量定义</h4>
<h5 id="常量">常量</h5>
<p>常量是程序中固定不变的值。</p>
<ol>
<li>
<p><strong>字面常量</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">42</span>        <span class="comment">// 整型常量</span></span><br><span class="line"><span class="number">3.14</span>      <span class="comment">// 浮点型常量</span></span><br><span class="line"><span class="string">&#x27;A&#x27;</span>       <span class="comment">// 字符常量</span></span><br><span class="line"><span class="string">&quot;Hello&quot;</span>   <span class="comment">// 字符串常量</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>const常量</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> MAX_SIZE = <span class="number">100</span>;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>宏常量</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PI 3.14159</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>枚举常量</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Color</span> &#123;</span> RED, GREEN, BLUE &#125;;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h5 id="变量定义">变量定义</h5>
<p>变量是程序中可以改变值的存储单元。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数据类型 变量名 = 初始值;</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> age = <span class="number">25</span>;         <span class="comment">// 整型变量</span></span><br><span class="line"><span class="type">float</span> salary;         <span class="comment">// 浮点型变量，未初始化</span></span><br><span class="line"><span class="type">char</span> grade = <span class="string">&#x27;A&#x27;</span>;     <span class="comment">// 字符型变量</span></span><br></pre></td></tr></table></figure>
<h4 id="类型转换">类型转换</h4>
<h5 id="隐式类型转换（自动转换）">隐式类型转换（自动转换）</h5>
<p>当不同类型的数据混合运算时，C会自动将较低精度的类型转换为较高精度的类型。</p>
<p>规则：</p>
<ol>
<li>char、short → int → unsigned → long → unsigned long → double</li>
<li>float → double</li>
</ol>
<p>示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">10</span>;</span><br><span class="line"><span class="type">float</span> f = <span class="number">3.14</span>;</span><br><span class="line"><span class="type">float</span> result = i + f;  <span class="comment">// i自动转换为float</span></span><br></pre></td></tr></table></figure>
<h5 id="显式类型转换（强制转换）">显式类型转换（强制转换）</h5>
<p>使用强制类型转换运算符可以显式地转换类型。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(目标类型)表达式</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> f = <span class="number">3.14</span>;</span><br><span class="line"><span class="type">int</span> i = (<span class="type">int</span>)f;  <span class="comment">// i的值为3，小数部分被截断</span></span><br></pre></td></tr></table></figure>
<h3 id="2-2-运算符与表达式">2.2 运算符与表达式</h3>
<h4 id="算术运算符">算术运算符</h4>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
<th>示例</th>
<th>结果</th>
</tr>
</thead>
<tbody>
<tr>
<td>+</td>
<td>加法</td>
<td>a + b</td>
<td>a和b的和</td>
</tr>
<tr>
<td>-</td>
<td>减法</td>
<td>a - b</td>
<td>a和b的差</td>
</tr>
<tr>
<td>*</td>
<td>乘法</td>
<td>a * b</td>
<td>a和b的积</td>
</tr>
<tr>
<td>/</td>
<td>除法</td>
<td>a / b</td>
<td>a除以b的商</td>
</tr>
<tr>
<td>%</td>
<td>取模</td>
<td>a % b</td>
<td>a除以b的余数</td>
</tr>
<tr>
<td>++</td>
<td>自增</td>
<td>a++或++a</td>
<td>a的值加1</td>
</tr>
<tr>
<td>–</td>
<td>自减</td>
<td>a–或–a</td>
<td>a的值减1</td>
</tr>
</tbody>
</table>
<p>注意：</p>
<ul>
<li>整数除法会截断小数部分</li>
<li>前缀自增/自减先修改变量值，再使用变量</li>
<li>后缀自增/自减先使用变量，再修改变量值</li>
</ul>
<p>示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">5</span>, b = <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> c = a / b;  <span class="comment">// c = 2</span></span><br><span class="line"><span class="type">int</span> d = a % b;  <span class="comment">// d = 1</span></span><br><span class="line"><span class="type">int</span> e = a++;    <span class="comment">// e = 5, a = 6</span></span><br><span class="line"><span class="type">int</span> f = ++b;    <span class="comment">// f = 3, b = 3</span></span><br></pre></td></tr></table></figure>
<h4 id="关系运算符">关系运算符</h4>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
<th>示例</th>
<th>结果</th>
</tr>
</thead>
<tbody>
<tr>
<td>==</td>
<td>等于</td>
<td>a == b</td>
<td>相等为1，不等为0</td>
</tr>
<tr>
<td>!=</td>
<td>不等于</td>
<td>a != b</td>
<td>不等为1，相等为0</td>
</tr>
<tr>
<td>&gt;</td>
<td>大于</td>
<td>a &gt; b</td>
<td>a大于b为1，否则为0</td>
</tr>
<tr>
<td>&lt;</td>
<td>小于</td>
<td>a &lt; b</td>
<td>a小于b为1，否则为0</td>
</tr>
<tr>
<td>&gt;=</td>
<td>大于等于</td>
<td>a &gt;= b</td>
<td>a大于等于b为1，否则为0</td>
</tr>
<tr>
<td>&lt;=</td>
<td>小于等于</td>
<td>a &lt;= b</td>
<td>a小于等于b为1，否则为0</td>
</tr>
</tbody>
</table>
<p>示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">5</span>, y = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> isGreater = (x &gt; y);  <span class="comment">// 0</span></span><br><span class="line"><span class="type">int</span> isEqual = (x == <span class="number">5</span>);   <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<h4 id="逻辑运算符">逻辑运算符</h4>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
<th>示例</th>
<th>结果</th>
</tr>
</thead>
<tbody>
<tr>
<td>&amp;&amp;</td>
<td>逻辑与</td>
<td>a &amp;&amp; b</td>
<td>都为真时为1，否则为0</td>
</tr>
<tr>
<td>||</td>
<td>逻辑或</td>
<td>a || b</td>
<td>有一个为真时为1，否则为0</td>
</tr>
<tr>
<td>!</td>
<td>逻辑非</td>
<td>!a</td>
<td>a为真时为0，否则为1</td>
</tr>
</tbody>
</table>
<p>注意：逻辑运算符具有短路特性。</p>
<p>示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> p = <span class="number">1</span>, q = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> r1 = p &amp;&amp; q;  <span class="comment">// 0，短路，q不计算</span></span><br><span class="line"><span class="type">int</span> r2 = p || q;  <span class="comment">// 1，短路，q不计算</span></span><br><span class="line"><span class="type">int</span> r3 = !p;      <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>
<h4 id="赋值运算符">赋值运算符</h4>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
<th>示例</th>
<th>等价于</th>
</tr>
</thead>
<tbody>
<tr>
<td>=</td>
<td>赋值</td>
<td>a = b</td>
<td>a = b</td>
</tr>
<tr>
<td>+=</td>
<td>加后赋值</td>
<td>a += b</td>
<td>a = a + b</td>
</tr>
<tr>
<td>-=</td>
<td>减后赋值</td>
<td>a -= b</td>
<td>a = a - b</td>
</tr>
<tr>
<td>*=</td>
<td>乘后赋值</td>
<td>a *= b</td>
<td>a = a * b</td>
</tr>
<tr>
<td>/=</td>
<td>除后赋值</td>
<td>a /= b</td>
<td>a = a / b</td>
</tr>
<tr>
<td>%=</td>
<td>取模后赋值</td>
<td>a %= b</td>
<td>a = a % b</td>
</tr>
</tbody>
</table>
<p>示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">a += <span class="number">5</span>;  <span class="comment">// a = 15</span></span><br><span class="line">a *= <span class="number">2</span>;  <span class="comment">// a = 30</span></span><br></pre></td></tr></table></figure>
<h4 id="位运算符">位运算符</h4>
<p>位运算符用于对二进制位进行操作。</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
<th>示例</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>&amp;</td>
<td>按位与</td>
<td>a &amp; b</td>
<td>对应位都为1时结果位为1</td>
</tr>
<tr>
<td>|</td>
<td>按位或</td>
<td>a | b</td>
<td>对应位有一个为1时结果位为1</td>
</tr>
<tr>
<td>^</td>
<td>按位异或</td>
<td>a ^ b</td>
<td>对应位不同时结果位为1</td>
</tr>
<tr>
<td>~</td>
<td>按位非</td>
<td>~a</td>
<td>每一位取反</td>
</tr>
<tr>
<td>&lt;&lt;</td>
<td>左移</td>
<td>a &lt;&lt; b</td>
<td>a的二进制位左移b位，右边补0</td>
</tr>
<tr>
<td>&gt;&gt;</td>
<td>右移</td>
<td>a &gt;&gt; b</td>
<td>a的二进制位右移b位，左边补符号位</td>
</tr>
</tbody>
</table>
<p>示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">6</span>;  <span class="comment">// 0110</span></span><br><span class="line"><span class="type">int</span> b = <span class="number">3</span>;  <span class="comment">// 0011</span></span><br><span class="line"><span class="type">int</span> c = a &amp; b;  <span class="comment">// 0010 (2)</span></span><br><span class="line"><span class="type">int</span> d = a | b;  <span class="comment">// 0111 (7)</span></span><br><span class="line"><span class="type">int</span> e = a ^ b;  <span class="comment">// 0101 (5)</span></span><br><span class="line"><span class="type">int</span> f = a &lt;&lt; <span class="number">1</span>;  <span class="comment">// 1100 (12)</span></span><br></pre></td></tr></table></figure>
<h4 id="条件运算符">条件运算符</h4>
<p>条件运算符（三元运算符）格式为：<code>表达式1 ? 表达式2 : 表达式3</code></p>
<p>如果表达式1为真（非零），则整个表达式的值为表达式2的值，否则为表达式3的值。</p>
<p>示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">5</span>, y = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> max = (x &gt; y) ? x : y;  <span class="comment">// max = 10</span></span><br></pre></td></tr></table></figure>
<h4 id="运算符优先级与结合性">运算符优先级与结合性</h4>
<p>运算符优先级决定了表达式中运算的执行顺序，结合性决定了相同优先级运算符的计算顺序。</p>
<p>优先级从高到低（部分）：</p>
<ol>
<li>括号 () [] -&gt; .</li>
<li>单目运算符 ! ~ ++ – + - (类型) sizeof</li>
<li>算术运算符 * / %</li>
<li>算术运算符 + -</li>
<li>位运算符 &lt;&lt; &gt;&gt;</li>
<li>关系运算符 &lt; &lt;= &gt; &gt;=</li>
<li>关系运算符 == !=</li>
<li>位运算符 &amp;</li>
<li>位运算符 ^</li>
<li>位运算符 |</li>
<li>逻辑运算符 &amp;&amp;</li>
<li>逻辑运算符 ||</li>
<li>条件运算符 ?:</li>
<li>赋值运算符 = += -= *= /= %= &amp;= |= ^= &lt;&lt;= &gt;&gt;=</li>
<li>逗号运算符 ,</li>
</ol>
<p>建议：使用括号明确运算顺序，提高代码可读性。</p>
<h3 id="2-3-控制流语句">2.3 控制流语句</h3>
<h4 id="条件语句">条件语句</h4>
<h5 id="if-else语句">if-else语句</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (条件表达式) &#123;</span><br><span class="line">    <span class="comment">// 条件为真时执行</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 条件为假时执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> score = <span class="number">85</span>;</span><br><span class="line"><span class="keyword">if</span> (score &gt;= <span class="number">60</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;及格\n&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;不及格\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>嵌套if-else：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (score &gt;= <span class="number">90</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;优秀\n&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (score &gt;= <span class="number">80</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;良好\n&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (score &gt;= <span class="number">60</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;及格\n&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;不及格\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="switch-case语句">switch-case语句</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (表达式) &#123;</span><br><span class="line">    <span class="keyword">case</span> 常量<span class="number">1</span>:</span><br><span class="line">        <span class="comment">// 代码块</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> 常量<span class="number">2</span>:</span><br><span class="line">        <span class="comment">// 代码块</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// 更多case</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">// 默认代码块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：</p>
<ul>
<li>case后必须是常量表达式</li>
<li>每个case后通常需要break来跳出switch</li>
<li>如果没有break，会继续执行下一个case（贯穿行为）</li>
</ul>
<p>示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> day = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">switch</span> (day) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;星期一\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;星期二\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;星期三\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;其他\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="循环语句">循环语句</h4>
<h5 id="while循环">while循环</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (条件表达式) &#123;</span><br><span class="line">    <span class="comment">// 循环体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行流程：先判断条件，条件为真则执行循环体，重复直到条件为假。</p>
<p>示例：计算1到10的和</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">1</span>, sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt;= <span class="number">10</span>) &#123;</span><br><span class="line">    sum += i;</span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;1到10的和: %d\n&quot;</span>, sum);  <span class="comment">// 55</span></span><br></pre></td></tr></table></figure>
<h5 id="do-while循环">do-while循环</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="comment">// 循环体</span></span><br><span class="line">&#125; <span class="keyword">while</span> (条件表达式);</span><br></pre></td></tr></table></figure>
<p>执行流程：先执行一次循环体，然后判断条件，条件为真则继续执行循环体，直到条件为假。</p>
<p>示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">1</span>, sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    sum += i;</span><br><span class="line">    i++;</span><br><span class="line">&#125; <span class="keyword">while</span> (i &lt;= <span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<h5 id="for循环">for循环</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (初始化; 条件; 更新) &#123;</span><br><span class="line">    <span class="comment">// 循环体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行流程：</p>
<ol>
<li>执行初始化表达式（只执行一次）</li>
<li>检查条件表达式，如果为假，退出循环</li>
<li>执行循环体</li>
<li>执行更新表达式</li>
<li>回到步骤2</li>
</ol>
<p>示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">    sum += i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>嵌套循环示例（打印乘法表）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">9</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= i; j++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d*%d=%d\t&quot;</span>, j, i, i*j);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="跳转语句">跳转语句</h4>
<h5 id="break语句">break语句</h5>
<p>在循环或switch语句中使用，用于立即跳出当前结构。</p>
<p>示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">6</span>) &#123;</span><br><span class="line">        <span class="keyword">break</span>;  <span class="comment">// 跳出循环</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, i);</span><br><span class="line">&#125;  <span class="comment">// 输出: 1 2 3 4 5</span></span><br></pre></td></tr></table></figure>
<h5 id="continue语句">continue语句</h5>
<p>在循环中使用，用于跳过当前循环的剩余部分，直接进入下一次循环。</p>
<p>示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;  <span class="comment">// 跳过偶数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, i);</span><br><span class="line">&#125;  <span class="comment">// 输出: 1 3 5 7 9</span></span><br></pre></td></tr></table></figure>
<h5 id="goto语句">goto语句</h5>
<p>无条件跳转到同一函数内的指定标签处。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">goto</span> 标签名;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">标签名: 语句</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">1</span>;</span><br><span class="line">loop:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, i);</span><br><span class="line">i++;</span><br><span class="line"><span class="keyword">if</span> (i &lt;= <span class="number">5</span>) &#123;</span><br><span class="line">    <span class="keyword">goto</span> loop;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：应尽量避免使用goto，因为它可能使代码结构混乱。</p>
<h4 id="复合语句与块作用域">复合语句与块作用域</h4>
<p>复合语句是由花括号<code>{}</code>括起来的一组语句，也称为代码块。复合语句可以在任何允许单个语句的地方使用。</p>
<p>在复合语句中声明的变量具有块作用域，只在该复合语句内部可见。</p>
<p>示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;  <span class="comment">// 主函数作用域</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (a &gt; <span class="number">5</span>) &#123;</span><br><span class="line">        <span class="type">int</span> b = <span class="number">20</span>;  <span class="comment">// 块作用域，只在if块内可见</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;a=%d, b=%d\n&quot;</span>, a, b);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// printf(&quot;b=%d\n&quot;, b);  // 错误：b在此处不可见</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-4-函数">2.4 函数</h3>
<h4 id="函数定义与声明">函数定义与声明</h4>
<h5 id="函数定义">函数定义</h5>
<p>函数定义指定了函数的具体实现。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">返回类型 函数名(参数列表) &#123;</span><br><span class="line">    <span class="comment">// 函数体</span></span><br><span class="line">    <span class="keyword">return</span> 返回值;  <span class="comment">// 如果返回类型不是void</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算两数之和</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="type">int</span> sum = a + b;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 没有返回值的函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printMessage</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello, World!\n&quot;</span>);</span><br><span class="line">    <span class="comment">// 没有return语句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="函数声明">函数声明</h5>
<p>函数声明（原型）告诉编译器函数的名称、参数类型和返回类型，不包含函数体。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">返回类型 函数名(参数列表);</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span>;  <span class="comment">// 参数名可以省略</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printMessage</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> result = add(<span class="number">5</span>, <span class="number">3</span>);</span><br><span class="line">    printMessage();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数定义</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="参数传递：值传递">参数传递：值传递</h4>
<p>C语言使用值传递方式传递参数，即函数接收的是实参的副本。在函数内部修改形参不会影响实参的值。</p>
<p>示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">increment</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    n++;  <span class="comment">// 只修改了形参</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;函数内: %d\n&quot;</span>, n);  <span class="comment">// 6</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">5</span>;</span><br><span class="line">    increment(num);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;函数外: %d\n&quot;</span>, num);  <span class="comment">// 仍然是5</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要修改实参，可以使用指针作为参数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">increment</span><span class="params">(<span class="type">int</span> *n)</span> &#123;</span><br><span class="line">    (*n)++;  <span class="comment">// 通过指针修改实参</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">5</span>;</span><br><span class="line">    increment(&amp;num);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, num);  <span class="comment">// 6</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="返回值与return语句">返回值与return语句</h4>
<p>return语句用于从函数返回一个值，并终止函数的执行。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> 表达式;</span><br></pre></td></tr></table></figure>
<p>如果函数返回类型为void，可以使用不带表达式的return语句或省略return语句。</p>
<p>示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (a &gt; b) &#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">exitEarly</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 执行一些操作</span></span><br><span class="line">    <span class="keyword">return</span>;  <span class="comment">// 提前退出函数</span></span><br><span class="line">    <span class="comment">// 后面的代码不会执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="函数调用与递归">函数调用与递归</h4>
<h5 id="函数调用">函数调用</h5>
<p>函数调用的一般形式：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">函数名(实参列表);</span><br></pre></td></tr></table></figure>
<p>如果函数有返回值，可以将返回值赋给变量：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> result = add(<span class="number">5</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure>
<h5 id="递归函数">递归函数</h5>
<p>递归函数是调用自身的函数，通常用于解决可以分解为相同形式的子问题的任务。</p>
<p>递归函数必须有一个终止条件，否则会导致无限递归。</p>
<p>示例：计算阶乘</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">factorial</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span> || n == <span class="number">1</span>) &#123;  <span class="comment">// 基本情况（终止条件）</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> n * factorial(n - <span class="number">1</span>);  <span class="comment">// 递归调用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d的阶乘是%d\n&quot;</span>, num, factorial(num));  <span class="comment">// 120</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="函数原型">函数原型</h4>
<p>函数原型是函数声明的一种形式，它告诉编译器函数的名称、返回类型和参数类型。函数原型通常放在源文件的开头或头文件中，允许函数在定义之前被调用。</p>
<p>示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数原型</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 可以在函数定义之前调用它</span></span><br><span class="line">    <span class="type">int</span> result = add(<span class="number">5</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数定义</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="作用域与存储类别">作用域与存储类别</h4>
<h5 id="作用域">作用域</h5>
<p>作用域决定了变量可以被访问的代码范围。</p>
<ol>
<li>
<p><strong>块作用域</strong>：在代码块中声明的变量，只在该块内可见。</p>
</li>
<li>
<p><strong>函数作用域</strong>：函数中的局部变量，在整个函数内可见。</p>
</li>
<li>
<p><strong>文件作用域</strong>：在函数外部声明的变量，在整个源文件中可见。</p>
</li>
<li>
<p><strong>函数原型作用域</strong>：函数原型中的参数名，只在原型中可见。</p>
</li>
</ol>
<h5 id="存储类别">存储类别</h5>
<p>存储类别决定了变量的存储位置、生命周期和链接属性。</p>
<ol>
<li>
<p><strong>auto</strong>：默认的存储类别，用于局部变量，表示变量存储在栈中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">auto</span> <span class="type">int</span> x = <span class="number">5</span>;  <span class="comment">// 与int x = 5;相同</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>static</strong>：</p>
<ul>
<li>用于局部变量：使变量在函数调用之间保持值，存储在静态存储区。</li>
<li>用于全局变量：限制变量只在定义它的文件中可见。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">counter</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> count = <span class="number">0</span>;  <span class="comment">// 只初始化一次</span></span><br><span class="line">    count++;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Count: %d\n&quot;</span>, count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>extern</strong>：声明外部变量，表示变量在其他文件中定义。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> globalVar;  <span class="comment">// 声明外部变量</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>register</strong>：提示编译器将变量存储在寄存器中，以提高访问速度。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">register</span> <span class="type">int</span> i;  <span class="comment">// 建议将i存储在寄存器中</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="2-5-数组与指针">2.5 数组与指针</h3>
<h4 id="一维数组与多维数组">一维数组与多维数组</h4>
<h5 id="一维数组">一维数组</h5>
<p>数组是相同类型元素的集合，在内存中连续存储。</p>
<p><strong>定义一维数组</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数据类型 数组名[数组大小];</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> numbers[<span class="number">5</span>];  <span class="comment">// 定义一个能存储5个整数的数组</span></span><br></pre></td></tr></table></figure>
<p><strong>初始化一维数组</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 完全初始化</span></span><br><span class="line"><span class="type">int</span> numbers[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 部分初始化，未初始化的元素默认为0</span></span><br><span class="line"><span class="type">int</span> numbers[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不指定大小，编译器根据初始化值数量确定</span></span><br><span class="line"><span class="type">int</span> numbers[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="多维数组">多维数组</h5>
<p>多维数组是数组的数组，最常见的是二维数组。</p>
<p><strong>定义二维数组</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数据类型 数组名[行数][列数];</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> matrix[<span class="number">3</span>][<span class="number">4</span>];  <span class="comment">// 定义一个3行4列的二维数组</span></span><br></pre></td></tr></table></figure>
<p><strong>初始化二维数组</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 按行初始化</span></span><br><span class="line"><span class="type">int</span> matrix[<span class="number">3</span>][<span class="number">4</span>] = &#123;</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;,</span><br><span class="line">    &#123;<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;,</span><br><span class="line">    &#123;<span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简化初始化</span></span><br><span class="line"><span class="type">int</span> matrix[<span class="number">3</span>][<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="数组初始化与访问">数组初始化与访问</h4>
<h5 id="数组访问">数组访问</h5>
<p>通过索引访问数组元素，索引从0开始。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> numbers[<span class="number">5</span>] = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>&#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;第一个元素: %d\n&quot;</span>, numbers[<span class="number">0</span>]);  <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;第三个元素: %d\n&quot;</span>, numbers[<span class="number">2</span>]);  <span class="comment">// 30</span></span><br></pre></td></tr></table></figure>
<p>修改数组元素：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numbers[<span class="number">1</span>] = <span class="number">25</span>;  <span class="comment">// 将第二个元素改为25</span></span><br></pre></td></tr></table></figure>
<h5 id="数组遍历">数组遍历</h5>
<p>使用循环遍历数组：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> numbers[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;numbers[%d] = %d\n&quot;</span>, i, numbers[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>遍历二维数组：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> matrix[<span class="number">3</span>][<span class="number">4</span>] = &#123;</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;,</span><br><span class="line">    &#123;<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;,</span><br><span class="line">    &#123;<span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;  <span class="comment">// 行</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++) &#123;  <span class="comment">// 列</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\t&quot;</span>, matrix[i][j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="指针概念与基本操作">指针概念与基本操作</h4>
<h5 id="指针定义">指针定义</h5>
<p>指针是存储内存地址的变量。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数据类型 *指针变量名;</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p;  <span class="comment">// 指向整型的指针</span></span><br><span class="line"><span class="type">float</span> *q;  <span class="comment">// 指向浮点型的指针</span></span><br><span class="line"><span class="type">char</span> *r;  <span class="comment">// 指向字符型的指针</span></span><br></pre></td></tr></table></figure>
<h5 id="取地址与解引用">取地址与解引用</h5>
<ul>
<li>使用取地址运算符<code>&amp;</code>获取变量的地址</li>
<li>使用解引用运算符<code>*</code>访问指针指向的变量的值</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> *p = &amp;num;  <span class="comment">// p存储num的地址</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;num的地址: %p\n&quot;</span>, &amp;num);  <span class="comment">// 输出num的地址</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;p的值: %p\n&quot;</span>, p);  <span class="comment">// 输出p存储的地址，与&amp;num相同</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;*p的值: %d\n&quot;</span>, *p);  <span class="comment">// 输出num的值，即10</span></span><br></pre></td></tr></table></figure>
<h5 id="修改指针指向的值">修改指针指向的值</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*p = <span class="number">20</span>;  <span class="comment">// 修改num的值为20</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;num的值: %d\n&quot;</span>, num);  <span class="comment">// 20</span></span><br></pre></td></tr></table></figure>
<h5 id="空指针">空指针</h5>
<p>空指针是不指向任何有效内存的指针，可以使用NULL表示。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p = <span class="literal">NULL</span>;  <span class="comment">// 空指针</span></span><br></pre></td></tr></table></figure>
<h4 id="指针与数组的关系">指针与数组的关系</h4>
<p>数组名是指向数组第一个元素的常量指针。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="type">int</span> *p = arr;  <span class="comment">// 等同于 p = &amp;arr[0]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下两种访问方式等效</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;arr[0] = %d\n&quot;</span>, arr[<span class="number">0</span>]);  <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;*p = %d\n&quot;</span>, *p);          <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;arr[1] = %d\n&quot;</span>, arr[<span class="number">1</span>]);  <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;*(p+1) = %d\n&quot;</span>, *(p+<span class="number">1</span>));  <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>注意：指针算术是按元素大小进行的，而不是简单的字节数。</p>
<h4 id="指针与函数">指针与函数</h4>
<h5 id="指针作为函数参数">指针作为函数参数</h5>
<p>使用指针作为函数参数可以在函数内部修改实参的值。</p>
<p>示例：交换两个整数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> *b)</span> &#123;</span><br><span class="line">    <span class="type">int</span> temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">5</span>, y = <span class="number">10</span>;</span><br><span class="line">    swap(&amp;x, &amp;y);  <span class="comment">// 传递地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;x = %d, y = %d\n&quot;</span>, x, y);  <span class="comment">// x = 10, y = 5</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="函数返回指针">函数返回指针</h5>
<p>函数可以返回指针，但应避免返回局部变量的地址。</p>
<p>示例：返回动态分配的内存</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *<span class="title function_">createArray</span><span class="params">(<span class="type">int</span> size)</span> &#123;</span><br><span class="line">    <span class="type">int</span> *arr = (<span class="type">int</span> *)<span class="built_in">malloc</span>(size * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> *myArray = createArray(<span class="number">5</span>);</span><br><span class="line">    <span class="comment">// 使用myArray</span></span><br><span class="line">    <span class="built_in">free</span>(myArray);  <span class="comment">// 记得释放内存</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="动态内存分配">动态内存分配</h4>
<p>C语言提供了四个标准库函数用于动态内存管理，需要包含头文件<code>stdlib.h</code>。</p>
<h5 id="malloc函数">malloc函数</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">malloc</span><span class="params">(<span class="type">size_t</span> size)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>分配size字节的内存</li>
<li>返回指向分配内存的指针，如果失败返回NULL</li>
<li>分配的内存未初始化</li>
</ul>
<p>示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *ptr = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="number">5</span> * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"><span class="keyword">if</span> (ptr != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="comment">// 使用内存</span></span><br><span class="line">    ptr[<span class="number">0</span>] = <span class="number">1</span>;  <span class="comment">// 初始化第一个元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="calloc函数">calloc函数</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">calloc</span><span class="params">(<span class="type">size_t</span> num, <span class="type">size_t</span> size)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>分配num个大小为size的内存块</li>
<li>返回指向分配内存的指针，如果失败返回NULL</li>
<li>分配的内存初始化为0</li>
</ul>
<p>示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *ptr = (<span class="type">int</span> *)<span class="built_in">calloc</span>(<span class="number">5</span>, <span class="keyword">sizeof</span>(<span class="type">int</span>));  <span class="comment">// 5个int，每个初始化为0</span></span><br></pre></td></tr></table></figure>
<h5 id="realloc函数">realloc函数</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">realloc</span><span class="params">(<span class="type">void</span> *ptr, <span class="type">size_t</span> size)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>调整之前分配的内存块大小</li>
<li>返回指向新内存的指针，如果失败返回NULL</li>
<li>如果ptr为NULL，等同于malloc(size)</li>
</ul>
<p>示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *ptr = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="number">5</span> * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"><span class="comment">// ... 使用ptr ...</span></span><br><span class="line">ptr = (<span class="type">int</span> *)<span class="built_in">realloc</span>(ptr, <span class="number">10</span> * <span class="keyword">sizeof</span>(<span class="type">int</span>));  <span class="comment">// 扩大到10个int</span></span><br></pre></td></tr></table></figure>
<h5 id="free函数">free函数</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">free</span><span class="params">(<span class="type">void</span> *ptr)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>释放之前分配的内存</li>
<li>释放后应将指针设置为NULL，避免悬空指针</li>
</ul>
<p>示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">free</span>(ptr);</span><br><span class="line">ptr = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>
<h4 id="指针算术运算">指针算术运算</h4>
<p>指针可以进行算术运算，但运算的单位是指针所指向类型的大小。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[] = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>&#125;;</span><br><span class="line"><span class="type">int</span> *p = arr;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;*p = %d\n&quot;</span>, *p);      <span class="comment">// 10</span></span><br><span class="line">p++;                           <span class="comment">// 指向下一个元素，即arr[1]</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;*p = %d\n&quot;</span>, *p);      <span class="comment">// 20</span></span><br><span class="line"></span><br><span class="line">p = arr + <span class="number">2</span>;                   <span class="comment">// 指向arr[2]</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;*p = %d\n&quot;</span>, *p);      <span class="comment">// 30</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> diff = (arr + <span class="number">4</span>) - arr;    <span class="comment">// 计算元素个数差</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;元素个数差: %d\n&quot;</span>, diff);  <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>
<h3 id="2-6-字符串处理">2.6 字符串处理</h3>
<h4 id="字符串表示与存储">字符串表示与存储</h4>
<p>在C语言中，字符串是字符的数组，以空字符<code>'\0'</code>结尾。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str1[] = &#123;<span class="string">&#x27;H&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;\0&#x27;</span>&#125;;</span><br><span class="line"><span class="type">char</span> str2[] = <span class="string">&quot;Hello&quot;</span>;  <span class="comment">// 自动添加&#x27;\0&#x27;</span></span><br></pre></td></tr></table></figure>
<h4 id="标准库字符串函数">标准库字符串函数</h4>
<p>C语言标准库提供了多个字符串处理函数，需要包含头文件<code>string.h</code>。</p>
<h5 id="strlen函数">strlen函数</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">strlen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>计算字符串长度（不包含终止符’\0’）</li>
</ul>
<p>示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[] = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;长度: %zu\n&quot;</span>, <span class="built_in">strlen</span>(str));  <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>
<h5 id="strcpy函数">strcpy函数</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">strcpy</span><span class="params">(<span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *src)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>将src复制到dest</li>
<li>确保dest足够大，否则会导致缓冲区溢出</li>
</ul>
<p>示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> src[] = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">char</span> dest[<span class="number">20</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(dest, src);  <span class="comment">// dest现在包含&quot;Hello&quot;</span></span><br></pre></td></tr></table></figure>
<h5 id="strcat函数">strcat函数</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">strcat</span><span class="params">(<span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *src)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>将src追加到dest末尾</li>
<li>确保dest足够大</li>
</ul>
<p>示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str1[<span class="number">20</span>] = <span class="string">&quot;Hello &quot;</span>;</span><br><span class="line"><span class="type">char</span> str2[] = <span class="string">&quot;World!&quot;</span>;</span><br><span class="line"><span class="built_in">strcat</span>(str1, str2);  <span class="comment">// str1现在是&quot;Hello World!&quot;</span></span><br></pre></td></tr></table></figure>
<h5 id="strcmp函数">strcmp函数</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">strcmp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s1, <span class="type">const</span> <span class="type">char</span> *s2)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>比较两个字符串</li>
<li>如果s1 &lt; s2，返回负数</li>
<li>如果s1 == s2，返回0</li>
<li>如果s1 &gt; s2，返回正数</li>
</ul>
<p>示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str1[] = <span class="string">&quot;apple&quot;</span>;</span><br><span class="line"><span class="type">char</span> str2[] = <span class="string">&quot;banana&quot;</span>;</span><br><span class="line"><span class="type">int</span> result = <span class="built_in">strcmp</span>(str1, str2);  <span class="comment">// 结果为负</span></span><br></pre></td></tr></table></figure>
<h4 id="字符数组与字符串指针">字符数组与字符串指针</h4>
<p>字符串可以存储在字符数组中，也可以通过字符指针访问。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字符数组</span></span><br><span class="line"><span class="type">char</span> str1[] = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串指针（指向字符串常量）</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *str2 = <span class="string">&quot;World&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>注意：字符串指针指向的字符串常量通常不能修改。</p>
<h4 id="字符串输入输出">字符串输入输出</h4>
<h5 id="输出字符串">输出字符串</h5>
<p>使用printf函数的%s格式说明符：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[] = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, str);</span><br></pre></td></tr></table></figure>
<h5 id="输入字符串">输入字符串</h5>
<p>使用scanf函数的%s格式说明符（不读取空格）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入姓名: &quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, name);  <span class="comment">// 注意name前没有&amp;符号</span></span><br></pre></td></tr></table></figure>
<p>读取包含空格的字符串，可以使用fgets函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入姓名: &quot;</span>);</span><br><span class="line">fgets(name, <span class="keyword">sizeof</span>(name), <span class="built_in">stdin</span>);  <span class="comment">// 读取整行，包括空格</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除可能的换行符</span></span><br><span class="line"><span class="type">int</span> len = <span class="built_in">strlen</span>(name);</span><br><span class="line"><span class="keyword">if</span> (len &gt; <span class="number">0</span> &amp;&amp; name[len<span class="number">-1</span>] == <span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line">    name[len<span class="number">-1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-7-结构体与联合体">2.7 结构体与联合体</h3>
<h4 id="结构体定义与使用">结构体定义与使用</h4>
<p>结构体是一种用户定义的数据类型，可以包含不同类型的成员变量。</p>
<h5 id="结构体定义">结构体定义</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> 结构体名 &#123;</span></span><br><span class="line">    数据类型 成员名<span class="number">1</span>;</span><br><span class="line">    数据类型 成员名<span class="number">2</span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">50</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">float</span> height;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="结构体变量声明与初始化">结构体变量声明与初始化</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明结构体变量</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> <span class="title">person1</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化结构体变量</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> <span class="title">person2</span> =</span> &#123;<span class="string">&quot;Alice&quot;</span>, <span class="number">25</span>, <span class="number">1.65</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// C99指定初始化</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> <span class="title">person3</span> =</span> &#123;</span><br><span class="line">    .name = <span class="string">&quot;Bob&quot;</span>,</span><br><span class="line">    .age = <span class="number">30</span>,</span><br><span class="line">    .height = <span class="number">1.75</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="访问结构体成员">访问结构体成员</h5>
<p>使用点运算符<code>.</code>访问结构体成员：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">person1.age = <span class="number">28</span>;</span><br><span class="line"><span class="built_in">strcpy</span>(person1.name, <span class="string">&quot;Charlie&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;姓名: %s, 年龄: %d\n&quot;</span>, person1.name, person1.age);</span><br></pre></td></tr></table></figure>
<h4 id="结构体数组与指针">结构体数组与指针</h4>
<h5 id="结构体数组">结构体数组</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> <span class="title">people</span>[3] =</span> &#123;</span><br><span class="line">    &#123;<span class="string">&quot;Alice&quot;</span>, <span class="number">25</span>, <span class="number">1.65</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;Bob&quot;</span>, <span class="number">30</span>, <span class="number">1.75</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;Charlie&quot;</span>, <span class="number">35</span>, <span class="number">1.80</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s, %d岁, %.2f米\n&quot;</span>, </span><br><span class="line">           people[i].name, people[i].age, people[i].height);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="结构体指针">结构体指针</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> <span class="title">person</span> =</span> &#123;<span class="string">&quot;David&quot;</span>, <span class="number">22</span>, <span class="number">1.70</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> *<span class="title">ptr</span> =</span> &amp;person;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用箭头运算符-&gt;访问成员</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;姓名: %s\n&quot;</span>, ptr-&gt;name);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;年龄: %d\n&quot;</span>, ptr-&gt;age);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以使用解引用运算符*</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;身高: %.2f\n&quot;</span>, (*ptr).height);</span><br></pre></td></tr></table></figure>
<h4 id="联合体（Union）">联合体（Union）</h4>
<p>联合体与结构体类似，但所有成员共享同一块内存空间。</p>
<h5 id="联合体定义">联合体定义</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> 联合体名 &#123;</span></span><br><span class="line">    数据类型 成员名<span class="number">1</span>;</span><br><span class="line">    数据类型 成员名<span class="number">2</span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">Data</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">float</span> f;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="联合体使用">联合体使用</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">Data</span> <span class="title">data</span>;</span></span><br><span class="line">data.i = <span class="number">100</span>;          <span class="comment">// 使用整型成员</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;data.i = %d\n&quot;</span>, data.i);  <span class="comment">// 100</span></span><br><span class="line"></span><br><span class="line">data.f = <span class="number">3.14</span>;         <span class="comment">// 现在使用浮点型成员，覆盖了之前的整数值</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;data.f = %.2f\n&quot;</span>, data.f);  <span class="comment">// 3.14</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;data.i = %d\n&quot;</span>, data.i);  <span class="comment">// 可能是一个奇怪的整数</span></span><br></pre></td></tr></table></figure>
<p>联合体的大小等于其最大成员的大小。</p>
<h4 id="枚举类型（Enum）">枚举类型（Enum）</h4>
<p>枚举是一种用户定义的整数类型，用于为整数值指定有意义的名称。</p>
<h5 id="枚举定义">枚举定义</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> 枚举名 &#123;</span></span><br><span class="line">    常量<span class="number">1</span>,</span><br><span class="line">    常量<span class="number">2</span>,</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>默认情况下，枚举常量的值从0开始递增。</p>
<p>示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Weekday</span> &#123;</span></span><br><span class="line">    MONDAY,    <span class="comment">// 0</span></span><br><span class="line">    TUESDAY,   <span class="comment">// 1</span></span><br><span class="line">    WEDNESDAY, <span class="comment">// 2</span></span><br><span class="line">    THURSDAY,  <span class="comment">// 3</span></span><br><span class="line">    FRIDAY,    <span class="comment">// 4</span></span><br><span class="line">    SATURDAY,  <span class="comment">// 5</span></span><br><span class="line">    SUNDAY     <span class="comment">// 6</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>可以指定枚举常量的值：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Color</span> &#123;</span></span><br><span class="line">    RED = <span class="number">1</span>,</span><br><span class="line">    GREEN = <span class="number">2</span>,</span><br><span class="line">    BLUE = <span class="number">4</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="枚举使用">枚举使用</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Weekday</span> <span class="title">today</span> =</span> WEDNESDAY;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;今天是星期%d\n&quot;</span>, today + <span class="number">1</span>);  <span class="comment">// 今天是星期4</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Color</span> <span class="title">myColor</span> =</span> GREEN;</span><br><span class="line"><span class="keyword">if</span> (myColor == GREEN) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;绿色\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="位域">位域</h4>
<p>位域是一种特殊的结构体成员，可以指定成员占用的位数，用于节省内存。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Flags</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> flag1 : <span class="number">1</span>;  <span class="comment">// 1位</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> flag2 : <span class="number">1</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> flag3 : <span class="number">2</span>;  <span class="comment">// 2位</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> : <span class="number">4</span>;        <span class="comment">// 4位的填充位</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Flags</span> <span class="title">f</span>;</span></span><br><span class="line">f.flag1 = <span class="number">1</span>;</span><br><span class="line">f.flag2 = <span class="number">0</span>;</span><br><span class="line">f.flag3 = <span class="number">3</span>;  <span class="comment">// 二进制11</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;flag1: %u\n&quot;</span>, f.flag1);  <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;flag2: %u\n&quot;</span>, f.flag2);  <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;flag3: %u\n&quot;</span>, f.flag3);  <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;结构体大小: %lu 字节\n&quot;</span>, <span class="keyword">sizeof</span>(f));  <span class="comment">// 通常为4字节（一个unsigned int的大小）</span></span><br></pre></td></tr></table></figure>
<p>位域常用于表示需要紧凑存储的标志位或状态信息。</p>
<h2 id="3-C-语言基础与扩展">3. C++语言基础与扩展</h2>
<h3 id="3-1-C-对C的扩展">3.1 C++对C的扩展</h3>
<p>C++在保留C语言核心功能的基础上，增加了许多强大的特性，使代码更加灵活、安全和可维护。</p>
<h4 id="命名空间（namespace）">命名空间（namespace）</h4>
<p>命名空间是C++提供的一种解决命名冲突的机制，它允许将标识符（变量、函数、类等）封装在不同的作用域中。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 命名空间定义</span></span><br><span class="line"><span class="keyword">namespace</span> MyProject &#123;</span><br><span class="line">    <span class="type">int</span> version = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;MyProject version: &quot;</span> &lt;&lt; version &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">namespace</span> Utils &#123;</span><br><span class="line">        <span class="comment">// 命名空间嵌套</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">helperFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Helper function called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 命名空间使用</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 使用作用域解析运算符</span></span><br><span class="line">    MyProject::<span class="built_in">printInfo</span>();</span><br><span class="line">    MyProject::Utils::<span class="built_in">helperFunction</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 使用using声明</span></span><br><span class="line">    <span class="keyword">using</span> MyProject::version;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Version: &quot;</span> &lt;&lt; version &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. 使用using指令</span></span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> MyProject;</span><br><span class="line">    <span class="built_in">printInfo</span>();  <span class="comment">// 直接使用命名空间内的函数</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：在头文件中应避免使用<code>using namespace std;</code>，以防止命名空间污染。</p>
<h4 id="输入输出流：cin、cout">输入输出流：cin、cout</h4>
<p>C++提供了类型安全的I/O流库，使用起来比C的printf/scanf更方便、更安全。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 输出</span></span><br><span class="line">    <span class="type">int</span> age = <span class="number">25</span>;</span><br><span class="line">    std::string name = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;姓名: &quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot;, 年龄: &quot;</span> &lt;&lt; age &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;PI = &quot;</span> &lt;&lt; <span class="number">3.14159</span> &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输入</span></span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;请输入一个数字: &quot;</span>;</span><br><span class="line">    std::cin &gt;&gt; num;</span><br><span class="line">    </span><br><span class="line">    std::string line;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;请输入一行文本: &quot;</span>;</span><br><span class="line">    std::cin.<span class="built_in">ignore</span>();  <span class="comment">// 忽略之前输入留下的换行符</span></span><br><span class="line">    std::<span class="built_in">getline</span>(std::cin, line);  <span class="comment">// 读取整行</span></span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;你输入的数字是: &quot;</span> &lt;&lt; num &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;你输入的文本是: &quot;</span> &lt;&lt; line &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="引用（Reference）">引用（Reference）</h4>
<p>引用是一个已存在变量的别名，它必须在创建时初始化，并且之后不能更改引用的目标。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> original = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span>&amp; ref = original;  <span class="comment">// ref是original的引用</span></span><br><span class="line">    </span><br><span class="line">    ref = <span class="number">20</span>;  <span class="comment">// 修改引用会修改原始变量</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;original = &quot;</span> &lt;&lt; original &lt;&lt; std::endl;  <span class="comment">// 输出20</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;ref = &quot;</span> &lt;&lt; ref &lt;&lt; std::endl;  <span class="comment">// 输出20</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 引用作为函数参数（传引用）</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span>&amp; a, <span class="type">int</span>&amp; b)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> temp = a;</span><br><span class="line">        a = b;</span><br><span class="line">        b = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> x = <span class="number">5</span>, y = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">swap</span>(x, y);  <span class="comment">// 直接修改原始变量</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>引用的特性：</p>
<ul>
<li>必须在定义时初始化</li>
<li>不能有空引用</li>
<li>不能改变引用指向的变量</li>
<li>引用的大小与原变量相同（本质上是指针，但语法更简洁）</li>
</ul>
<h4 id="函数重载（Function-Overloading）">函数重载（Function Overloading）</h4>
<p>函数重载允许在同一作用域内定义多个同名函数，只要它们的参数列表不同（类型、数量或顺序）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不同参数类型</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">add</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不同参数数量</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b + c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不同参数顺序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printInfo</span><span class="params">(std::string name, <span class="type">int</span> age)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;姓名: &quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot;, 年龄: &quot;</span> &lt;&lt; age &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printInfo</span><span class="params">(<span class="type">int</span> age, std::string name)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;年龄: &quot;</span> &lt;&lt; age &lt;&lt; <span class="string">&quot;, 姓名: &quot;</span> &lt;&lt; name &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">add</span>(<span class="number">5</span>, <span class="number">3</span>) &lt;&lt; std::endl;       <span class="comment">// 调用int版本</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">add</span>(<span class="number">3.14</span>, <span class="number">2.71</span>) &lt;&lt; std::endl; <span class="comment">// 调用double版本</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">add</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) &lt;&lt; std::endl;    <span class="comment">// 调用三参数版本</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printInfo</span>(<span class="string">&quot;张三&quot;</span>, <span class="number">25</span>);</span><br><span class="line">    <span class="built_in">printInfo</span>(<span class="number">30</span>, <span class="string">&quot;李四&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：函数重载不能仅通过返回类型不同来区分。</p>
<h4 id="内联函数（Inline-Function）">内联函数（Inline Function）</h4>
<p>内联函数是一种在编译时将函数调用替换为函数体的优化技术，适用于小型、频繁调用的函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 内联函数定义</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a &gt; b) ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> result = <span class="built_in">max</span>(<span class="number">10</span>, <span class="number">15</span>);  <span class="comment">// 可能被编译为：(10 &gt; 15) ? 10 : 15</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;最大值: &quot;</span> &lt;&lt; result &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>内联函数的特点：</p>
<ul>
<li>减少函数调用开销</li>
<li>适合简短的函数（通常1-5行）</li>
<li>编译器可以选择忽略内联请求</li>
<li>通常在头文件中定义，以便在所有编译单元中可见</li>
</ul>
<h4 id="函数默认参数与占位参数">函数默认参数与占位参数</h4>
<p>默认参数允许函数参数在调用时省略，使用预定义的默认值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认参数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">greet</span><span class="params">(std::string name = <span class="string">&quot;Guest&quot;</span>, std::string message = <span class="string">&quot;Hello&quot;</span>)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; message &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot;!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 占位参数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span>)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用默认参数</span></span><br><span class="line">    <span class="built_in">greet</span>();                    <span class="comment">// Hello, Guest!</span></span><br><span class="line">    <span class="built_in">greet</span>(<span class="string">&quot;张三&quot;</span>);               <span class="comment">// Hello, 张三!</span></span><br><span class="line">    <span class="built_in">greet</span>(<span class="string">&quot;李四&quot;</span>, <span class="string">&quot;你好&quot;</span>);        <span class="comment">// 你好, 李四!</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用占位参数</span></span><br><span class="line">    <span class="built_in">func</span>(<span class="number">10</span>, <span class="number">20</span>);  <span class="comment">// 第二个参数被忽略</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意事项：</p>
<ul>
<li>默认参数必须从右向左连续设置</li>
<li>函数声明和定义中，默认参数只能出现一次</li>
</ul>
<h4 id="const修饰符增强">const修饰符增强</h4>
<p>C++中const的用法比C更丰富，主要用于：</p>
<ol>
<li><strong>常量变量</strong>：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> MAX_SIZE = <span class="number">100</span>;</span><br><span class="line"><span class="comment">// MAX_SIZE = 200;  // 错误：不能修改常量</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li><strong>const引用</strong>：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> value = <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; ref = value;  <span class="comment">// 只读引用</span></span><br><span class="line"><span class="comment">// ref = 20;  // 错误：不能修改</span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li><strong>const指针</strong>：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span>* p1 = &amp;value;  <span class="comment">// 指向常量的指针</span></span><br><span class="line"><span class="comment">// *p1 = 30;  // 错误</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span>* <span class="type">const</span> p2 = &amp;value;  <span class="comment">// 常量指针</span></span><br><span class="line"><span class="comment">// p2 = &amp;other;  // 错误</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* <span class="type">const</span> p3 = &amp;value;  <span class="comment">// 指向常量的常量指针</span></span><br></pre></td></tr></table></figure>
<ol start="4">
<li><strong>const成员函数</strong>：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(std::string n) : <span class="built_in">name</span>(n) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// const成员函数不能修改成员变量</span></span><br><span class="line">    <span class="function">std::string <span class="title">getName</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="comment">// name = &quot;新名字&quot;;  // 错误</span></span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="作用域解析运算符">作用域解析运算符::</h4>
<p>作用域解析运算符用于访问特定作用域内的标识符：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> value = <span class="number">100</span>;  <span class="comment">// 全局变量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> MySpace &#123;</span><br><span class="line">    <span class="type">int</span> value = <span class="number">200</span>;  <span class="comment">// 命名空间变量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> value;  <span class="comment">// 静态成员</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> MyClass::value = <span class="number">300</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> value = <span class="number">50</span>;  <span class="comment">// 局部变量</span></span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; value &lt;&lt; std::endl;          <span class="comment">// 50（局部变量）</span></span><br><span class="line">    std::cout &lt;&lt; ::value &lt;&lt; std::endl;        <span class="comment">// 100（全局变量）</span></span><br><span class="line">    std::cout &lt;&lt; MySpace::value &lt;&lt; std::endl; <span class="comment">// 200（命名空间变量）</span></span><br><span class="line">    std::cout &lt;&lt; MyClass::value &lt;&lt; std::endl; <span class="comment">// 300（类静态成员）</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-2-面向对象编程基础">3.2 面向对象编程基础</h3>
<p>面向对象编程（OOP）是一种编程范式，它使用&quot;对象&quot;来设计应用程序和计算机程序。C++提供了完整的OOP支持。</p>
<h4 id="类与对象概念">类与对象概念</h4>
<p><strong>类</strong>是用户定义的数据类型，它封装了数据（成员变量）和操作这些数据的函数（成员函数）。<br>
<strong>对象</strong>是类的实例，一个类可以创建多个对象。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类的定义</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:  <span class="comment">// 访问控制符</span></span><br><span class="line">    <span class="comment">// 成员变量（属性）</span></span><br><span class="line">    std::string name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    std::string address;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:  <span class="comment">// 访问控制符</span></span><br><span class="line">    <span class="comment">// 成员函数（方法）</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setInfo</span><span class="params">(std::string n, <span class="type">int</span> a, std::string addr)</span> </span>&#123;</span><br><span class="line">        name = n;</span><br><span class="line">        age = a;</span><br><span class="line">        address = addr;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">displayInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;姓名: &quot;</span> &lt;&lt; name &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;年龄: &quot;</span> &lt;&lt; age &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;地址: &quot;</span> &lt;&lt; address &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建对象（类的实例）</span></span><br><span class="line">    Person person1;</span><br><span class="line">    person<span class="number">1.</span><span class="built_in">setInfo</span>(<span class="string">&quot;张三&quot;</span>, <span class="number">25</span>, <span class="string">&quot;北京市朝阳区&quot;</span>);</span><br><span class="line">    person<span class="number">1.</span><span class="built_in">displayInfo</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建另一个对象</span></span><br><span class="line">    Person person2;</span><br><span class="line">    person<span class="number">2.</span><span class="built_in">setInfo</span>(<span class="string">&quot;李四&quot;</span>, <span class="number">30</span>, <span class="string">&quot;上海市浦东新区&quot;</span>);</span><br><span class="line">    person<span class="number">2.</span><span class="built_in">displayInfo</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="封装">封装</h4>
<p>封装是OOP的三大特性之一（封装、继承、多态），它将数据和操作数据的函数结合在一起，隐藏对象的内部细节，仅对外提供必要的接口。</p>
<p>C++通过访问控制符实现封装：</p>
<ul>
<li><code>public</code>: 公开成员，可以在任何地方访问</li>
<li><code>private</code>: 私有成员，只能在类的内部访问</li>
<li><code>protected</code>: 保护成员，在类内部和子类中可以访问</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BankAccount</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 私有数据成员，隐藏内部细节</span></span><br><span class="line">    std::string accountNumber;</span><br><span class="line">    <span class="type">double</span> balance;</span><br><span class="line">    std::string ownerName;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 公开接口，提供必要的访问方式</span></span><br><span class="line">    <span class="built_in">BankAccount</span>(std::string accNum, std::string name) &#123;</span><br><span class="line">        accountNumber = accNum;</span><br><span class="line">        ownerName = name;</span><br><span class="line">        balance = <span class="number">0.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 存款方法</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">deposit</span><span class="params">(<span class="type">double</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (amount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            balance += amount;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;存款成功，金额: &quot;</span> &lt;&lt; amount &lt;&lt; std::endl;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;存款金额必须大于0&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 取款方法</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">withdraw</span><span class="params">(<span class="type">double</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (amount &gt; <span class="number">0</span> &amp;&amp; amount &lt;= balance) &#123;</span><br><span class="line">            balance -= amount;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;取款成功，金额: &quot;</span> &lt;&lt; amount &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;取款金额无效或余额不足&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 查询余额方法</span></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">getBalance</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> balance;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 显示账户信息</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">displayAccountInfo</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;账户号码: &quot;</span> &lt;&lt; accountNumber &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;户主姓名: &quot;</span> &lt;&lt; ownerName &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;账户余额: &quot;</span> &lt;&lt; balance &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">BankAccount <span class="title">account</span><span class="params">(<span class="string">&quot;1234567890&quot;</span>, <span class="string">&quot;张三&quot;</span>)</span></span>;</span><br><span class="line">    account.<span class="built_in">displayAccountInfo</span>();</span><br><span class="line">    </span><br><span class="line">    account.<span class="built_in">deposit</span>(<span class="number">1000.0</span>);</span><br><span class="line">    account.<span class="built_in">withdraw</span>(<span class="number">500.0</span>);</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;当前余额: &quot;</span> &lt;&lt; account.<span class="built_in">getBalance</span>() &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// account.balance = 1000000;  // 错误：无法直接访问私有成员</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="构造函数与析构函数">构造函数与析构函数</h4>
<p><strong>构造函数</strong>是一种特殊的成员函数，在创建对象时自动调用，用于初始化对象。<br>
<strong>析构函数</strong>也是一种特殊的成员函数，在对象销毁时自动调用，用于清理资源。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> width;</span><br><span class="line">    <span class="type">double</span> height;</span><br><span class="line">    <span class="type">double</span>* areaPtr;  <span class="comment">// 动态分配内存的示例</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 默认构造函数</span></span><br><span class="line">    <span class="built_in">Rectangle</span>() &#123;</span><br><span class="line">        width = <span class="number">0</span>;</span><br><span class="line">        height = <span class="number">0</span>;</span><br><span class="line">        areaPtr = <span class="keyword">new</span> <span class="built_in">double</span>(<span class="number">0</span>);  <span class="comment">// 分配内存</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;默认构造函数被调用&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 带参数的构造函数</span></span><br><span class="line">    <span class="built_in">Rectangle</span>(<span class="type">double</span> w, <span class="type">double</span> h) &#123;</span><br><span class="line">        width = w;</span><br><span class="line">        height = h;</span><br><span class="line">        areaPtr = <span class="keyword">new</span> <span class="built_in">double</span>(w * h);  <span class="comment">// 分配内存并计算面积</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;带参数的构造函数被调用&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">Rectangle</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span> areaPtr;  <span class="comment">// 释放内存</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;析构函数被调用，内存已释放&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 成员函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setDimensions</span><span class="params">(<span class="type">double</span> w, <span class="type">double</span> h)</span> </span>&#123;</span><br><span class="line">        width = w;</span><br><span class="line">        height = h;</span><br><span class="line">        *areaPtr = width * height;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">getArea</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> *areaPtr;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">displayInfo</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;宽度: &quot;</span> &lt;&lt; width &lt;&lt; <span class="string">&quot;, 高度: &quot;</span> &lt;&lt; height &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;面积: &quot;</span> &lt;&lt; *areaPtr &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用默认构造函数</span></span><br><span class="line">    Rectangle rect1;</span><br><span class="line">    rect<span class="number">1.</span><span class="built_in">displayInfo</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用带参数的构造函数</span></span><br><span class="line">    <span class="function">Rectangle <span class="title">rect2</span><span class="params">(<span class="number">5.0</span>, <span class="number">3.0</span>)</span></span>;</span><br><span class="line">    rect<span class="number">2.</span><span class="built_in">displayInfo</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 当函数结束时，对象将被销毁，析构函数会被调用</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;程序即将结束&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>构造函数的特点：</p>
<ul>
<li>函数名与类名相同</li>
<li>没有返回类型</li>
<li>可以重载</li>
<li>可以有默认参数</li>
<li>对象创建时自动调用</li>
</ul>
<p>析构函数的特点：</p>
<ul>
<li>函数名是类名前加波浪号（~）</li>
<li>没有返回类型，没有参数</li>
<li>不能重载</li>
<li>对象销毁时自动调用</li>
<li>通常用于释放动态分配的内存等资源</li>
</ul>
<h4 id="拷贝构造函数与赋值运算符">拷贝构造函数与赋值运算符</h4>
<p><strong>拷贝构造函数</strong>用于通过一个已存在的对象创建一个新对象。<br>
<strong>赋值运算符重载</strong>用于将一个对象的值赋给另一个已存在的对象。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">String</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span>* buffer;</span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">String</span>(<span class="type">const</span> <span class="type">char</span>* str = <span class="string">&quot;&quot;</span>) &#123;</span><br><span class="line">        length = <span class="built_in">strlen</span>(str);</span><br><span class="line">        buffer = <span class="keyword">new</span> <span class="type">char</span>[length + <span class="number">1</span>];  <span class="comment">// 分配内存（包括结束符）</span></span><br><span class="line">        <span class="built_in">strcpy</span>(buffer, str);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;构造函数: \&quot;&quot;</span> &lt;&lt; buffer &lt;&lt; <span class="string">&quot;\&quot;&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 拷贝构造函数</span></span><br><span class="line">    <span class="built_in">String</span>(<span class="type">const</span> String&amp; other) &#123;</span><br><span class="line">        length = other.length;</span><br><span class="line">        buffer = <span class="keyword">new</span> <span class="type">char</span>[length + <span class="number">1</span>];  <span class="comment">// 深拷贝</span></span><br><span class="line">        <span class="built_in">strcpy</span>(buffer, other.buffer);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;拷贝构造函数: \&quot;&quot;</span> &lt;&lt; buffer &lt;&lt; <span class="string">&quot;\&quot;&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 赋值运算符重载</span></span><br><span class="line">    String&amp; <span class="keyword">operator</span>=(<span class="type">const</span> String&amp; other) &#123;</span><br><span class="line">        <span class="comment">// 自我赋值检查</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;other) &#123;</span><br><span class="line">            <span class="comment">// 释放旧内存</span></span><br><span class="line">            <span class="keyword">delete</span>[] buffer;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 深拷贝</span></span><br><span class="line">            length = other.length;</span><br><span class="line">            buffer = <span class="keyword">new</span> <span class="type">char</span>[length + <span class="number">1</span>];</span><br><span class="line">            <span class="built_in">strcpy</span>(buffer, other.buffer);</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;赋值运算符: \&quot;&quot;</span> &lt;&lt; buffer &lt;&lt; <span class="string">&quot;\&quot;&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">String</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] buffer;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;析构函数: 释放内存&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取字符串内容</span></span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">getBuffer</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> buffer;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取字符串长度</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getLength</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用构造函数</span></span><br><span class="line">    <span class="function">String <span class="title">s1</span><span class="params">(<span class="string">&quot;Hello&quot;</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用拷贝构造函数</span></span><br><span class="line">    String s2 = s1;  <span class="comment">// 或 String s2(s1);</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用赋值运算符</span></span><br><span class="line">    <span class="function">String <span class="title">s3</span><span class="params">(<span class="string">&quot;World&quot;</span>)</span></span>;</span><br><span class="line">    s3 = s1;  <span class="comment">// 赋值操作</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输出结果</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;s1: \&quot;&quot;</span> &lt;&lt; s<span class="number">1.</span><span class="built_in">getBuffer</span>() &lt;&lt; <span class="string">&quot;\&quot; (长度: &quot;</span> &lt;&lt; s<span class="number">1.</span><span class="built_in">getLength</span>() &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;s2: \&quot;&quot;</span> &lt;&lt; s<span class="number">2.</span><span class="built_in">getBuffer</span>() &lt;&lt; <span class="string">&quot;\&quot; (长度: &quot;</span> &lt;&lt; s<span class="number">2.</span><span class="built_in">getLength</span>() &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;s3: \&quot;&quot;</span> &lt;&lt; s<span class="number">3.</span><span class="built_in">getBuffer</span>() &lt;&lt; <span class="string">&quot;\&quot; (长度: &quot;</span> &lt;&lt; s<span class="number">3.</span><span class="built_in">getLength</span>() &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>拷贝构造函数的调用时机：</p>
<ul>
<li>使用一个对象初始化另一个对象时</li>
<li>函数参数按值传递对象时</li>
<li>函数返回值为对象时</li>
</ul>
<h4 id="静态成员">静态成员</h4>
<p>静态成员属于类而不属于对象，所有对象共享同一份静态成员。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 静态成员变量</span></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> count;  <span class="comment">// 声明</span></span><br><span class="line">    <span class="type">int</span> id;  <span class="comment">// 非静态成员变量</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">Counter</span>() &#123;</span><br><span class="line">        count++;</span><br><span class="line">        id = count;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;创建对象 #&quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot;, 总对象数: &quot;</span> &lt;&lt; count &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">Counter</span>() &#123;</span><br><span class="line">        count--;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;销毁对象 #&quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot;, 剩余对象数: &quot;</span> &lt;&lt; count &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 静态成员函数</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 静态成员函数只能访问静态成员变量</span></span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">        <span class="comment">// return id;  // 错误：不能访问非静态成员</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取对象ID</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getId</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态成员变量的定义和初始化</span></span><br><span class="line"><span class="type">int</span> Counter::count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 访问静态成员函数（不需要创建对象）</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;当前对象数: &quot;</span> &lt;&lt; Counter::<span class="built_in">getCount</span>() &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建对象</span></span><br><span class="line">    Counter c1;</span><br><span class="line">    Counter c2;</span><br><span class="line">    </span><br><span class="line">    &#123;  <span class="comment">// 新的作用域</span></span><br><span class="line">        Counter c3;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;作用域内对象数: &quot;</span> &lt;&lt; Counter::<span class="built_in">getCount</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;  <span class="comment">// c3在此处销毁</span></span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;作用域外对象数: &quot;</span> &lt;&lt; Counter::<span class="built_in">getCount</span>() &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>静态成员的特点：</p>
<ul>
<li>静态成员变量需要在类外定义和初始化</li>
<li>静态成员函数可以通过类名直接调用，不需要对象</li>
<li>静态成员函数只能访问静态成员变量和其他静态成员函数</li>
</ul>
<h4 id="this指针">this指针</h4>
<p><code>this</code>指针是一个指向当前对象的常量指针，它隐含在每个非静态成员函数中。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数使用this指针</span></span><br><span class="line">    <span class="built_in">Student</span>(std::string name, <span class="type">int</span> age) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;name = name;  <span class="comment">// 区分成员变量和参数名</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回当前对象的引用，支持链式调用</span></span><br><span class="line">    <span class="function">Student&amp; <span class="title">setName</span><span class="params">(std::string name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;  <span class="comment">// 返回当前对象的引用</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">Student&amp; <span class="title">setAge</span><span class="params">(<span class="type">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用this指针访问成员</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">displayInfo</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;姓名: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;name &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;年龄: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;age &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 比较两个对象是否相等</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isEqual</span><span class="params">(<span class="type">const</span> Student&amp; other)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span> != &amp;other &amp;&amp;  <span class="comment">// 避免自我比较（可选）</span></span><br><span class="line">               <span class="keyword">this</span>-&gt;name == other.name &amp;&amp; </span><br><span class="line">               <span class="keyword">this</span>-&gt;age == other.age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Student <span class="title">student1</span><span class="params">(<span class="string">&quot;张三&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">    student<span class="number">1.</span><span class="built_in">displayInfo</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 链式调用</span></span><br><span class="line">    <span class="function">Student <span class="title">student2</span><span class="params">(<span class="string">&quot;&quot;</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    student<span class="number">2.</span><span class="built_in">setName</span>(<span class="string">&quot;李四&quot;</span>).<span class="built_in">setAge</span>(<span class="number">22</span>);</span><br><span class="line">    student<span class="number">2.</span><span class="built_in">displayInfo</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 比较对象</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;student1 和 student2 是否相等: &quot;</span> </span><br><span class="line">              &lt;&lt; (student<span class="number">1.</span><span class="built_in">isEqual</span>(student2) ? <span class="string">&quot;是&quot;</span> : <span class="string">&quot;否&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>this指针的用途：</p>
<ul>
<li>区分成员变量和局部变量（当它们同名时）</li>
<li>从成员函数返回当前对象</li>
<li>在成员函数中访问当前对象的其他成员</li>
<li>比较两个对象是否为同一个对象</li>
</ul>
<h3 id="3-3-继承与多态">3.3 继承与多态</h3>
<p>继承是面向对象编程的核心特性之一，它允许创建基于现有类的新类，实现代码重用。多态则允许通过基类指针或引用来访问派生类的方法。</p>
<h4 id="继承的概念与语法">继承的概念与语法</h4>
<p>继承使一个类（派生类）可以继承另一个类（基类）的成员变量和成员函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基类（父类）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">bool</span> isAlive;  <span class="comment">// 保护成员，派生类可以访问</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">Animal</span>(std::string n, <span class="type">int</span> a) : <span class="built_in">name</span>(n), <span class="built_in">age</span>(a), <span class="built_in">isAlive</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;创建动物: &quot;</span> &lt;&lt; name &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 普通成员函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setName</span><span class="params">(std::string n)</span> </span>&#123;</span><br><span class="line">        name = n;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">std::string <span class="title">getName</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setAge</span><span class="params">(<span class="type">int</span> a)</span> </span>&#123;</span><br><span class="line">        age = a;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getAge</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 普通函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; name &lt;&lt; <span class="string">&quot; 正在进食&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 虚函数（为多态做准备）</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">makeSound</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; name &lt;&lt; <span class="string">&quot; 发出未知声音&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">Animal</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;销毁动物: &quot;</span> &lt;&lt; name &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派生类（子类）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> : <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string breed;  <span class="comment">// 特有属性</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数，调用基类构造函数</span></span><br><span class="line">    <span class="built_in">Dog</span>(std::string n, <span class="type">int</span> a, std::string b) : <span class="built_in">Animal</span>(n, a), <span class="built_in">breed</span>(b) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;创建狗: &quot;</span> &lt;&lt; <span class="built_in">getName</span>() &lt;&lt; <span class="string">&quot; 品种: &quot;</span> &lt;&lt; breed &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 派生类特有的方法</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setBreed</span><span class="params">(std::string b)</span> </span>&#123;</span><br><span class="line">        breed = b;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">std::string <span class="title">getBreed</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> breed;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 覆盖基类的虚函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">makeSound</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="built_in">getName</span>() &lt;&lt; <span class="string">&quot; 汪汪叫&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 派生类特有的方法</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fetch</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="built_in">getName</span>() &lt;&lt; <span class="string">&quot; 正在捡球&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">Dog</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;销毁狗: &quot;</span> &lt;&lt; <span class="built_in">getName</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 另一个派生类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> : <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">bool</span> hasTail;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Cat</span>(std::string n, <span class="type">int</span> a, <span class="type">bool</span> tail = <span class="literal">true</span>) : <span class="built_in">Animal</span>(n, a), <span class="built_in">hasTail</span>(tail) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;创建猫: &quot;</span> &lt;&lt; <span class="built_in">getName</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 覆盖基类的虚函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">makeSound</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="built_in">getName</span>() &lt;&lt; <span class="string">&quot; 喵喵叫&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 特有方法</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">purr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="built_in">getName</span>() &lt;&lt; <span class="string">&quot; 正在发出呼噜声&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建派生类对象</span></span><br><span class="line">    <span class="function">Dog <span class="title">myDog</span><span class="params">(<span class="string">&quot;旺财&quot;</span>, <span class="number">3</span>, <span class="string">&quot;拉布拉多&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">Cat <span class="title">myCat</span><span class="params">(<span class="string">&quot;咪咪&quot;</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调用继承的方法</span></span><br><span class="line">    myDog.<span class="built_in">eat</span>();</span><br><span class="line">    myCat.<span class="built_in">eat</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调用覆盖的方法</span></span><br><span class="line">    myDog.<span class="built_in">makeSound</span>();</span><br><span class="line">    myCat.<span class="built_in">makeSound</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调用特有方法</span></span><br><span class="line">    myDog.<span class="built_in">fetch</span>();</span><br><span class="line">    myCat.<span class="built_in">purr</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用protected成员</span></span><br><span class="line">    <span class="comment">// myDog.isAlive = false;  // 错误：protected成员在类外不能访问</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="基类与派生类">基类与派生类</h4>
<ul>
<li><strong>基类</strong>：被继承的类，也称为父类或超类</li>
<li><strong>派生类</strong>：继承其他类的类，也称为子类或派生类</li>
</ul>
<p>派生类可以：</p>
<ul>
<li>继承基类的public和protected成员</li>
<li>增加自己的成员变量和成员函数</li>
<li>覆盖基类的虚函数</li>
<li>访问基类的构造函数和析构函数</li>
</ul>
<h4 id="访问控制与继承方式">访问控制与继承方式</h4>
<p>C++支持三种继承方式，它们决定了基类成员在派生类中的访问级别：</p>
<table>
<thead>
<tr>
<th>基类中的访问级别</th>
<th>public继承</th>
<th>protected继承</th>
<th>private继承</th>
</tr>
</thead>
<tbody>
<tr>
<td>public</td>
<td>public</td>
<td>protected</td>
<td>private</td>
</tr>
<tr>
<td>protected</td>
<td>protected</td>
<td>protected</td>
<td>private</td>
</tr>
<tr>
<td>private</td>
<td>不可访问</td>
<td>不可访问</td>
<td>不可访问</td>
</tr>
</tbody>
</table>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> privateVar;  <span class="comment">// 任何继承方式下派生类都不能访问</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> protectedVar;  <span class="comment">// 派生类可以访问</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> publicVar;  <span class="comment">// 公共访问</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">Base</span>() : <span class="built_in">privateVar</span>(<span class="number">1</span>), <span class="built_in">protectedVar</span>(<span class="number">2</span>), <span class="built_in">publicVar</span>(<span class="number">3</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// public继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PublicDerived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">accessBase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// privateVar = 10;  // 错误：不可访问</span></span><br><span class="line">        protectedVar = <span class="number">20</span>;  <span class="comment">// 可访问</span></span><br><span class="line">        publicVar = <span class="number">30</span>;     <span class="comment">// 可访问</span></span><br><span class="line">        </span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;PublicDerived: &quot;</span> &lt;&lt; protectedVar &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; publicVar &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// protected继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProtectedDerived</span> : <span class="keyword">protected</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">accessBase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// privateVar = 10;  // 错误：不可访问</span></span><br><span class="line">        protectedVar = <span class="number">20</span>;  <span class="comment">// 可访问</span></span><br><span class="line">        publicVar = <span class="number">30</span>;     <span class="comment">// 可访问，但在外部看来是protected</span></span><br><span class="line">        </span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;ProtectedDerived: &quot;</span> &lt;&lt; protectedVar &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; publicVar &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// private继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PrivateDerived</span> : <span class="keyword">private</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">accessBase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// privateVar = 10;  // 错误：不可访问</span></span><br><span class="line">        protectedVar = <span class="number">20</span>;  <span class="comment">// 可访问，但在外部看来是private</span></span><br><span class="line">        publicVar = <span class="number">30</span>;     <span class="comment">// 可访问，但在外部看来是private</span></span><br><span class="line">        </span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;PrivateDerived: &quot;</span> &lt;&lt; protectedVar &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; publicVar &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    PublicDerived pub;</span><br><span class="line">    pub.<span class="built_in">accessBase</span>();</span><br><span class="line">    pub.publicVar = <span class="number">40</span>;  <span class="comment">// 可访问，因为是public继承</span></span><br><span class="line">    </span><br><span class="line">    ProtectedDerived pro;</span><br><span class="line">    pro.<span class="built_in">accessBase</span>();</span><br><span class="line">    <span class="comment">// pro.publicVar = 40;  // 错误：publicVar在ProtectedDerived中是protected</span></span><br><span class="line">    </span><br><span class="line">    PrivateDerived pri;</span><br><span class="line">    pri.<span class="built_in">accessBase</span>();</span><br><span class="line">    <span class="comment">// pri.publicVar = 40;  // 错误：publicVar在PrivateDerived中是private</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="多态性：静态多态与动态多态">多态性：静态多态与动态多态</h4>
<p>多态是面向对象编程的重要特性，允许使用统一的接口处理不同的对象。C++支持两种类型的多态：</p>
<p><strong>1. 静态多态（编译时多态）</strong></p>
<p>通过函数重载和运算符重载实现，在编译时确定调用哪个函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数重载示例（静态多态）</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">add</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Calculator</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 运算符重载（静态多态）</span></span><br><span class="line">    <span class="type">int</span> <span class="keyword">operator</span>+(<span class="type">int</span> a) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span> + a;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">double</span> <span class="keyword">operator</span>+(<span class="type">double</span> a) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.0</span> + a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 静态多态：编译时确定调用哪个add函数</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;整数加法: &quot;</span> &lt;&lt; <span class="built_in">add</span>(<span class="number">5</span>, <span class="number">3</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;浮点数加法: &quot;</span> &lt;&lt; <span class="built_in">add</span>(<span class="number">3.14</span>, <span class="number">2.71</span>) &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    Calculator calc;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;运算符重载1: &quot;</span> &lt;&lt; (calc + <span class="number">10</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;运算符重载2: &quot;</span> &lt;&lt; (calc + <span class="number">10.5</span>) &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2. 动态多态（运行时多态）</strong></p>
<p>通过虚函数和继承实现，在运行时确定调用哪个函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Vehicle</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;车辆启动&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;车辆停止&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Vehicle</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> : <span class="keyword">public</span> Vehicle &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;汽车启动，引擎轰鸣&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">stop</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;汽车停止，踩刹车&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bicycle</span> : <span class="keyword">public</span> Vehicle &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;自行车启动，踩踏板&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">stop</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;自行车停止，捏刹车&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用基类指针的函数（动态多态）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">operateVehicle</span><span class="params">(Vehicle* vehicle)</span> </span>&#123;</span><br><span class="line">    vehicle-&gt;<span class="built_in">start</span>();</span><br><span class="line">    <span class="comment">// 模拟运行</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;... 行驶中 ...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    vehicle-&gt;<span class="built_in">stop</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Car car;</span><br><span class="line">    Bicycle bicycle;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 动态多态：运行时确定调用哪个方法</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;===== 操作汽车 ====&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">operateVehicle</span>(&amp;car);</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\n===== 操作自行车 ====&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">operateVehicle</span>(&amp;bicycle);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="虚函数（Virtual-Function）">虚函数（Virtual Function）</h4>
<p>虚函数是在基类中声明的特殊函数，允许派生类重写它，实现动态多态。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    std::string name;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Shape</span>(std::string n) : <span class="built_in">name</span>(n) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 虚函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">calculateArea</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;基类面积计算&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;形状: &quot;</span> &lt;&lt; name &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Shape</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;销毁形状: &quot;</span> &lt;&lt; name &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> : <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> radius;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Circle</span>(std::string n, <span class="type">double</span> r) : <span class="built_in">Shape</span>(n), <span class="built_in">radius</span>(r) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 重写虚函数</span></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">calculateArea</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3.14159</span> * radius * radius;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;圆形: &quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot;, 半径: &quot;</span> &lt;&lt; radius &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建基类指针指向派生类对象</span></span><br><span class="line">    Shape* shape1 = <span class="keyword">new</span> <span class="built_in">Shape</span>(<span class="string">&quot;通用形状&quot;</span>);</span><br><span class="line">    Shape* shape2 = <span class="keyword">new</span> <span class="built_in">Circle</span>(<span class="string">&quot;圆1&quot;</span>, <span class="number">5.0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 动态绑定 - 根据对象实际类型调用方法</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;===== 基类对象 ====&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    shape1-&gt;<span class="built_in">display</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;面积: &quot;</span> &lt;&lt; shape1-&gt;<span class="built_in">calculateArea</span>() &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\n===== 派生类对象 ====&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    shape2-&gt;<span class="built_in">display</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;面积: &quot;</span> &lt;&lt; shape2-&gt;<span class="built_in">calculateArea</span>() &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 释放内存</span></span><br><span class="line">    <span class="keyword">delete</span> shape1;</span><br><span class="line">    <span class="keyword">delete</span> shape2;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虚函数工作原理：</p>
<ul>
<li>每个包含虚函数的类都有一个虚函数表（vtable）</li>
<li>每个对象包含一个指向虚函数表的指针（vptr）</li>
<li>当调用虚函数时，通过vptr查找vtable，找到对应函数的地址</li>
<li>这种机制使得在运行时可以根据对象的实际类型调用正确的函数</li>
</ul>
<h4 id="纯虚函数与抽象类">纯虚函数与抽象类</h4>
<p><strong>纯虚函数</strong>是没有实现的虚函数，声明时使用<code>= 0</code>语法。包含纯虚函数的类称为<strong>抽象类</strong>，抽象类不能直接实例化。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractShape</span> &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    std::string name;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">AbstractShape</span>(std::string n) : <span class="built_in">name</span>(n) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 纯虚函数 - 没有实现</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">calculateArea</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">displayDetails</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 普通虚函数 - 可以有实现</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">displayName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;形状名称: &quot;</span> &lt;&lt; name &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">AbstractShape</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体派生类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> : <span class="keyword">public</span> AbstractShape &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> width;</span><br><span class="line">    <span class="type">double</span> height;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Rectangle</span>(std::string n, <span class="type">double</span> w, <span class="type">double</span> h) : <span class="built_in">AbstractShape</span>(n), <span class="built_in">width</span>(w), <span class="built_in">height</span>(h) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 必须实现所有纯虚函数</span></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">calculateArea</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> width * height;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">displayDetails</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="built_in">displayName</span>();</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;矩形 - 宽: &quot;</span> &lt;&lt; width &lt;&lt; <span class="string">&quot;, 高: &quot;</span> &lt;&lt; height &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;面积: &quot;</span> &lt;&lt; <span class="built_in">calculateArea</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Triangle</span> : <span class="keyword">public</span> AbstractShape &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> base;</span><br><span class="line">    <span class="type">double</span> height;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Triangle</span>(std::string n, <span class="type">double</span> b, <span class="type">double</span> h) : <span class="built_in">AbstractShape</span>(n), <span class="built_in">base</span>(b), <span class="built_in">height</span>(h) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">calculateArea</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.5</span> * base * height;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">displayDetails</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="built_in">displayName</span>();</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;三角形 - 底: &quot;</span> &lt;&lt; base &lt;&lt; <span class="string">&quot;, 高: &quot;</span> &lt;&lt; height &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;面积: &quot;</span> &lt;&lt; <span class="built_in">calculateArea</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// AbstractShape shape(&quot;抽象形状&quot;);  // 错误：不能实例化抽象类</span></span><br><span class="line">    </span><br><span class="line">    AbstractShape* shapes[<span class="number">2</span>];</span><br><span class="line">    shapes[<span class="number">0</span>] = <span class="keyword">new</span> <span class="built_in">Rectangle</span>(<span class="string">&quot;矩形1&quot;</span>, <span class="number">4.0</span>, <span class="number">5.0</span>);</span><br><span class="line">    shapes[<span class="number">1</span>] = <span class="keyword">new</span> <span class="built_in">Triangle</span>(<span class="string">&quot;三角形1&quot;</span>, <span class="number">6.0</span>, <span class="number">3.0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">        shapes[i]-&gt;<span class="built_in">displayDetails</span>();</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;------------------&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 释放内存</span></span><br><span class="line">    <span class="keyword">delete</span> shapes[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">delete</span> shapes[<span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>抽象类的用途：</p>
<ul>
<li>定义接口规范，确保所有派生类实现必要的功能</li>
<li>作为多态的基类，提供统一的接口</li>
<li>实现设计模式中的接口抽象层</li>
</ul>
<h4 id="虚析构函数">虚析构函数</h4>
<p>虚析构函数确保当通过基类指针删除派生类对象时，会正确调用派生类的析构函数，防止资源泄漏。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span>* data;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>() &#123;</span><br><span class="line">        data = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">100</span>];</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Base 构造函数: 分配内存&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 虚析构函数</span></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] data;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Base 析构函数: 释放内存&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span>* moreData;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Derived</span>() &#123;</span><br><span class="line">        moreData = <span class="keyword">new</span> <span class="type">double</span>[<span class="number">200</span>];</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Derived 构造函数: 分配额外内存&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ~<span class="built_in">Derived</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] moreData;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Derived 析构函数: 释放额外内存&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;===== 创建并删除基类对象 =====&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    Base* basePtr = <span class="keyword">new</span> <span class="built_in">Base</span>();</span><br><span class="line">    <span class="keyword">delete</span> basePtr;</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\n===== 创建并删除派生类对象 =====&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    Derived* derivedPtr = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">    <span class="keyword">delete</span> derivedPtr;</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\n===== 通过基类指针删除派生类对象 =====&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    Base* polyPtr = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">    <span class="keyword">delete</span> polyPtr;  <span class="comment">// 正确：会调用派生类析构函数</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>重要规则</strong>：如果类有虚函数，或者打算被继承并通过基类指针删除，则应该将析构函数声明为虚函数。</p>
<h4 id="覆盖（Override）与隐藏（Hide）">覆盖（Override）与隐藏（Hide）</h4>
<p><strong>覆盖（Override）</strong>：派生类重写基类的虚函数，要求函数签名完全相同。<br>
<strong>隐藏（Hide）</strong>：派生类中定义了与基类同名的函数，但函数签名不同，或者基类函数不是虚函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BaseClass</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">BaseClass</span>(<span class="type">int</span> v = <span class="number">0</span>) : <span class="built_in">value</span>(v) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 虚函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">showValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;BaseClass showValue(): &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 虚函数，带参数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">display</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;BaseClass display(int): &quot;</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 非虚函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;BaseClass print(): &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DerivedClass</span> : <span class="keyword">public</span> BaseClass &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> dvalue;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">DerivedClass</span>(<span class="type">int</span> v = <span class="number">0</span>, <span class="type">double</span> dv = <span class="number">0.0</span>) : <span class="built_in">BaseClass</span>(v), <span class="built_in">dvalue</span>(dv) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 覆盖（Override）基类的虚函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showValue</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;DerivedClass showValue(): &quot;</span> &lt;&lt; dvalue &lt;&lt; std::endl;</span><br><span class="line">        BaseClass::<span class="built_in">showValue</span>();  <span class="comment">// 调用基类版本</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 隐藏（Hide）基类的display函数</span></span><br><span class="line">    <span class="comment">// 参数类型不同</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">(<span class="type">double</span> y)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;DerivedClass display(double): &quot;</span> &lt;&lt; y &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 隐藏（Hide）基类的print函数</span></span><br><span class="line">    <span class="comment">// 非虚函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;DerivedClass print(): &quot;</span> &lt;&lt; dvalue &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">DerivedClass <span class="title">derived</span><span class="params">(<span class="number">10</span>, <span class="number">20.5</span>)</span></span>;</span><br><span class="line">    BaseClass* basePtr = &amp;derived;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 覆盖的虚函数 - 动态绑定</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;===== 覆盖（Override）示例 =====&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    basePtr-&gt;<span class="built_in">showValue</span>();  <span class="comment">// 调用DerivedClass版本（动态绑定）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 隐藏的函数 - 静态绑定</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\n===== 隐藏（Hide）示例 =====&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// basePtr-&gt;display(3.14);  // 错误：基类没有display(double)函数</span></span><br><span class="line">    basePtr-&gt;<span class="built_in">display</span>(<span class="number">100</span>);  <span class="comment">// 调用BaseClass版本</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 通过派生类对象访问</span></span><br><span class="line">    derived.<span class="built_in">display</span>(<span class="number">3.14</span>);  <span class="comment">// 调用DerivedClass版本</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 非虚函数隐藏</span></span><br><span class="line">    basePtr-&gt;<span class="built_in">print</span>();  <span class="comment">// 调用BaseClass版本（静态绑定）</span></span><br><span class="line">    derived.<span class="built_in">print</span>();   <span class="comment">// 调用DerivedClass版本</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>覆盖与隐藏的区别：</p>
<ul>
<li>覆盖要求函数签名完全相同且基类函数为虚函数</li>
<li>隐藏只要函数名相同即可，可以是不同的参数列表</li>
<li>覆盖使用动态绑定（运行时决定）</li>
<li>隐藏使用静态绑定（编译时决定）</li>
<li>C++11引入override关键字，显式声明覆盖，提高代码可读性和安全性</li>
</ul>
<h3 id="3-4-函数模板与类模板">3.4 函数模板与类模板</h3>
<p>模板是C++支持泛型编程的核心机制，允许我们编写独立于特定数据类型的代码。泛型编程提高了代码的重用性和灵活性，是现代C++编程的重要组成部分。</p>
<h4 id="泛型编程概念">泛型编程概念</h4>
<p>泛型编程是一种编程范式，它允许编写能够处理多种数据类型的代码，而不需要为每种类型单独编写函数或类。在C++中，这主要通过模板机制实现。</p>
<p>泛型编程的优点：</p>
<ul>
<li>代码重用：编写一次，应用于多种数据类型</li>
<li>类型安全：在编译时进行类型检查</li>
<li>高效：与手写的特定类型代码效率相当</li>
<li>减少重复代码：避免为不同类型编写几乎相同的函数/类</li>
</ul>
<h4 id="函数模板定义与使用">函数模板定义与使用</h4>
<p>函数模板允许定义一个函数，该函数可以处理不同的数据类型，而不需要为每种类型单独编写函数。</p>
<p><strong>基本语法：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;  <span class="comment">// 或使用 class T</span></span><br><span class="line">返回类型 函数名(参数列表) &#123;</span><br><span class="line">    <span class="comment">// 函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>示例：简单的函数模板</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数模板 - 比较两个值的大小，返回较大的那个</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;  <span class="comment">// T 是类型参数</span></span><br><span class="line"><span class="function">T <span class="title">maxValue</span><span class="params">(T a, T b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a &gt; b) ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 另一个函数模板 - 输出数组内容</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="type">size_t</span> N&gt;  <span class="comment">// 带有非类型参数 N</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printArray</span><span class="params">(<span class="type">const</span> T (&amp;arr)[N])</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;数组内容: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        std::cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用函数模板处理整数</span></span><br><span class="line">    <span class="type">int</span> a = <span class="number">5</span>, b = <span class="number">10</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;较大的整数: &quot;</span> &lt;&lt; <span class="built_in">maxValue</span>(a, b) &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用函数模板处理浮点数</span></span><br><span class="line">    <span class="type">double</span> x = <span class="number">3.14</span>, y = <span class="number">2.71</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;较大的浮点数: &quot;</span> &lt;&lt; <span class="built_in">maxValue</span>(x, y) &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用函数模板处理字符串</span></span><br><span class="line">    std::string str1 = <span class="string">&quot;hello&quot;</span>, str2 = <span class="string">&quot;world&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;较大的字符串: &quot;</span> &lt;&lt; <span class="built_in">maxValue</span>(str1, str2) &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用带非类型参数的函数模板</span></span><br><span class="line">    <span class="type">int</span> intArray[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="type">double</span> doubleArray[] = &#123;<span class="number">1.1</span>, <span class="number">2.2</span>, <span class="number">3.3</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printArray</span>(intArray);    <span class="comment">// 编译时自动推导类型和大小</span></span><br><span class="line">    <span class="built_in">printArray</span>(doubleArray); <span class="comment">// 编译时自动推导类型和大小</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>函数模板的实例化：</strong></p>
<p>当我们调用一个函数模板时，编译器会根据实参的类型自动生成一个特定类型的函数，这个过程称为模板实例化。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数模板</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">sum</span><span class="params">(T a, T b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 隐式实例化 - 编译器自动推导类型</span></span><br><span class="line">    <span class="type">int</span> intResult = <span class="built_in">sum</span>(<span class="number">5</span>, <span class="number">3</span>);    <span class="comment">// 实例化 sum&lt;int&gt;</span></span><br><span class="line">    <span class="type">double</span> doubleResult = <span class="built_in">sum</span>(<span class="number">2.5</span>, <span class="number">3.7</span>);  <span class="comment">// 实例化 sum&lt;double&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 显式实例化 - 明确指定类型</span></span><br><span class="line">    std::string strResult = <span class="built_in">sum</span>&lt;std::string&gt;(<span class="string">&quot;Hello, &quot;</span>, <span class="string">&quot;world!&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;intResult: &quot;</span> &lt;&lt; intResult &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;doubleResult: &quot;</span> &lt;&lt; doubleResult &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;strResult: &quot;</span> &lt;&lt; strResult &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>函数模板的重载：</strong></p>
<p>可以为特定类型提供函数模板的重载版本，或者重载不同参数个数的函数模板。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数模板</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">add</span><span class="params">(T a, T b)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;使用泛型函数模板&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数模板重载 - 不同参数个数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">add</span><span class="params">(T a, T b, T c)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;使用三参数泛型函数模板&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> a + b + c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非模板函数 - 为特定类型提供专门实现</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">add</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;使用double专用函数&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调用int版本的模板函数</span></span><br><span class="line">    <span class="type">int</span> i = <span class="built_in">add</span>(<span class="number">5</span>, <span class="number">3</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;i = &quot;</span> &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调用double专用函数（非模板版本优先）</span></span><br><span class="line">    <span class="type">double</span> d = <span class="built_in">add</span>(<span class="number">2.5</span>, <span class="number">3.7</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;d = &quot;</span> &lt;&lt; d &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调用三参数模板函数</span></span><br><span class="line">    <span class="type">int</span> j = <span class="built_in">add</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;j = &quot;</span> &lt;&lt; j &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>函数模板的多类型参数：</strong></p>
<p>函数模板可以有多个不同的类型参数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 多类型参数的函数模板</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2, <span class="keyword">typename</span> T3&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printValues</span><span class="params">(T1 a, T2 b, T3 c)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;值1: &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;, 值2: &quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot;, 值3: &quot;</span> &lt;&lt; c &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 带返回值的多类型参数函数模板</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="function">T1 <span class="title">convertAndAdd</span><span class="params">(T2 value, T1 addValue)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;T1&gt;(value) + addValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用不同类型的参数调用</span></span><br><span class="line">    <span class="built_in">printValues</span>(<span class="number">10</span>, <span class="number">3.14</span>, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="built_in">printValues</span>(<span class="string">&quot;string&quot;</span>, <span class="literal">true</span>, <span class="number">42.5</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用转换函数模板</span></span><br><span class="line">    <span class="type">double</span> result1 = <span class="built_in">convertAndAdd</span>(<span class="number">5</span>, <span class="number">3.14</span>);  <span class="comment">// int转换为double再相加</span></span><br><span class="line">    <span class="type">int</span> result2 = <span class="built_in">convertAndAdd</span>(<span class="number">10.5</span>, <span class="number">20</span>);    <span class="comment">// double转换为int再相加</span></span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;result1: &quot;</span> &lt;&lt; result1 &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;result2: &quot;</span> &lt;&lt; result2 &lt;&lt; std::endl;  <span class="comment">// 注意这里会截断小数部分</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="类模板定义与使用">类模板定义与使用</h4>
<p>类模板允许我们定义一个类，该类可以处理不同的数据类型，而不需要为每种类型单独编写类。</p>
<p><strong>基本语法：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;  <span class="comment">// 或使用 class T</span></span><br><span class="line"><span class="keyword">class</span> 类名 &#123;</span><br><span class="line">    <span class="comment">// 类成员</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数、成员函数等</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>示例：简单的类模板</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 类模板 - 通用的栈实现</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="type">int</span> MAX_SIZE = <span class="number">100</span>&gt;  <span class="comment">// 带默认参数的类模板</span></span><br><span class="line"><span class="keyword">class</span> Stack &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T elements[MAX_SIZE];</span><br><span class="line">    <span class="type">int</span> topIndex;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">Stack</span>() : <span class="built_in">topIndex</span>(<span class="number">-1</span>) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 成员函数 - 检查栈是否为空</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isEmpty</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> topIndex == <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 成员函数 - 检查栈是否已满</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isFull</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> topIndex == MAX_SIZE - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 成员函数 - 入栈</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">const</span> T&amp; value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isFull</span>()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">overflow_error</span>(<span class="string">&quot;栈已满&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        elements[++topIndex] = value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 成员函数 - 出栈</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">underflow_error</span>(<span class="string">&quot;栈已空&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        --topIndex;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 成员函数 - 获取栈顶元素</span></span><br><span class="line">    <span class="function">T&amp; <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">underflow_error</span>(<span class="string">&quot;栈已空&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> elements[topIndex];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 成员函数 - 获取栈中元素个数</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> topIndex + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 整数栈</span></span><br><span class="line">        Stack&lt;<span class="type">int</span>&gt; intStack;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;整数栈示例: &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 入栈</span></span><br><span class="line">        intStack.<span class="built_in">push</span>(<span class="number">10</span>);</span><br><span class="line">        intStack.<span class="built_in">push</span>(<span class="number">20</span>);</span><br><span class="line">        intStack.<span class="built_in">push</span>(<span class="number">30</span>);</span><br><span class="line">        </span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;栈大小: &quot;</span> &lt;&lt; intStack.<span class="built_in">size</span>() &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;栈顶元素: &quot;</span> &lt;&lt; intStack.<span class="built_in">top</span>() &lt;&lt; std::endl;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 出栈</span></span><br><span class="line">        intStack.<span class="built_in">pop</span>();</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;弹出一个元素后，栈大小: &quot;</span> &lt;&lt; intStack.<span class="built_in">size</span>() &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;新的栈顶元素: &quot;</span> &lt;&lt; intStack.<span class="built_in">top</span>() &lt;&lt; std::endl;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 字符串栈，使用自定义大小</span></span><br><span class="line">        Stack&lt;std::string, <span class="number">5</span>&gt; stringStack;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;\n字符串栈示例: &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        </span><br><span class="line">        stringStack.<span class="built_in">push</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        stringStack.<span class="built_in">push</span>(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;字符串栈大小: &quot;</span> &lt;&lt; stringStack.<span class="built_in">size</span>() &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;栈顶字符串: &quot;</span> &lt;&lt; stringStack.<span class="built_in">top</span>() &lt;&lt; std::endl;</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::exception&amp; e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;异常: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>类模板的实例化：</strong></p>
<p>类模板不会自动实例化，必须显式指定类型才能使用。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 类模板 - 简单的模板类</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Pair</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T first;</span><br><span class="line">    T second;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">Pair</span>(T a, T b) : <span class="built_in">first</span>(a), <span class="built_in">second</span>(b) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 成员函数</span></span><br><span class="line">    <span class="function">T <span class="title">getFirst</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> first; &#125;</span><br><span class="line">    <span class="function">T <span class="title">getSecond</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> second; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setFirst</span><span class="params">(T a)</span> </span>&#123; first = a; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setSecond</span><span class="params">(T b)</span> </span>&#123; second = b; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        T temp = first;</span><br><span class="line">        first = second;</span><br><span class="line">        second = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; first &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; second &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 显式实例化 - 指定int类型</span></span><br><span class="line">    <span class="function">Pair&lt;<span class="type">int</span>&gt; <span class="title">intPair</span><span class="params">(<span class="number">5</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;整数对: &quot;</span>;</span><br><span class="line">    intPair.<span class="built_in">display</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 交换元素</span></span><br><span class="line">    intPair.<span class="built_in">swap</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;交换后: &quot;</span>;</span><br><span class="line">    intPair.<span class="built_in">display</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 显式实例化 - 指定double类型</span></span><br><span class="line">    <span class="function">Pair&lt;<span class="type">double</span>&gt; <span class="title">doublePair</span><span class="params">(<span class="number">3.14</span>, <span class="number">2.71</span>)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;浮点数对: &quot;</span>;</span><br><span class="line">    doublePair.<span class="built_in">display</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 显式实例化 - 指定string类型</span></span><br><span class="line">    <span class="function">Pair&lt;std::string&gt; <span class="title">stringPair</span><span class="params">(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;字符串对: &quot;</span>;</span><br><span class="line">    stringPair.<span class="built_in">display</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>类模板的成员函数：</strong></p>
<p>类模板的成员函数可以在类内定义，也可以在类外定义。类外定义时需要指定模板参数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 类模板声明</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Container</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;T&gt; elements;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 在类内定义的成员函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">const</span> T&amp; element)</span> </span>&#123;</span><br><span class="line">        elements.<span class="built_in">push_back</span>(element);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isEmpty</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> elements.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">T <span class="title">get</span><span class="params">(<span class="type">size_t</span> index)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在类外定义的成员函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">size_t</span> Container&lt;T&gt;::<span class="built_in">size</span>() <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> elements.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T Container&lt;T&gt;::<span class="built_in">get</span>(<span class="type">size_t</span> index) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; elements.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> elements[index];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> std::<span class="built_in">out_of_range</span>(<span class="string">&quot;索引超出范围&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> Container&lt;T&gt;::<span class="built_in">clear</span>() &#123;</span><br><span class="line">    elements.<span class="built_in">clear</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Container&lt;<span class="type">int</span>&gt; intContainer;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 添加元素</span></span><br><span class="line">    intContainer.<span class="built_in">add</span>(<span class="number">10</span>);</span><br><span class="line">    intContainer.<span class="built_in">add</span>(<span class="number">20</span>);</span><br><span class="line">    intContainer.<span class="built_in">add</span>(<span class="number">30</span>);</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;容器大小: &quot;</span> &lt;&lt; intContainer.<span class="built_in">size</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;元素1: &quot;</span> &lt;&lt; intContainer.<span class="built_in">get</span>(<span class="number">0</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;元素2: &quot;</span> &lt;&lt; intContainer.<span class="built_in">get</span>(<span class="number">1</span>) &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 清空容器</span></span><br><span class="line">    intContainer.<span class="built_in">clear</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;清空后，容器是否为空: &quot;</span> &lt;&lt; (intContainer.<span class="built_in">isEmpty</span>() ? <span class="string">&quot;是&quot;</span> : <span class="string">&quot;否&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>多类型参数的类模板：</strong></p>
<p>类模板可以有多个不同的类型参数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 多类型参数的类模板</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> KeyType, <span class="keyword">typename</span> ValueType&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Pair</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    KeyType key;</span><br><span class="line">    ValueType value;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">Pair</span>(KeyType k, ValueType v) : <span class="built_in">key</span>(k), <span class="built_in">value</span>(v) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 成员函数</span></span><br><span class="line">    <span class="function">KeyType <span class="title">getKey</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">    <span class="function">ValueType <span class="title">getValue</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setKey</span><span class="params">(KeyType k)</span> </span>&#123; key = k; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setValue</span><span class="params">(ValueType v)</span> </span>&#123; value = v; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;键: &quot;</span> &lt;&lt; key &lt;&lt; <span class="string">&quot;, 值: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 不同类型组合的Pair</span></span><br><span class="line">    <span class="function">Pair&lt;<span class="type">int</span>, std::string&gt; <span class="title">intStringPair</span><span class="params">(<span class="number">1</span>, <span class="string">&quot;一&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">Pair&lt;std::string, <span class="type">double</span>&gt; <span class="title">stringDoublePair</span><span class="params">(<span class="string">&quot;pi&quot;</span>, <span class="number">3.14159</span>)</span></span>;</span><br><span class="line">    <span class="function">Pair&lt;<span class="type">char</span>, <span class="type">int</span>&gt; <span class="title">charIntPair</span><span class="params">(<span class="string">&#x27;A&#x27;</span>, <span class="number">65</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;===== 不同类型的键值对 ====&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    intStringPair.<span class="built_in">display</span>();</span><br><span class="line">    stringDoublePair.<span class="built_in">display</span>();</span><br><span class="line">    charIntPair.<span class="built_in">display</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="模板特化">模板特化</h4>
<p>模板特化允许为特定类型提供自定义实现，当使用该特定类型时，编译器会使用特化版本而不是通用版本。</p>
<p><strong>函数模板特化：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通用函数模板</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printValue</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;通用版本: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数模板特化 - 为const char*类型提供特殊实现</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="type">void</span> <span class="built_in">printValue</span>&lt;<span class="type">const</span> <span class="type">char</span>*&gt;(<span class="type">const</span> <span class="type">char</span>* value) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;字符串特化版本: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数模板特化 - 为bool类型提供特殊实现</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="type">void</span> <span class="built_in">printValue</span>&lt;<span class="type">bool</span>&gt;(<span class="type">bool</span> value) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;布尔特化版本: &quot;</span> &lt;&lt; (value ? <span class="string">&quot;true&quot;</span> : <span class="string">&quot;false&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用通用版本</span></span><br><span class="line">    <span class="built_in">printValue</span>(<span class="number">42</span>);           <span class="comment">// int</span></span><br><span class="line">    <span class="built_in">printValue</span>(<span class="number">3.14</span>);         <span class="comment">// double</span></span><br><span class="line">    <span class="built_in">printValue</span>(std::<span class="built_in">string</span>(<span class="string">&quot;hello&quot;</span>));  <span class="comment">// std::string</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用特化版本</span></span><br><span class="line">    <span class="built_in">printValue</span>(<span class="string">&quot;world&quot;</span>);      <span class="comment">// const char* - 使用特化版本</span></span><br><span class="line">    <span class="built_in">printValue</span>(<span class="literal">true</span>);         <span class="comment">// bool - 使用特化版本</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>类模板特化：</strong></p>
<p>类模板可以完全特化或部分特化。</p>
<p><strong>1. 类模板完全特化：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通用类模板</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Container</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T value;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Container</span>(T v) : <span class="built_in">value</span>(v) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;通用容器: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">T <span class="title">getValue</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类模板完全特化 - 为bool类型提供特殊实现</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Container</span>&lt;<span class="type">bool</span>&gt; &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">bool</span> value;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Container</span>(<span class="type">bool</span> v) : <span class="built_in">value</span>(v) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;布尔容器特化: &quot;</span> &lt;&lt; (value ? <span class="string">&quot;true&quot;</span> : <span class="string">&quot;false&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">getValue</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 特化版本可以有额外的方法</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">toggle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        value = !value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用通用版本</span></span><br><span class="line">    <span class="function">Container&lt;<span class="type">int</span>&gt; <span class="title">intContainer</span><span class="params">(<span class="number">42</span>)</span></span>;</span><br><span class="line">    <span class="function">Container&lt;<span class="type">double</span>&gt; <span class="title">doubleContainer</span><span class="params">(<span class="number">3.14</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用特化版本</span></span><br><span class="line">    <span class="function">Container&lt;<span class="type">bool</span>&gt; <span class="title">boolContainer</span><span class="params">(<span class="literal">true</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;===== 通用版本 =====&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    intContainer.<span class="built_in">display</span>();</span><br><span class="line">    doubleContainer.<span class="built_in">display</span>();</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\n===== 特化版本 =====&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    boolContainer.<span class="built_in">display</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用特化版本的额外方法</span></span><br><span class="line">    boolContainer.<span class="built_in">toggle</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;切换后: &quot;</span> &lt;&lt; (boolContainer.<span class="built_in">getValue</span>() ? <span class="string">&quot;true&quot;</span> : <span class="string">&quot;false&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2. 类模板部分特化：</strong></p>
<p>对于具有多个类型参数的类模板，可以只对其中一部分类型参数进行特化。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通用类模板 - 用于存储和处理不同类型的数据集合</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> ContainerType&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DataProcessor</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ContainerType container;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">const</span> T&amp; item)</span> </span>&#123;</span><br><span class="line">        container.<span class="built_in">push_back</span>(item);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;添加元素: &quot;</span> &lt;&lt; item &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;使用通用处理逻辑...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类模板部分特化 - 为vector容器提供特殊实现</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DataProcessor</span>&lt;T, std::vector&lt;T&gt;&gt; &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;T&gt; container;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">const</span> T&amp; item)</span> </span>&#123;</span><br><span class="line">        container.<span class="built_in">push_back</span>(item);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Vector特化: 添加元素 &quot;</span> &lt;&lt; item &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Vector特化: 执行快速随机访问处理&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类模板部分特化 - 为list容器提供特殊实现</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DataProcessor</span>&lt;T, std::list&lt;T&gt;&gt; &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::list&lt;T&gt; container;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">const</span> T&amp; item)</span> </span>&#123;</span><br><span class="line">        container.<span class="built_in">push_back</span>(item);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;List特化: 添加元素 &quot;</span> &lt;&lt; item &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;List特化: 执行高效插入删除处理&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用vector特化版本</span></span><br><span class="line">    DataProcessor&lt;<span class="type">int</span>, std::vector&lt;<span class="type">int</span>&gt;&gt; vectorProcessor;</span><br><span class="line">    vectorProcessor.<span class="built_in">add</span>(<span class="number">10</span>);</span><br><span class="line">    vectorProcessor.<span class="built_in">add</span>(<span class="number">20</span>);</span><br><span class="line">    vectorProcessor.<span class="built_in">process</span>();</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用list特化版本</span></span><br><span class="line">    DataProcessor&lt;std::string, std::list&lt;std::string&gt;&gt; listProcessor;</span><br><span class="line">    listProcessor.<span class="built_in">add</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    listProcessor.<span class="built_in">add</span>(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">    listProcessor.<span class="built_in">process</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="模板分离编译问题">模板分离编译问题</h4>
<p>C++模板的编译模型与普通函数和类不同，这可能导致链接错误。主要原因是模板只有在被使用时才会被实例化，而编译器需要访问模板的完整定义才能进行实例化。</p>
<p><strong>问题描述：</strong></p>
<p>当我们将模板声明放在头文件(.h)中，而将模板定义放在源文件(.cpp)中时，可能会遇到链接错误。</p>
<p><strong>解决方案：</strong></p>
<ol>
<li>
<p><strong>将模板定义和声明都放在头文件中</strong></p>
<p>这是最简单、最常用的解决方案。将所有模板代码（声明和定义）都放在头文件中，这样当其他文件包含该头文件时，编译器可以访问到完整的模板定义。</p>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// utilities.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> UTILITIES_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UTILITIES_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 模板声明和定义都在头文件中</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">maxValue</span><span class="params">(T a, T b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a &gt; b) ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Container</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T value;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Container</span>(T v) : <span class="built_in">value</span>(v) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">T <span class="title">getValue</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;值: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// UTILITIES_H</span></span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>使用显式实例化</strong></p>
<p>在模板定义文件中显式实例化需要使用的所有类型，这样编译器会为这些类型生成代码。</p>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// utilities.h - 只包含声明</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> UTILITIES_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UTILITIES_H</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">maxValue</span><span class="params">(T a, T b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Container</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T value;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Container</span>(T v);</span><br><span class="line">    <span class="function">T <span class="title">getValue</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// UTILITIES_H</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// utilities.cpp - 包含定义和显式实例化</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;utilities.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">maxValue</span><span class="params">(T a, T b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a &gt; b) ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Container&lt;T&gt;::<span class="built_in">Container</span>(T v) : <span class="built_in">value</span>(v) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T Container&lt;T&gt;::<span class="built_in">getValue</span>() <span class="type">const</span> &#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> Container&lt;T&gt;::<span class="built_in">display</span>() <span class="type">const</span> &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;值: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显式实例化</span></span><br><span class="line"><span class="keyword">template</span> <span class="type">int</span> <span class="built_in">maxValue</span>&lt;<span class="type">int</span>&gt;(<span class="type">int</span>, <span class="type">int</span>);</span><br><span class="line"><span class="keyword">template</span> <span class="type">double</span> <span class="built_in">maxValue</span>&lt;<span class="type">double</span>&gt;(<span class="type">double</span>, <span class="type">double</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> <span class="keyword">class</span> <span class="title class_">Container</span>&lt;<span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">template</span> <span class="keyword">class</span> <span class="title class_">Container</span>&lt;<span class="type">double</span>&gt;;</span><br><span class="line"><span class="keyword">template</span> <span class="keyword">class</span> <span class="title class_">Container</span>&lt;std::string&gt;;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>使用模板定义包含文件</strong></p>
<p>将模板定义放在单独的文件中，然后在头文件末尾包含该文件。</p>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// utilities.h - 包含声明</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> UTILITIES_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UTILITIES_H</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">maxValue</span><span class="params">(T a, T b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 包含定义文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;utilities_impl.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// UTILITIES_H</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// utilities_impl.h - 包含定义</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> UTILITIES_IMPL_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UTILITIES_IMPL_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">maxValue</span><span class="params">(T a, T b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a &gt; b) ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// UTILITIES_IMPL_H</span></span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><strong>最佳实践：</strong></p>
<ul>
<li>对于大多数项目，将模板声明和定义都放在头文件中是最简单和最可靠的方法</li>
<li>如果担心编译时间问题，可以考虑使用前向声明和显式实例化</li>
<li>对于库开发，可以提供预实例化的常见类型版本，以减少客户端的编译时间</li>
</ul>
<h3 id="3-5-STL标准模板库">3.5 STL标准模板库</h3>
<p>C++标准模板库（Standard Template Library，STL）是C++标准库的重要组成部分，提供了一系列模板化的容器、算法和迭代器，以及函数对象、适配器等组件。STL极大地提高了C++程序员的开发效率，是现代C++编程中不可或缺的工具。</p>
<h4 id="STL组件概述：容器、算法、迭代器">STL组件概述：容器、算法、迭代器</h4>
<p>STL主要由以下几个核心组件组成：</p>
<ol>
<li><strong>容器（Containers）</strong>：用于存储和管理数据的类模板，如vector、list、map等</li>
<li><strong>算法（Algorithms）</strong>：用于处理容器中数据的函数模板，如sort、find、for_each等</li>
<li><strong>迭代器（Iterators）</strong>：提供一种方法来访问容器中的元素，是容器和算法之间的桥梁</li>
<li><strong>函数对象（Functors）</strong>：可以像函数一样调用的对象，用于自定义算法行为</li>
<li><strong>适配器（Adapters）</strong>：修改其他组件接口的类模板，如stack、queue、priority_queue等</li>
<li><strong>分配器（Allocators）</strong>：负责容器内存管理的组件</li>
</ol>
<p>这几个组件之间的关系可以概括为：<strong>算法通过迭代器操作容器中的数据</strong>，而函数对象可以定制算法的行为。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 容器：存储数据</span></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">5</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">7</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 迭代器：连接容器和算法</span></span><br><span class="line">    <span class="comment">// 算法：通过迭代器操作容器中的数据</span></span><br><span class="line">    std::<span class="built_in">sort</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 遍历容器并输出结果</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;排序后的结果: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = numbers.<span class="built_in">begin</span>(); it != numbers.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        std::cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;  <span class="comment">// 通过迭代器访问元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="常用容器：vector、list、deque、map、set">常用容器：vector、list、deque、map、set</h4>
<p>STL提供了多种容器，每种容器都有其特定的性能特点和适用场景。</p>
<h5 id="1-vector（向量）">1. vector（向量）</h5>
<p>vector是最常用的容器之一，它提供了动态大小的数组功能。</p>
<p><strong>特点：</strong></p>
<ul>
<li>支持随机访问（通过下标访问，O(1)时间复杂度）</li>
<li>在末尾添加/删除元素效率高（平均O(1)时间复杂度）</li>
<li>在中间插入/删除元素效率低（需要移动元素，O(n)时间复杂度）</li>
<li>内存连续存储</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建vector</span></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; v1;                    <span class="comment">// 空vector</span></span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">v2</span><span class="params">(<span class="number">5</span>)</span></span>;                 <span class="comment">// 包含5个默认初始化元素的vector</span></span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">v3</span><span class="params">(<span class="number">5</span>, <span class="number">10</span>)</span></span>;             <span class="comment">// 包含5个值为10的元素的vector</span></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; v4 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;  <span class="comment">// 使用初始化列表</span></span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">v5</span><span class="params">(v<span class="number">4.</span>begin(), v<span class="number">4.</span>end())</span></span>;  <span class="comment">// 从迭代器范围复制</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 添加元素</span></span><br><span class="line">    v<span class="number">1.</span><span class="built_in">push_back</span>(<span class="number">10</span>);    <span class="comment">// 在末尾添加元素</span></span><br><span class="line">    v<span class="number">1.</span><span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">    v<span class="number">1.</span><span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 访问元素</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;第一个元素: &quot;</span> &lt;&lt; v1[<span class="number">0</span>] &lt;&lt; std::endl;       <span class="comment">// 下标访问（无边界检查）</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;第二个元素: &quot;</span> &lt;&lt; v<span class="number">1.</span><span class="built_in">at</span>(<span class="number">1</span>) &lt;&lt; std::endl;    <span class="comment">// at方法（有边界检查）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 修改元素</span></span><br><span class="line">    v1[<span class="number">0</span>] = <span class="number">100</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 遍历vector - 使用迭代器</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;使用迭代器遍历: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = v<span class="number">1.</span><span class="built_in">begin</span>(); it != v<span class="number">1.</span><span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        std::cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 遍历vector - 使用范围for循环（C++11）</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;使用范围for循环: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; value : v1) &#123;</span><br><span class="line">        std::cout &lt;&lt; value &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 其他常用操作</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;大小: &quot;</span> &lt;&lt; v<span class="number">1.</span><span class="built_in">size</span>() &lt;&lt; std::endl;          <span class="comment">// 返回元素个数</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;容量: &quot;</span> &lt;&lt; v<span class="number">1.</span><span class="built_in">capacity</span>() &lt;&lt; std::endl;      <span class="comment">// 返回当前分配的存储空间能容纳的元素个数</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;是否为空: &quot;</span> &lt;&lt; (v<span class="number">1.</span><span class="built_in">empty</span>() ? <span class="string">&quot;是&quot;</span> : <span class="string">&quot;否&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 插入元素</span></span><br><span class="line">    v<span class="number">1.</span><span class="built_in">insert</span>(v<span class="number">1.</span><span class="built_in">begin</span>() + <span class="number">1</span>, <span class="number">50</span>);  <span class="comment">// 在索引1的位置插入50</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 删除元素</span></span><br><span class="line">    v<span class="number">1.</span><span class="built_in">pop_back</span>();                  <span class="comment">// 删除最后一个元素</span></span><br><span class="line">    v<span class="number">1.</span><span class="built_in">erase</span>(v<span class="number">1.</span><span class="built_in">begin</span>());           <span class="comment">// 删除第一个元素</span></span><br><span class="line">    v<span class="number">1.</span><span class="built_in">erase</span>(v<span class="number">1.</span><span class="built_in">begin</span>(), v<span class="number">1.</span><span class="built_in">begin</span>() + <span class="number">2</span>);  <span class="comment">// 删除从第一个元素开始的两个元素</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 清空vector</span></span><br><span class="line">    v<span class="number">1.</span><span class="built_in">clear</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2-list（链表）">2. list（链表）</h5>
<p>list是双向链表实现的容器。</p>
<p><strong>特点：</strong></p>
<ul>
<li>不支持随机访问（O(n)时间复杂度）</li>
<li>在任意位置插入/删除元素效率高（只需修改指针，O(1)时间复杂度）</li>
<li>内存不连续存储</li>
<li>提供了特殊的成员函数，如sort、merge、splice等</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建list</span></span><br><span class="line">    std::list&lt;<span class="type">int</span>&gt; l1;                    <span class="comment">// 空list</span></span><br><span class="line">    <span class="function">std::list&lt;<span class="type">int</span>&gt; <span class="title">l2</span><span class="params">(<span class="number">5</span>)</span></span>;                 <span class="comment">// 包含5个默认初始化元素的list</span></span><br><span class="line">    <span class="function">std::list&lt;<span class="type">int</span>&gt; <span class="title">l3</span><span class="params">(<span class="number">5</span>, <span class="number">10</span>)</span></span>;             <span class="comment">// 包含5个值为10的元素的list</span></span><br><span class="line">    std::list&lt;<span class="type">int</span>&gt; l4 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;  <span class="comment">// 使用初始化列表</span></span><br><span class="line">    <span class="function">std::list&lt;<span class="type">int</span>&gt; <span class="title">l5</span><span class="params">(l<span class="number">4.</span>begin(), l<span class="number">4.</span>end())</span></span>;  <span class="comment">// 从迭代器范围复制</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 添加元素</span></span><br><span class="line">    l<span class="number">1.</span><span class="built_in">push_back</span>(<span class="number">30</span>);     <span class="comment">// 在末尾添加元素</span></span><br><span class="line">    l<span class="number">1.</span><span class="built_in">push_front</span>(<span class="number">10</span>);    <span class="comment">// 在开头添加元素</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 访问元素</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;第一个元素: &quot;</span> &lt;&lt; l<span class="number">1.f</span>ront() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;最后一个元素: &quot;</span> &lt;&lt; l<span class="number">1.</span><span class="built_in">back</span>() &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// 注意：list没有[]操作符和at()方法，不能随机访问</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 修改元素</span></span><br><span class="line">    l<span class="number">1.f</span>ront() = <span class="number">100</span>;</span><br><span class="line">    l<span class="number">1.</span><span class="built_in">back</span>() = <span class="number">300</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 遍历list - 使用迭代器</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;使用迭代器遍历: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = l<span class="number">1.</span><span class="built_in">begin</span>(); it != l<span class="number">1.</span><span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        std::cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 遍历list - 使用范围for循环</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;使用范围for循环: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; value : l1) &#123;</span><br><span class="line">        std::cout &lt;&lt; value &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 插入元素</span></span><br><span class="line">    <span class="keyword">auto</span> it = l<span class="number">1.</span><span class="built_in">begin</span>();</span><br><span class="line">    ++it;  <span class="comment">// 移动到第二个位置</span></span><br><span class="line">    l<span class="number">1.</span><span class="built_in">insert</span>(it, <span class="number">200</span>);  <span class="comment">// 在第二个位置插入200</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 删除元素</span></span><br><span class="line">    l<span class="number">1.</span><span class="built_in">pop_back</span>();       <span class="comment">// 删除最后一个元素</span></span><br><span class="line">    l<span class="number">1.</span><span class="built_in">pop_front</span>();      <span class="comment">// 删除第一个元素</span></span><br><span class="line">    l<span class="number">1.</span><span class="built_in">erase</span>(it);        <span class="comment">// 删除迭代器指向的元素</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// list特有的操作</span></span><br><span class="line">    std::list&lt;<span class="type">int</span>&gt; l6 = &#123;<span class="number">5</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">7</span>&#125;;</span><br><span class="line">    l<span class="number">6.</span><span class="built_in">sort</span>();           <span class="comment">// 排序</span></span><br><span class="line">    l<span class="number">6.</span><span class="built_in">reverse</span>();        <span class="comment">// 反转</span></span><br><span class="line">    l<span class="number">6.</span><span class="built_in">unique</span>();         <span class="comment">// 删除连续的重复元素</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 合并两个有序list</span></span><br><span class="line">    std::list&lt;<span class="type">int</span>&gt; l7 = &#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>&#125;;</span><br><span class="line">    std::list&lt;<span class="type">int</span>&gt; l8 = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    l<span class="number">7.</span><span class="built_in">merge</span>(l8);        <span class="comment">// 合并后l7包含1,2,3,4,5,6，l8为空</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 移动元素（splice操作）</span></span><br><span class="line">    std::list&lt;<span class="type">int</span>&gt; l9 = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>&#125;;</span><br><span class="line">    std::list&lt;<span class="type">int</span>&gt; l10 = &#123;<span class="number">40</span>, <span class="number">50</span>, <span class="number">60</span>&#125;;</span><br><span class="line">    l<span class="number">9.</span><span class="built_in">splice</span>(l<span class="number">9.</span><span class="built_in">end</span>(), l10);  <span class="comment">// 将l10的所有元素移到l9末尾</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="3-deque（双端队列）">3. deque（双端队列）</h5>
<p>deque（double-ended queue）是双端队列，支持在两端高效地插入和删除元素。</p>
<p><strong>特点：</strong></p>
<ul>
<li>支持随机访问（通过下标访问，O(1)时间复杂度）</li>
<li>在两端添加/删除元素效率高（O(1)时间复杂度）</li>
<li>内存不连续存储，但通过中控器管理多个连续内存块</li>
<li>适用于需要在两端频繁操作且需要随机访问的场景</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建deque</span></span><br><span class="line">    std::deque&lt;<span class="type">int</span>&gt; d1;                    <span class="comment">// 空deque</span></span><br><span class="line">    <span class="function">std::deque&lt;<span class="type">int</span>&gt; <span class="title">d2</span><span class="params">(<span class="number">5</span>)</span></span>;                 <span class="comment">// 包含5个默认初始化元素的deque</span></span><br><span class="line">    <span class="function">std::deque&lt;<span class="type">int</span>&gt; <span class="title">d3</span><span class="params">(<span class="number">5</span>, <span class="number">10</span>)</span></span>;             <span class="comment">// 包含5个值为10的元素的deque</span></span><br><span class="line">    std::deque&lt;<span class="type">int</span>&gt; d4 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;  <span class="comment">// 使用初始化列表</span></span><br><span class="line">    <span class="function">std::deque&lt;<span class="type">int</span>&gt; <span class="title">d5</span><span class="params">(d<span class="number">4.</span>begin(), d<span class="number">4.</span>end())</span></span>;  <span class="comment">// 从迭代器范围复制</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 添加元素</span></span><br><span class="line">    d<span class="number">1.</span><span class="built_in">push_back</span>(<span class="number">30</span>);     <span class="comment">// 在末尾添加元素</span></span><br><span class="line">    d<span class="number">1.</span><span class="built_in">push_front</span>(<span class="number">10</span>);    <span class="comment">// 在开头添加元素</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 访问元素</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;第一个元素: &quot;</span> &lt;&lt; d1[<span class="number">0</span>] &lt;&lt; std::endl;        <span class="comment">// 下标访问</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;最后一个元素: &quot;</span> &lt;&lt; d<span class="number">1.</span><span class="built_in">at</span>(d<span class="number">1.</span><span class="built_in">size</span>()<span class="number">-1</span>) &lt;&lt; std::endl;  <span class="comment">// at方法</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 修改元素</span></span><br><span class="line">    d1[<span class="number">0</span>] = <span class="number">100</span>;</span><br><span class="line">    d1[d<span class="number">1.</span><span class="built_in">size</span>()<span class="number">-1</span>] = <span class="number">300</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 遍历deque</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;使用迭代器遍历: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = d<span class="number">1.</span><span class="built_in">begin</span>(); it != d<span class="number">1.</span><span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        std::cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 插入元素</span></span><br><span class="line">    d<span class="number">1.</span><span class="built_in">insert</span>(d<span class="number">1.</span><span class="built_in">begin</span>() + <span class="number">1</span>, <span class="number">200</span>);  <span class="comment">// 在索引1的位置插入200</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 删除元素</span></span><br><span class="line">    d<span class="number">1.</span><span class="built_in">pop_back</span>();       <span class="comment">// 删除最后一个元素</span></span><br><span class="line">    d<span class="number">1.</span><span class="built_in">pop_front</span>();      <span class="comment">// 删除第一个元素</span></span><br><span class="line">    d<span class="number">1.</span><span class="built_in">erase</span>(d<span class="number">1.</span><span class="built_in">begin</span>());  <span class="comment">// 删除第一个元素</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 其他常用操作</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;大小: &quot;</span> &lt;&lt; d<span class="number">1.</span><span class="built_in">size</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;是否为空: &quot;</span> &lt;&lt; (d<span class="number">1.</span><span class="built_in">empty</span>() ? <span class="string">&quot;是&quot;</span> : <span class="string">&quot;否&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line">    d<span class="number">1.</span><span class="built_in">clear</span>();          <span class="comment">// 清空deque</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 双端队列典型应用 - 滑动窗口</span></span><br><span class="line">    std::deque&lt;<span class="type">int</span>&gt; window;</span><br><span class="line">    <span class="comment">// 在滑动窗口算法中，deque可以高效地维护窗口中的元素</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="4-map（映射）">4. map（映射）</h5>
<p>map是关联容器，存储键值对（key-value pairs），并按键自动排序。</p>
<p><strong>特点：</strong></p>
<ul>
<li>存储键值对，每个键唯一</li>
<li>按键自动排序（默认按升序）</li>
<li>查找、插入和删除操作的时间复杂度为O(log n)</li>
<li>基于红黑树实现</li>
<li>不能通过迭代器修改键（但可以修改值）</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建map</span></span><br><span class="line">    std::map&lt;std::string, <span class="type">int</span>&gt; scores;  <span class="comment">// string作为键，int作为值</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 添加元素</span></span><br><span class="line">    scores[<span class="string">&quot;Alice&quot;</span>] = <span class="number">95</span>;              <span class="comment">// 使用下标操作符</span></span><br><span class="line">    scores.<span class="built_in">insert</span>(&#123;<span class="string">&quot;Bob&quot;</span>, <span class="number">87</span>&#125;);        <span class="comment">// 使用insert方法和初始化列表</span></span><br><span class="line">    scores.<span class="built_in">insert</span>(std::<span class="built_in">make_pair</span>(<span class="string">&quot;Charlie&quot;</span>, <span class="number">92</span>));  <span class="comment">// 使用make_pair</span></span><br><span class="line">    scores.<span class="built_in">insert</span>(std::<span class="built_in">pair</span>&lt;std::string, <span class="type">int</span>&gt;(<span class="string">&quot;David&quot;</span>, <span class="number">89</span>));  <span class="comment">// 使用pair构造函数</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 访问元素</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Alice的分数: &quot;</span> &lt;&lt; scores[<span class="string">&quot;Alice&quot;</span>] &lt;&lt; std::endl;  <span class="comment">// 下标操作符（如果键不存在会插入默认值）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用find方法安全地查找元素</span></span><br><span class="line">    <span class="keyword">auto</span> it = scores.<span class="built_in">find</span>(<span class="string">&quot;Bob&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (it != scores.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Bob的分数: &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Bob不存在&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 修改元素</span></span><br><span class="line">    scores[<span class="string">&quot;Alice&quot;</span>] = <span class="number">98</span>;  <span class="comment">// 更新已存在键的值</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 遍历map</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;所有学生的分数: &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; pair : scores) &#123;</span><br><span class="line">        std::cout &lt;&lt; pair.first &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; pair.second &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 检查键是否存在</span></span><br><span class="line">    <span class="keyword">if</span> (scores.<span class="built_in">count</span>(<span class="string">&quot;Eve&quot;</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Eve存在&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Eve不存在&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 删除元素</span></span><br><span class="line">    scores.<span class="built_in">erase</span>(<span class="string">&quot;David&quot;</span>);       <span class="comment">// 通过键删除</span></span><br><span class="line">    scores.<span class="built_in">erase</span>(scores.<span class="built_in">begin</span>());  <span class="comment">// 通过迭代器删除</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 其他常用操作</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;map的大小: &quot;</span> &lt;&lt; scores.<span class="built_in">size</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;是否为空: &quot;</span> &lt;&lt; (scores.<span class="built_in">empty</span>() ? <span class="string">&quot;是&quot;</span> : <span class="string">&quot;否&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line">    scores.<span class="built_in">clear</span>();  <span class="comment">// 清空map</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="5-set（集合）">5. set（集合）</h5>
<p>set是关联容器，存储唯一元素，并按顺序自动排序。</p>
<p><strong>特点：</strong></p>
<ul>
<li>存储唯一元素（值就是键）</li>
<li>元素自动排序（默认按升序）</li>
<li>查找、插入和删除操作的时间复杂度为O(log n)</li>
<li>基于红黑树实现</li>
<li>不能通过迭代器修改元素（只读）</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建set</span></span><br><span class="line">    std::set&lt;<span class="type">int</span>&gt; numbers;  <span class="comment">// 存储int类型的集合</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 添加元素</span></span><br><span class="line">    numbers.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">    numbers.<span class="built_in">insert</span>(<span class="number">20</span>);</span><br><span class="line">    numbers.<span class="built_in">insert</span>(<span class="number">30</span>);</span><br><span class="line">    numbers.<span class="built_in">insert</span>(<span class="number">20</span>);  <span class="comment">// 重复元素，不会被插入</span></span><br><span class="line">    numbers.<span class="built_in">insert</span>(&#123;<span class="number">5</span>, <span class="number">15</span>, <span class="number">25</span>&#125;);  <span class="comment">// 使用初始化列表插入多个元素</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 访问元素 - 不能直接通过下标访问，需要使用迭代器</span></span><br><span class="line">    <span class="keyword">auto</span> it = numbers.<span class="built_in">find</span>(<span class="number">20</span>);</span><br><span class="line">    <span class="keyword">if</span> (it != numbers.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;找到元素: &quot;</span> &lt;&lt; *it &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;元素不存在&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 遍历set</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;集合中的所有元素: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; num : numbers) &#123;</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 检查元素是否存在</span></span><br><span class="line">    <span class="keyword">if</span> (numbers.<span class="built_in">count</span>(<span class="number">15</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;15在集合中&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;15不在集合中&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 删除元素</span></span><br><span class="line">    numbers.<span class="built_in">erase</span>(<span class="number">20</span>);        <span class="comment">// 通过值删除</span></span><br><span class="line">    numbers.<span class="built_in">erase</span>(numbers.<span class="built_in">begin</span>());  <span class="comment">// 通过迭代器删除</span></span><br><span class="line">    numbers.<span class="built_in">erase</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">find</span>(<span class="number">20</span>));  <span class="comment">// 删除范围内的元素</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 其他常用操作</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;集合的大小: &quot;</span> &lt;&lt; numbers.<span class="built_in">size</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;是否为空: &quot;</span> &lt;&lt; (numbers.<span class="built_in">empty</span>() ? <span class="string">&quot;是&quot;</span> : <span class="string">&quot;否&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取第一个和最后一个元素</span></span><br><span class="line">    <span class="keyword">if</span> (!numbers.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;第一个元素: &quot;</span> &lt;&lt; *numbers.<span class="built_in">begin</span>() &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;最后一个元素: &quot;</span> &lt;&lt; *numbers.<span class="built_in">rbegin</span>() &lt;&lt; std::endl;  <span class="comment">// rbegin返回逆序迭代器</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    numbers.<span class="built_in">clear</span>();  <span class="comment">// 清空集合</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="迭代器使用">迭代器使用</h4>
<p>迭代器是连接容器和算法的桥梁，提供了一种统一的方式来访问容器中的元素，而不需要关心容器的具体实现。</p>
<h5 id="迭代器类型">迭代器类型</h5>
<p>STL提供了几种不同类型的迭代器，按照功能从弱到强依次为：</p>
<ol>
<li><strong>输入迭代器（Input Iterator）</strong>：只读访问，可以单向移动（只能++）</li>
<li><strong>输出迭代器（Output Iterator）</strong>：只写访问，可以单向移动（只能++）</li>
<li><strong>前向迭代器（Forward Iterator）</strong>：读写访问，可以单向移动（只能++）</li>
<li><strong>双向迭代器（Bidirectional Iterator）</strong>：读写访问，可以双向移动（可以++和–）</li>
<li><strong>随机访问迭代器（Random Access Iterator）</strong>：读写访问，可以随机访问（支持+、-、+=、-=、[]等操作）</li>
</ol>
<p>不同容器支持的迭代器类型：</p>
<ul>
<li>vector、deque：支持随机访问迭代器</li>
<li>list、set、map：支持双向迭代器</li>
<li>输入流迭代器istream_iterator：输入迭代器</li>
<li>输出流迭代器ostream_iterator：输出迭代器</li>
</ul>
<h5 id="迭代器操作">迭代器操作</h5>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. vector的随机访问迭代器示例</span></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 随机访问操作</span></span><br><span class="line">    <span class="keyword">auto</span> vec_it = vec.<span class="built_in">begin</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;vec[2]: &quot;</span> &lt;&lt; vec_it[<span class="number">2</span>] &lt;&lt; std::endl;  <span class="comment">// 支持下标操作</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;*(vec_it + 2): &quot;</span> &lt;&lt; *(vec_it + <span class="number">2</span>) &lt;&lt; std::endl;  <span class="comment">// 支持算术运算</span></span><br><span class="line">    </span><br><span class="line">    vec_it += <span class="number">3</span>;  <span class="comment">// 移动迭代器</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;移动后的值: &quot;</span> &lt;&lt; *vec_it &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. list的双向迭代器示例</span></span><br><span class="line">    std::list&lt;<span class="type">int</span>&gt; lst = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 双向访问</span></span><br><span class="line">    <span class="keyword">auto</span> lst_it = lst.<span class="built_in">begin</span>();</span><br><span class="line">    ++lst_it;  <span class="comment">// 前进到下一个元素</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;第二个元素: &quot;</span> &lt;&lt; *lst_it &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    --lst_it;  <span class="comment">// 后退到前一个元素</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;第一个元素: &quot;</span> &lt;&lt; *lst_it &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 注意：list的迭代器不支持随机访问</span></span><br><span class="line">    <span class="comment">// lst_it += 2;  // 编译错误</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. map的迭代器示例</span></span><br><span class="line">    std::map&lt;std::string, <span class="type">int</span>&gt; scores = &#123;</span><br><span class="line">        &#123;<span class="string">&quot;Alice&quot;</span>, <span class="number">95</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;Bob&quot;</span>, <span class="number">87</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;Charlie&quot;</span>, <span class="number">92</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 遍历map</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = scores.<span class="built_in">begin</span>(); it != scores.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        std::cout &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 4. 迭代器适配器 - 反向迭代器</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;反向遍历vector: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = vec.<span class="built_in">rbegin</span>(); it != vec.<span class="built_in">rend</span>(); ++it) &#123;</span><br><span class="line">        std::cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 5. 迭代器辅助函数</span></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec2 = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>&#125;;</span><br><span class="line">    <span class="keyword">auto</span> it1 = vec<span class="number">2.</span><span class="built_in">begin</span>() + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">auto</span> it2 = vec<span class="number">2.</span><span class="built_in">end</span>() - <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;迭代器之间的距离: &quot;</span> &lt;&lt; std::<span class="built_in">distance</span>(it1, it2) &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 6. 常量迭代器</span></span><br><span class="line">    <span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt; const_vec = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt;::const_iterator cit;</span><br><span class="line">    <span class="comment">// *cit = 10;  // 编译错误，不能修改通过const_iterator访问的元素</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="迭代器与算法的结合使用">迭代器与算法的结合使用</h5>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">5</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用sort算法排序（需要随机访问迭代器）</span></span><br><span class="line">    std::<span class="built_in">sort</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>());</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;排序后的数组: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; num : numbers) &#123;</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用find算法查找元素</span></span><br><span class="line">    <span class="keyword">auto</span> it = std::<span class="built_in">find</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>(), <span class="number">7</span>);</span><br><span class="line">    <span class="keyword">if</span> (it != numbers.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;找到元素7，位置: &quot;</span> &lt;&lt; (it - numbers.<span class="built_in">begin</span>()) &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用count算法统计元素出现次数</span></span><br><span class="line">    <span class="type">int</span> count = std::<span class="built_in">count</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>(), <span class="number">5</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;元素5出现的次数: &quot;</span> &lt;&lt; count &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用for_each算法遍历并修改元素</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;每个元素加10: &quot;</span>;</span><br><span class="line">    std::for_each(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>(), [](<span class="type">int</span>&amp; n) &#123;</span><br><span class="line">        n += <span class="number">10</span>;</span><br><span class="line">        std::cout &lt;&lt; n &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用reverse算法反转容器</span></span><br><span class="line">    std::<span class="built_in">reverse</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>());</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;反转后的数组: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; num : numbers) &#123;</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用copy算法复制元素</span></span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">copied</span><span class="params">(numbers.size())</span></span>;</span><br><span class="line">    std::<span class="built_in">copy</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>(), copied.<span class="built_in">begin</span>());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用fill算法填充容器</span></span><br><span class="line">    std::<span class="built_in">fill</span>(copied.<span class="built_in">begin</span>(), copied.<span class="built_in">begin</span>() + <span class="number">3</span>, <span class="number">99</span>);</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;填充后的数组: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; num : copied) &#123;</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="常用算法：sort、find、for-each">常用算法：sort、find、for_each</h4>
<p>STL提供了大量的算法，这些算法通过迭代器操作容器中的数据。下面介绍几个最常用的算法。</p>
<h5 id="1-sort算法">1. sort算法</h5>
<p>sort算法用于对容器中的元素进行排序。默认使用升序排列，也可以提供自定义的比较函数。</p>
<p><strong>语法：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sort</span>(first, last);                <span class="comment">// 默认升序排序</span></span><br><span class="line"><span class="built_in">sort</span>(first, last, comp);          <span class="comment">// 使用自定义比较函数</span></span><br></pre></td></tr></table></figure>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义比较函数 - 降序排列</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">descending</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义结构体</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    std::string name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">const</span> std::string&amp; n, <span class="type">int</span> a) : <span class="built_in">name</span>(n), <span class="built_in">age</span>(a) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 基本排序</span></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">5</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">7</span>&#125;;</span><br><span class="line">    std::<span class="built_in">sort</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>());</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;升序排序: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; num : numbers) &#123;</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用自定义比较函数降序排序</span></span><br><span class="line">    std::<span class="built_in">sort</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>(), descending);</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;降序排序: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; num : numbers) &#123;</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用Lambda表达式排序</span></span><br><span class="line">    std::<span class="built_in">sort</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>(), [](<span class="type">int</span> a, <span class="type">int</span> b) &#123;</span><br><span class="line">        <span class="keyword">return</span> a &lt; b;  <span class="comment">// 升序</span></span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 对结构体排序</span></span><br><span class="line">    std::vector&lt;Person&gt; people = &#123;</span><br><span class="line">        &#123;<span class="string">&quot;Alice&quot;</span>, <span class="number">25</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;Bob&quot;</span>, <span class="number">20</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;Charlie&quot;</span>, <span class="number">30</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 按年龄排序</span></span><br><span class="line">    std::<span class="built_in">sort</span>(people.<span class="built_in">begin</span>(), people.<span class="built_in">end</span>(), [](<span class="type">const</span> Person&amp; p1, <span class="type">const</span> Person&amp; p2) &#123;</span><br><span class="line">        <span class="keyword">return</span> p<span class="number">1.</span>age &lt; p<span class="number">2.</span>age;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;按年龄排序: &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; p : people) &#123;</span><br><span class="line">        std::cout &lt;&lt; p.name &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; p.age &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 按名字排序</span></span><br><span class="line">    std::<span class="built_in">sort</span>(people.<span class="built_in">begin</span>(), people.<span class="built_in">end</span>(), [](<span class="type">const</span> Person&amp; p1, <span class="type">const</span> Person&amp; p2) &#123;</span><br><span class="line">        <span class="keyword">return</span> p<span class="number">1.</span>name &lt; p<span class="number">2.</span>name;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;按名字排序: &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; p : people) &#123;</span><br><span class="line">        std::cout &lt;&lt; p.name &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; p.age &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2-find算法">2. find算法</h5>
<p>find算法用于在容器中查找指定的元素。</p>
<p><strong>语法：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">find</span>(first, last, value);         <span class="comment">// 查找等于value的元素</span></span><br><span class="line"><span class="built_in">find_if</span>(first, last, pred);       <span class="comment">// 查找满足pred条件的元素</span></span><br><span class="line"><span class="built_in">find_if_not</span>(first, last, pred);   <span class="comment">// 查找不满足pred条件的元素</span></span><br></pre></td></tr></table></figure>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义谓词函数 - 判断是否为偶数</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isEven</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n % <span class="number">2</span> == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义结构体</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    std::string name;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">Student</span>(<span class="type">const</span> std::string&amp; n, <span class="type">int</span> i) : <span class="built_in">name</span>(n), <span class="built_in">id</span>(i) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 重载==运算符以便使用find</span></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Student&amp; other) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id == other.id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 基本查找</span></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">5</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">8</span>&#125;;</span><br><span class="line">    <span class="keyword">auto</span> it = std::<span class="built_in">find</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>(), <span class="number">3</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (it != numbers.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;找到元素3，位置: &quot;</span> &lt;&lt; (it - numbers.<span class="built_in">begin</span>()) &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;未找到元素3&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用find_if查找满足条件的元素</span></span><br><span class="line">    <span class="keyword">auto</span> even_it = std::<span class="built_in">find_if</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>(), isEven);</span><br><span class="line">    <span class="keyword">if</span> (even_it != numbers.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;第一个偶数: &quot;</span> &lt;&lt; *even_it &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用Lambda表达式查找</span></span><br><span class="line">    <span class="keyword">auto</span> odd_it = std::<span class="built_in">find_if</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>(), [](<span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">return</span> n % <span class="number">2</span> != <span class="number">0</span> &amp;&amp; n &gt; <span class="number">5</span>;  <span class="comment">// 查找大于5的奇数</span></span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (odd_it != numbers.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;找到大于5的奇数: &quot;</span> &lt;&lt; *odd_it &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在结构体向量中查找</span></span><br><span class="line">    std::vector&lt;Student&gt; students = &#123;</span><br><span class="line">        &#123;<span class="string">&quot;Alice&quot;</span>, <span class="number">1001</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;Bob&quot;</span>, <span class="number">1002</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;Charlie&quot;</span>, <span class="number">1003</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="function">Student <span class="title">target</span><span class="params">(<span class="string">&quot;&quot;</span>, <span class="number">1002</span>)</span></span>;  <span class="comment">// 只设置id来查找</span></span><br><span class="line">    <span class="keyword">auto</span> student_it = std::<span class="built_in">find</span>(students.<span class="built_in">begin</span>(), students.<span class="built_in">end</span>(), target);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (student_it != students.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;找到学生: &quot;</span> &lt;&lt; student_it-&gt;name &lt;&lt; <span class="string">&quot;, ID: &quot;</span> &lt;&lt; student_it-&gt;id &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用find_if根据名字查找</span></span><br><span class="line">    <span class="keyword">auto</span> name_it = std::<span class="built_in">find_if</span>(students.<span class="built_in">begin</span>(), students.<span class="built_in">end</span>(), [](<span class="type">const</span> Student&amp; s) &#123;</span><br><span class="line">        <span class="keyword">return</span> s.name == <span class="string">&quot;Charlie&quot;</span>;  <span class="comment">// 根据名字查找</span></span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (name_it != students.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;找到学生Charlie, ID: &quot;</span> &lt;&lt; name_it-&gt;id &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="3-for-each算法">3. for_each算法</h5>
<p>for_each算法用于对容器中的每个元素执行指定的操作。</p>
<p><strong>语法：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for_each(first, last, fn);   <span class="comment">// 对[first, last)范围内的每个元素执行fn</span></span><br></pre></td></tr></table></figure>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义函数 - 打印元素</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printElement</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; n &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义函数对象（Functor）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MultiplyBy</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> factor;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MultiplyBy</span>(<span class="type">int</span> f) : <span class="built_in">factor</span>(f) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span>&amp; n)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        n *= factor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用函数进行遍历</span></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;原始数组: &quot;</span>;</span><br><span class="line">    std::for_each(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>(), printElement);</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用函数对象修改元素</span></span><br><span class="line">    std::for_each(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>(), <span class="built_in">MultiplyBy</span>(<span class="number">2</span>));</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;乘以2后: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; num : numbers) &#123;</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用Lambda表达式</span></span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    std::for_each(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>(), [&amp;sum](<span class="type">int</span> n) &#123;</span><br><span class="line">        sum += n;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;元素: &quot;</span> &lt;&lt; n &lt;&lt; <span class="string">&quot;, 当前和: &quot;</span> &lt;&lt; sum &lt;&lt; std::endl;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;总和: &quot;</span> &lt;&lt; sum &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在结构体向量上使用</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Product</span> &#123;</span><br><span class="line">        std::string name;</span><br><span class="line">        <span class="type">double</span> price;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    std::vector&lt;Product&gt; products = &#123;</span><br><span class="line">        &#123;<span class="string">&quot;手机&quot;</span>, <span class="number">1999.99</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;电脑&quot;</span>, <span class="number">5999.99</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;平板&quot;</span>, <span class="number">2999.99</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用Lambda表达式计算总价</span></span><br><span class="line">    <span class="type">double</span> totalPrice = <span class="number">0.0</span>;</span><br><span class="line">    std::for_each(products.<span class="built_in">begin</span>(), products.<span class="built_in">end</span>(), [&amp;totalPrice](<span class="type">const</span> Product&amp; p) &#123;</span><br><span class="line">        totalPrice += p.price;</span><br><span class="line">        std::cout &lt;&lt; p.name &lt;&lt; <span class="string">&quot;: ¥&quot;</span> &lt;&lt; p.price &lt;&lt; std::endl;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;总价: ¥&quot;</span> &lt;&lt; totalPrice &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="函数对象（Functor）">函数对象（Functor）</h4>
<p>函数对象，也称为仿函数，是指重载了函数调用运算符<code>operator()</code>的类或结构体的实例。函数对象可以像普通函数一样被调用，但它可以保存状态。</p>
<p><strong>特点：</strong></p>
<ul>
<li>可以保存状态（成员变量）</li>
<li>可以作为模板参数传递</li>
<li>比函数指针更高效（编译器可以内联）</li>
<li>可以有多个不同的实例，每个实例有自己的状态</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 简单的函数对象</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GreaterThan</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> threshold;</span><br><span class="line">    <span class="type">int</span> count;  <span class="comment">// 保存状态</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">GreaterThan</span>(<span class="type">int</span> t) : <span class="built_in">threshold</span>(t), <span class="built_in">count</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 重载函数调用运算符</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &gt; threshold) &#123;</span><br><span class="line">            ++count;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取计数</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getCount</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于排序的函数对象</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SortByName</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">        std::string name;</span><br><span class="line">        <span class="type">int</span> age;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">Person</span>(<span class="type">const</span> std::string&amp; n, <span class="type">int</span> a) : <span class="built_in">name</span>(n), <span class="built_in">age</span>(a) &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> Person&amp; p1, <span class="type">const</span> Person&amp; p2)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p<span class="number">1.</span>name &lt; p<span class="number">2.</span>name;  <span class="comment">// 按名字升序排序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于累加的函数对象</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Adder</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> sum;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Adder</span>() : <span class="built_in">sum</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        sum += n;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getSum</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 使用函数对象作为谓词</span></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>, <span class="number">20</span>, <span class="number">25</span>, <span class="number">30</span>&#125;;</span><br><span class="line">    <span class="function">GreaterThan <span class="title">gt</span><span class="params">(<span class="number">15</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用函数对象过滤元素</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;大于15的元素: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; num : numbers) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">gt</span>(num)) &#123;  <span class="comment">// 调用函数对象</span></span><br><span class="line">            std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;大于15的元素个数: &quot;</span> &lt;&lt; gt.<span class="built_in">getCount</span>() &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 使用函数对象作为排序条件</span></span><br><span class="line">    std::vector&lt;SortByName::Person&gt; people = &#123;</span><br><span class="line">        &#123;<span class="string">&quot;Alice&quot;</span>, <span class="number">25</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;Bob&quot;</span>, <span class="number">20</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;Charlie&quot;</span>, <span class="number">30</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    std::<span class="built_in">sort</span>(people.<span class="built_in">begin</span>(), people.<span class="built_in">end</span>(), <span class="built_in">SortByName</span>());</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;按名字排序后的人员: &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; p : people) &#123;</span><br><span class="line">        std::cout &lt;&lt; p.name &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; p.age &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. 使用函数对象进行累加</span></span><br><span class="line">    Adder adder = std::for_each(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>(), <span class="built_in">Adder</span>());</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;数组元素总和: &quot;</span> &lt;&lt; adder.<span class="built_in">getSum</span>() &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 4. 使用函数对象计算均值</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">AverageCalculator</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">        <span class="type">double</span> sum;</span><br><span class="line">        <span class="type">int</span> count;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">AverageCalculator</span>() : <span class="built_in">sum</span>(<span class="number">0.0</span>), <span class="built_in">count</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">double</span> n)</span> </span>&#123;</span><br><span class="line">            sum += n;</span><br><span class="line">            ++count;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="type">double</span> <span class="title">getAverage</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> count &gt; <span class="number">0</span> ? sum / count : <span class="number">0.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    std::vector&lt;<span class="type">double</span>&gt; scores = &#123;<span class="number">85.5</span>, <span class="number">92.0</span>, <span class="number">78.5</span>, <span class="number">90.0</span>, <span class="number">88.5</span>&#125;;</span><br><span class="line">    AverageCalculator avgCalc = std::for_each(scores.<span class="built_in">begin</span>(), scores.<span class="built_in">end</span>(), <span class="built_in">AverageCalculator</span>());</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;平均分数: &quot;</span> &lt;&lt; avgCalc.<span class="built_in">getAverage</span>() &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Lambda表达式">Lambda表达式</h4>
<p>Lambda表达式是C++11引入的一种匿名函数定义方式，它允许在需要函数的地方内联定义函数。Lambda表达式特别适合作为算法的谓词或回调函数。</p>
<p><strong>基本语法：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[capture](parameters) <span class="keyword">mutable</span> -&gt; return_type &#123; body &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>capture</strong>: 捕获列表，指定如何捕获外部变量
<ul>
<li><code>[=]</code>: 值捕获，捕获所有外部变量的副本</li>
<li><code>[&amp;]</code>: 引用捕获，捕获所有外部变量的引用</li>
<li><code>[x]</code>: 值捕获特定变量x</li>
<li><code>[&amp;x]</code>: 引用捕获特定变量x</li>
<li><code>[this]</code>: 捕获当前对象的this指针</li>
<li>混合捕获：如<code>[=, &amp;x]</code>表示值捕获所有变量，但引用捕获x</li>
</ul>
</li>
<li><strong>parameters</strong>: 参数列表，与普通函数类似</li>
<li><strong>mutable</strong>: 可选，允许修改值捕获的变量</li>
<li><strong>return_type</strong>: 可选，返回类型，如果可以从return语句推导则可以省略</li>
<li><strong>body</strong>: 函数体</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 基本Lambda表达式</span></span><br><span class="line">    <span class="keyword">auto</span> hello = []() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Hello, Lambda!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">hello</span>();  <span class="comment">// 调用Lambda表达式</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 带参数的Lambda表达式</span></span><br><span class="line">    <span class="keyword">auto</span> add = [](<span class="type">int</span> a, <span class="type">int</span> b) -&gt; <span class="type">int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;5 + 3 = &quot;</span> &lt;&lt; <span class="built_in">add</span>(<span class="number">5</span>, <span class="number">3</span>) &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. 值捕获</span></span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">auto</span> printX = [x]() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;x的值: &quot;</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">        <span class="comment">// x = 20;  // 编译错误，不能修改值捕获的变量</span></span><br><span class="line">    &#125;;</span><br><span class="line">    x = <span class="number">30</span>;  <span class="comment">// 修改外部x不会影响Lambda中捕获的值</span></span><br><span class="line">    <span class="built_in">printX</span>();  <span class="comment">// 输出10</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 4. 引用捕获</span></span><br><span class="line">    <span class="keyword">auto</span> printXRef = [&amp;x]() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;x的引用: &quot;</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">        x = <span class="number">20</span>;  <span class="comment">// 可以修改引用捕获的变量</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">printXRef</span>();  <span class="comment">// 输出30</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;修改后的x: &quot;</span> &lt;&lt; x &lt;&lt; std::endl;  <span class="comment">// 输出20</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 5. mutable关键字</span></span><br><span class="line">    <span class="keyword">auto</span> modifyX = [x]() <span class="keyword">mutable</span> &#123;</span><br><span class="line">        x = <span class="number">100</span>;  <span class="comment">// 允许修改值捕获的变量（只修改副本）</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Lambda内修改后的x: &quot;</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">modifyX</span>();  <span class="comment">// 输出100</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Lambda外的x: &quot;</span> &lt;&lt; x &lt;&lt; std::endl;  <span class="comment">// 仍然是20</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 6. 捕获所有变量</span></span><br><span class="line">    <span class="type">int</span> a = <span class="number">5</span>, b = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">auto</span> captureAllByValue = [=]() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;, b = &quot;</span> &lt;&lt; b &lt;&lt; std::endl;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">auto</span> captureAllByRef = [&amp;]() &#123;</span><br><span class="line">        a = <span class="number">15</span>;</span><br><span class="line">        b = <span class="number">20</span>;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;引用捕获修改后 - a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;, b = &quot;</span> &lt;&lt; b &lt;&lt; std::endl;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">captureAllByValue</span>();  <span class="comment">// 输出5和10</span></span><br><span class="line">    <span class="built_in">captureAllByRef</span>();    <span class="comment">// 输出15和20</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;外部变量 - a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;, b = &quot;</span> &lt;&lt; b &lt;&lt; std::endl;  <span class="comment">// 输出15和20</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 7. Lambda作为算法参数</span></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">5</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">6</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用Lambda排序</span></span><br><span class="line">    std::<span class="built_in">sort</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>(), [](<span class="type">int</span> x, <span class="type">int</span> y) &#123;</span><br><span class="line">        <span class="keyword">return</span> x &gt; y;  <span class="comment">// 降序排序</span></span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;降序排序: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; num : numbers) &#123;</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用Lambda过滤</span></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; evenNumbers;</span><br><span class="line">    std::<span class="built_in">copy_if</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>(), std::<span class="built_in">back_inserter</span>(evenNumbers), [](<span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">return</span> n % <span class="number">2</span> == <span class="number">0</span>;  <span class="comment">// 只复制偶数</span></span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;偶数: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; num : evenNumbers) &#123;</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 8. Lambda与函数对象的结合</span></span><br><span class="line">    std::function&lt;<span class="type">int</span>(<span class="type">int</span>)&gt; factorial = [&amp;factorial](<span class="type">int</span> n) -&gt; <span class="type">int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> n &lt;= <span class="number">1</span> ? <span class="number">1</span> : n * <span class="built_in">factorial</span>(n - <span class="number">1</span>);  <span class="comment">// 递归Lambda</span></span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;5! = &quot;</span> &lt;&lt; <span class="built_in">factorial</span>(<span class="number">5</span>) &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 9. 带状态的Lambda</span></span><br><span class="line">    <span class="keyword">auto</span> counter = [count = <span class="number">0</span>]() <span class="keyword">mutable</span> &#123;  <span class="comment">// C++14支持的初始化捕获</span></span><br><span class="line">        <span class="keyword">return</span> ++count;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;计数1: &quot;</span> &lt;&lt; <span class="built_in">counter</span>() &lt;&lt; std::endl;  <span class="comment">// 输出1</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;计数2: &quot;</span> &lt;&lt; <span class="built_in">counter</span>() &lt;&lt; std::endl;  <span class="comment">// 输出2</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;计数3: &quot;</span> &lt;&lt; <span class="built_in">counter</span>() &lt;&lt; std::endl;  <span class="comment">// 输出3</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Lambda表达式的高级用法：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;numeric&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 嵌套Lambda表达式</span></span><br><span class="line">    <span class="keyword">auto</span> outerLambda = [](<span class="type">int</span> x) &#123;</span><br><span class="line">        <span class="keyword">return</span> [x](<span class="type">int</span> y) &#123;</span><br><span class="line">            <span class="keyword">return</span> x + y;  <span class="comment">// 内部Lambda捕获外部Lambda的参数</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">auto</span> add5 = <span class="built_in">outerLambda</span>(<span class="number">5</span>);  <span class="comment">// 创建一个加5的函数</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;20 + 5 = &quot;</span> &lt;&lt; <span class="built_in">add5</span>(<span class="number">20</span>) &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">auto</span> add10 = <span class="built_in">outerLambda</span>(<span class="number">10</span>);  <span class="comment">// 创建一个加10的函数</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;20 + 10 = &quot;</span> &lt;&lt; <span class="built_in">add10</span>(<span class="number">20</span>) &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. Lambda与std::function结合</span></span><br><span class="line">    std::vector&lt;std::function&lt;<span class="type">int</span>(<span class="type">int</span>)&gt;&gt; operations;</span><br><span class="line">    </span><br><span class="line">    operations.<span class="built_in">push_back</span>([](<span class="type">int</span> x) &#123; <span class="keyword">return</span> x * x; &#125;);        <span class="comment">// 平方</span></span><br><span class="line">    operations.<span class="built_in">push_back</span>([](<span class="type">int</span> x) &#123; <span class="keyword">return</span> x * <span class="number">2</span>; &#125;);         <span class="comment">// 乘以2</span></span><br><span class="line">    operations.<span class="built_in">push_back</span>([](<span class="type">int</span> x) &#123; <span class="keyword">return</span> x / <span class="number">2</span>; &#125;);         <span class="comment">// 除以2</span></span><br><span class="line">    operations.<span class="built_in">push_back</span>([](<span class="type">int</span> x) &#123; <span class="keyword">return</span> x + <span class="number">10</span>; &#125;);        <span class="comment">// 加10</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> value = <span class="number">5</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;原始值: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; op : operations) &#123;</span><br><span class="line">        value = <span class="built_in">op</span>(value);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;应用操作后: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. 使用Lambda进行函数组合</span></span><br><span class="line">    <span class="keyword">auto</span> compose = [](<span class="keyword">auto</span> f, <span class="keyword">auto</span> g) &#123;</span><br><span class="line">        <span class="keyword">return</span> [f, g](<span class="keyword">auto</span> x) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">f</span>(<span class="built_in">g</span>(x));  <span class="comment">// 先应用g，再应用f</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">auto</span> square = [](<span class="type">int</span> x) &#123; <span class="keyword">return</span> x * x; &#125;;</span><br><span class="line">    <span class="keyword">auto</span> doubleIt = [](<span class="type">int</span> x) &#123; <span class="keyword">return</span> x * <span class="number">2</span>; &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">auto</span> squareThenDouble = <span class="built_in">compose</span>(doubleIt, square);  <span class="comment">// 先平方再乘以2</span></span><br><span class="line">    <span class="keyword">auto</span> doubleThenSquare = <span class="built_in">compose</span>(square, doubleIt);  <span class="comment">// 先乘以2再平方</span></span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;平方后乘以2 (3): &quot;</span> &lt;&lt; <span class="built_in">squareThenDouble</span>(<span class="number">3</span>) &lt;&lt; std::endl;  <span class="comment">// 18</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;乘以2后平方 (3): &quot;</span> &lt;&lt; <span class="built_in">doubleThenSquare</span>(<span class="number">3</span>) &lt;&lt; std::endl;   <span class="comment">// 36</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 4. 使用Lambda作为条件谓词</span></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 过滤出大于3且小于8的偶数</span></span><br><span class="line">    <span class="keyword">auto</span> filterCondition = [](<span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">return</span> n &gt; <span class="number">3</span> &amp;&amp; n &lt; <span class="number">8</span> &amp;&amp; n % <span class="number">2</span> == <span class="number">0</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;满足条件的数: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; num : numbers) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">filterCondition</span>(num)) &#123;</span><br><span class="line">            std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 5. 使用Lambda计算统计信息</span></span><br><span class="line">    <span class="type">double</span> sum = std::<span class="built_in">accumulate</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>(), <span class="number">0.0</span>);</span><br><span class="line">    <span class="type">double</span> average = sum / numbers.<span class="built_in">size</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 计算方差</span></span><br><span class="line">    <span class="type">double</span> variance = std::<span class="built_in">accumulate</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>(), <span class="number">0.0</span>, </span><br><span class="line">        [average](<span class="type">double</span> acc, <span class="type">int</span> n) &#123;</span><br><span class="line">            <span class="keyword">return</span> acc + (n - average) * (n - average);</span><br><span class="line">        &#125;</span><br><span class="line">    ) / numbers.<span class="built_in">size</span>();</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;平均值: &quot;</span> &lt;&lt; average &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;方差: &quot;</span> &lt;&lt; variance &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Lambda表达式与函数对象的对比：</strong></p>
<table>
<thead>
<tr>
<th>特性</th>
<th>Lambda表达式</th>
<th>函数对象</th>
</tr>
</thead>
<tbody>
<tr>
<td>定义位置</td>
<td>内联定义</td>
<td>需要单独定义类/结构体</td>
</tr>
<tr>
<td>状态保存</td>
<td>可以通过捕获列表保存外部变量</td>
<td>可以通过成员变量保存状态</td>
</tr>
<tr>
<td>可复用性</td>
<td>局部定义，作用域有限</td>
<td>可以在多个地方使用</td>
</tr>
<tr>
<td>代码可读性</td>
<td>简单表达式更易读</td>
<td>复杂逻辑更易维护</td>
</tr>
<tr>
<td>编译效率</td>
<td>通常可以很好地内联</td>
<td>通常可以很好地内联</td>
</tr>
<tr>
<td>灵活性</td>
<td>语法简洁，使用方便</td>
<td>可以定义其他成员函数和操作符</td>
</tr>
</tbody>
</table>
<p>在实际编程中，Lambda表达式通常用于简单的、局部使用的函数，而函数对象则更适合复杂的、需要在多处复用的功能。</p>
<h3 id="3-6-异常处理">3.6 异常处理</h3>
<ul>
<li>异常处理机制</li>
<li>try-catch语句</li>
<li>throw表达式</li>
<li>自定义异常类</li>
<li>标准异常库</li>
</ul>
<h3 id="3-7-智能指针">3.7 智能指针</h3>
<ul>
<li>智能指针概念与原理</li>
<li>auto_ptr（已废弃）</li>
<li>unique_ptr</li>
<li>shared_ptr</li>
<li>weak_ptr</li>
<li>循环引用问题</li>
</ul>
<h2 id="4-高级特性与实用技能">4. 高级特性与实用技能</h2>
<h3 id="4-1-内存管理">4.1 内存管理</h3>
<p>内存管理是C++编程中至关重要的环节，它直接影响程序的性能、稳定性和安全性。在C++中，开发者对内存拥有极大的控制权，同时也承担着相应的责任。</p>
<h4 id="内存分区">内存分区</h4>
<p>C++程序在运行时，内存主要分为以下几个区域：</p>
<h5 id="栈区（Stack）">栈区（Stack）</h5>
<ul>
<li><strong>特点</strong>：由编译器自动分配和释放，存放函数的参数值、局部变量等</li>
<li><strong>空间大小</strong>：通常较小（几MB）</li>
<li><strong>分配方式</strong>：后进先出（LIFO）</li>
<li><strong>效率</strong>：高，系统自动管理</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;      <span class="comment">// 局部变量，分配在栈上</span></span><br><span class="line">    <span class="type">int</span> arr[<span class="number">100</span>];    <span class="comment">// 数组，分配在栈上</span></span><br><span class="line">    <span class="comment">// 函数结束时自动释放</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="堆区（Heap）">堆区（Heap）</h5>
<ul>
<li><strong>特点</strong>：动态分配的内存，需要手动申请和释放</li>
<li><strong>空间大小</strong>：通常较大（可达到GB级别）</li>
<li><strong>分配方式</strong>：随机分配</li>
<li><strong>效率</strong>：相对较低，需要手动管理</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dynamicMemory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span>* p = <span class="keyword">new</span> <span class="type">int</span>;     <span class="comment">// 在堆上分配内存</span></span><br><span class="line">    *p = <span class="number">42</span>;</span><br><span class="line">    <span class="keyword">delete</span> p;            <span class="comment">// 必须手动释放，否则内存泄漏</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span>* arr = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>];  <span class="comment">// 动态数组</span></span><br><span class="line">    <span class="keyword">delete</span>[] arr;           <span class="comment">// 释放数组，注意使用delete[]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="全局-静态存储区">全局/静态存储区</h5>
<ul>
<li><strong>特点</strong>：存储全局变量和静态变量</li>
<li><strong>生命周期</strong>：程序运行期间一直存在</li>
<li><strong>初始化</strong>：未初始化的全局变量和静态变量会被自动初始化为0</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> globalVar = <span class="number">100</span>;       <span class="comment">// 全局变量，在全局存储区</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> staticVar = <span class="number">200</span>;  <span class="comment">// 静态局部变量，在全局/静态存储区</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="常量存储区">常量存储区</h5>
<ul>
<li><strong>特点</strong>：存储常量值，不可修改</li>
<li><strong>内容</strong>：字符串字面量等</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">constExample</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* str = <span class="string">&quot;Hello World&quot;</span>;  <span class="comment">// &quot;Hello World&quot;存储在常量区</span></span><br><span class="line">    <span class="comment">// str[0] = &#x27;h&#x27;;  // 错误：不能修改常量区内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="内存泄漏检测">内存泄漏检测</h4>
<p>内存泄漏是指程序中已分配的内存不再被使用，但未被释放的现象。内存泄漏会导致程序占用内存越来越多，最终可能导致程序崩溃。</p>
<h5 id="常见的内存泄漏场景">常见的内存泄漏场景</h5>
<ol>
<li><strong>忘记释放动态内存</strong></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">leakExample1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span>* p = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">100</span>];</span><br><span class="line">    <span class="comment">// 忘记delete[] p;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li><strong>指针重定向</strong></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">leakExample2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span>* p = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">10</span>);</span><br><span class="line">    p = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">20</span>);  <span class="comment">// 原来的内存被丢弃，无法访问也无法释放</span></span><br><span class="line">    <span class="keyword">delete</span> p;  <span class="comment">// 只释放了第二次分配的内存</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li><strong>异常导致的内存泄漏</strong></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">leakExample3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span>* p = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">100</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 可能抛出异常的代码</span></span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">exception</span>();</span><br><span class="line">    &#125; <span class="built_in">catch</span> (...) &#123;</span><br><span class="line">        <span class="comment">// 没有在catch中释放p</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 异常发生后，这里不会执行</span></span><br><span class="line">    <span class="comment">// delete[] p;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="内存泄漏检测工具">内存泄漏检测工具</h5>
<ol>
<li>
<p><strong>Valgrind</strong></p>
<ul>
<li>强大的内存调试工具</li>
<li>可以检测内存泄漏、越界访问等问题</li>
<li>示例：<code>valgrind --leak-check=full ./your_program</code></li>
</ul>
</li>
<li>
<p><strong>AddressSanitizer (ASAN)</strong></p>
<ul>
<li>编译时工具，由LLVM和GCC提供</li>
<li>使用方法：编译时添加<code>-fsanitize=address</code>选项</li>
<li>性能开销较小，检测能力强</li>
</ul>
</li>
<li>
<p><strong>Visual Leak Detector (VLD)</strong></p>
<ul>
<li>Windows平台下的内存泄漏检测工具</li>
<li>集成在Visual Studio中使用</li>
</ul>
</li>
</ol>
<h4 id="RAII原则">RAII原则</h4>
<p>RAII（Resource Acquisition Is Initialization，资源获取即初始化）是C++中管理资源的重要原则。它确保在获取资源的同时初始化对象，在对象销毁时自动释放资源。</p>
<h5 id="RAII的核心思想">RAII的核心思想</h5>
<ul>
<li>在构造函数中获取资源（内存、文件句柄、锁等）</li>
<li>在析构函数中释放资源</li>
<li>利用对象的生命周期来管理资源的生命周期</li>
</ul>
<h5 id="RAII的优势">RAII的优势</h5>
<ul>
<li><strong>自动资源管理</strong>：无需手动释放资源</li>
<li><strong>异常安全</strong>：即使发生异常，资源也能被正确释放</li>
<li><strong>代码简洁</strong>：减少样板代码</li>
</ul>
<h5 id="RAII的典型应用">RAII的典型应用</h5>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义RAII包装类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FileHandler</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    FILE* file;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">FileHandler</span>(<span class="type">const</span> <span class="type">char</span>* filename, <span class="type">const</span> <span class="type">char</span>* mode) &#123;</span><br><span class="line">        file = <span class="built_in">fopen</span>(filename, mode);</span><br><span class="line">        <span class="keyword">if</span> (!file) &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Failed to open file&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ~<span class="built_in">FileHandler</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> (file) &#123;</span><br><span class="line">            <span class="built_in">fclose</span>(file);  <span class="comment">// 自动关闭文件</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 禁止拷贝，避免资源重复释放</span></span><br><span class="line">    <span class="built_in">FileHandler</span>(<span class="type">const</span> FileHandler&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    FileHandler&amp; <span class="keyword">operator</span>=(<span class="type">const</span> FileHandler&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 允许移动</span></span><br><span class="line">    <span class="built_in">FileHandler</span>(FileHandler&amp;&amp; other) <span class="keyword">noexcept</span> : <span class="built_in">file</span>(other.file) &#123;</span><br><span class="line">        other.file = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    FileHandler&amp; <span class="keyword">operator</span>=(FileHandler&amp;&amp; other) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;other) &#123;</span><br><span class="line">            <span class="keyword">if</span> (file) <span class="built_in">fclose</span>(file);</span><br><span class="line">            file = other.file;</span><br><span class="line">            other.file = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">FILE* <span class="title">get</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> file; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用RAII类</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">safeFileOperation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="function">FileHandler <span class="title">file</span><span class="params">(<span class="string">&quot;data.txt&quot;</span>, <span class="string">&quot;r&quot;</span>)</span></span>;</span><br><span class="line">        <span class="comment">// 使用file</span></span><br><span class="line">        <span class="comment">// 函数结束或发生异常时，file对象销毁，文件自动关闭</span></span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::exception&amp; e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Error: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="析构函数的重要性">析构函数的重要性</h4>
<p>析构函数是RAII原则的核心，它确保在对象销毁时释放所有已分配的资源。</p>
<h5 id="析构函数的作用">析构函数的作用</h5>
<ul>
<li>释放对象拥有的资源（内存、文件句柄、网络连接等）</li>
<li>执行对象销毁前的清理工作</li>
<li>在对象生命周期结束时自动调用</li>
</ul>
<h5 id="常见的析构函数实现">常见的析构函数实现</h5>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ResourceManager</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span>* data;</span><br><span class="line">    std::string name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ResourceManager</span>(<span class="type">int</span> size) : <span class="built_in">name</span>(<span class="string">&quot;ResourceManager&quot;</span>) &#123;</span><br><span class="line">        data = <span class="keyword">new</span> <span class="type">int</span>[size];</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Constructor: &quot;</span> &lt;&lt; name &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ~<span class="built_in">ResourceManager</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] data;  <span class="comment">// 释放动态分配的内存</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Destructor: &quot;</span> &lt;&lt; name &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#123;  <span class="comment">// 作用域开始</span></span><br><span class="line">        <span class="function">ResourceManager <span class="title">rm</span><span class="params">(<span class="number">100</span>)</span></span>;</span><br><span class="line">        <span class="comment">// 作用域结束时，rm对象销毁，析构函数自动调用</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="注意事项">注意事项</h5>
<ol>
<li><strong>虚析构函数</strong>：在多态继承中，基类的析构函数应该声明为虚函数，以确保派生类对象通过基类指针销毁时，能正确调用派生类的析构函数</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() &#123;  <span class="comment">// 虚析构函数</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Base destructor&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span>* data;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Derived</span>() &#123;</span><br><span class="line">        data = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">100</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ~<span class="built_in">Derived</span>() <span class="keyword">override</span> &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] data;  <span class="comment">// 正确释放派生类资源</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Derived destructor&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base* ptr = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">    <span class="keyword">delete</span> ptr;  <span class="comment">// 由于Base有虚析构函数，会先调用Derived::~Derived()，再调用Base::~Base()</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>
<p><strong>默认析构函数</strong>：当类没有管理动态资源时，可以依赖编译器生成的默认析构函数</p>
</li>
<li>
<p><strong>三/五/零法则</strong>：如果需要自定义析构函数，通常也需要自定义拷贝构造函数和拷贝赋值运算符（C++11引入了移动语义后扩展为五法则）</p>
</li>
</ol>
<h3 id="4-2-面向对象设计原则">4.2 面向对象设计原则</h3>
<p>面向对象设计原则是指导软件设计的经验总结，遵循这些原则可以创建出更具可维护性、可扩展性和可重用性的代码。</p>
<h4 id="封装、继承、多态原则">封装、继承、多态原则</h4>
<p>这些是面向对象编程的三大核心特性，它们共同构成了面向对象设计的基础。</p>
<h5 id="封装（Encapsulation）">封装（Encapsulation）</h5>
<p>封装是将数据（属性）和行为（方法）组合在一个单元中，并控制对它们的访问权限。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BankAccount</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:  <span class="comment">// 封装数据，限制直接访问</span></span><br><span class="line">    <span class="type">double</span> balance;</span><br><span class="line">    std::string ownerName;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:  <span class="comment">// 提供受控的访问接口</span></span><br><span class="line">    <span class="built_in">BankAccount</span>(<span class="type">const</span> std::string&amp; name, <span class="type">double</span> initialBalance) </span><br><span class="line">        : <span class="built_in">ownerName</span>(name), <span class="built_in">balance</span>(initialBalance) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">deposit</span><span class="params">(<span class="type">double</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (amount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            balance += amount;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">withdraw</span><span class="params">(<span class="type">double</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (amount &gt; <span class="number">0</span> &amp;&amp; amount &lt;= balance) &#123;</span><br><span class="line">            balance -= amount;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">getBalance</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> balance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="继承（Inheritance）">继承（Inheritance）</h5>
<p>继承允许一个类（派生类）继承另一个类（基类）的属性和方法，实现代码重用。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Vehicle</span> &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    std::string brand;</span><br><span class="line">    <span class="type">int</span> year;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Vehicle</span>(<span class="type">const</span> std::string&amp; b, <span class="type">int</span> y) : <span class="built_in">brand</span>(b), <span class="built_in">year</span>(y) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">start</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Vehicle started.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> : <span class="keyword">public</span> Vehicle &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> numDoors;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Car</span>(<span class="type">const</span> std::string&amp; b, <span class="type">int</span> y, <span class="type">int</span> doors)</span><br><span class="line">        : <span class="built_in">Vehicle</span>(b, y), <span class="built_in">numDoors</span>(doors) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">start</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; brand &lt;&lt; <span class="string">&quot; car started.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="多态（Polymorphism）">多态（Polymorphism）</h5>
<p>多态允许使用基类指针或引用调用派生类的方法，实现动态绑定。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">testVehicle</span><span class="params">(<span class="type">const</span> Vehicle&amp; vehicle)</span> </span>&#123;</span><br><span class="line">    vehicle.<span class="built_in">start</span>();  <span class="comment">// 根据实际对象类型调用相应的start()</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Vehicle <span class="title">generic</span><span class="params">(<span class="string">&quot;Generic&quot;</span>, <span class="number">2020</span>)</span></span>;</span><br><span class="line">    <span class="function">Car <span class="title">myCar</span><span class="params">(<span class="string">&quot;Toyota&quot;</span>, <span class="number">2022</span>, <span class="number">4</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">testVehicle</span>(generic);  <span class="comment">// 输出: Vehicle started.</span></span><br><span class="line">    <span class="built_in">testVehicle</span>(myCar);    <span class="comment">// 输出: Toyota car started.</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="SOLID设计原则">SOLID设计原则</h4>
<p>SOLID是五个重要设计原则的首字母缩写，这些原则有助于创建更加健壮、可维护的软件。</p>
<h5 id="单一职责原则（Single-Responsibility-Principle-SRP）">单一职责原则（Single Responsibility Principle, SRP）</h5>
<p>每个类应该只有一个引起它变化的原因，即一个类只负责一项职责。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 遵循SRP的设计</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string name;</span><br><span class="line">    std::string email;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">User</span>(<span class="type">const</span> std::string&amp; n, <span class="type">const</span> std::string&amp; e) </span><br><span class="line">        : <span class="built_in">name</span>(n), <span class="built_in">email</span>(e) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">const</span> std::string&amp; <span class="title">getName</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> name; &#125;</span><br><span class="line">    <span class="function"><span class="type">const</span> std::string&amp; <span class="title">getEmail</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> email; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UserRepository</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">saveUser</span><span class="params">(<span class="type">const</span> User&amp; user)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 保存用户到数据库</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">User <span class="title">findUserById</span><span class="params">(<span class="type">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 从数据库查找用户</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">User</span>(<span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>); <span class="comment">// 示例返回</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EmailService</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sendEmail</span><span class="params">(<span class="type">const</span> User&amp; user, <span class="type">const</span> std::string&amp; message)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 发送邮件</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="开放封闭原则（Open-Closed-Principle-OCP）">开放封闭原则（Open-Closed Principle, OCP）</h5>
<p>软件实体（类、模块、函数等）应该对扩展开放，对修改封闭。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 良好的设计 - 使用虚函数实现OCP</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">calculateArea</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Shape</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> : <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> width;</span><br><span class="line">    <span class="type">double</span> height;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Rectangle</span>(<span class="type">double</span> w, <span class="type">double</span> h) : <span class="built_in">width</span>(w), <span class="built_in">height</span>(h) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">calculateArea</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> width * height;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> : <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> radius;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Circle</span>(<span class="type">double</span> r) : <span class="built_in">radius</span>(r) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">calculateArea</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> M_PI * radius * radius;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不需要修改此函数即可支持新的形状</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printArea</span><span class="params">(<span class="type">const</span> Shape&amp; shape)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Area: &quot;</span> &lt;&lt; shape.<span class="built_in">calculateArea</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="里氏替换原则（Liskov-Substitution-Principle-LSP）">里氏替换原则（Liskov Substitution Principle, LSP）</h5>
<p>派生类应该能够替换其基类而不改变程序的正确性。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 遵循LSP的设计</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> width;</span><br><span class="line">    <span class="type">double</span> height;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">setWidth</span><span class="params">(<span class="type">double</span> w)</span> </span>&#123; width = w; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">setHeight</span><span class="params">(<span class="type">double</span> h)</span> </span>&#123; height = h; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">getArea</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> width * height; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Square</span> : <span class="keyword">public</span> Rectangle &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setWidth</span><span class="params">(<span class="type">double</span> w)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        Rectangle::<span class="built_in">setWidth</span>(w);</span><br><span class="line">        Rectangle::<span class="built_in">setHeight</span>(w);  <span class="comment">// 保持宽高一致</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setHeight</span><span class="params">(<span class="type">double</span> h)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        Rectangle::<span class="built_in">setWidth</span>(h);  <span class="comment">// 保持宽高一致</span></span><br><span class="line">        Rectangle::<span class="built_in">setHeight</span>(h);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="接口隔离原则（Interface-Segregation-Principle-ISP）">接口隔离原则（Interface Segregation Principle, ISP）</h5>
<p>客户端不应该被迫实现它不需要的接口。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 良好的接口设计 - 细分接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Printer</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Printer</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Scanner</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">scan</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Scanner</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Fax</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fax</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Fax</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多功能设备可以实现多个接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AllInOneDevice</span> : <span class="keyword">public</span> Printer, <span class="keyword">public</span> Scanner, <span class="keyword">public</span> Fax &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; <span class="comment">/* 实现 */</span> &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">scan</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; <span class="comment">/* 实现 */</span> &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fax</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; <span class="comment">/* 实现 */</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简单打印机只实现必要的接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SimplePrinter</span> : <span class="keyword">public</span> Printer &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; <span class="comment">/* 实现 */</span> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="依赖倒置原则（Dependency-Inversion-Principle-DIP）">依赖倒置原则（Dependency Inversion Principle, DIP）</h5>
<p>高层模块不应该依赖低层模块，两者都应该依赖于抽象；抽象不应该依赖于细节，细节应该依赖于抽象。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 良好的设计 - 依赖抽象</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Database</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">connect</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">query</span><span class="params">(<span class="type">const</span> std::string&amp; sql)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Database</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MySQLDatabase</span> : <span class="keyword">public</span> Database &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">connect</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="comment">// MySQL连接实现</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">query</span><span class="params">(<span class="type">const</span> std::string&amp; sql)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="comment">// MySQL查询实现</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PostgreSQLDatabase</span> : <span class="keyword">public</span> Database &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">connect</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="comment">// PostgreSQL连接实现</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">query</span><span class="params">(<span class="type">const</span> std::string&amp; sql)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="comment">// PostgreSQL查询实现</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 高层模块依赖抽象而非具体实现</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Database&amp; database;  <span class="comment">// 依赖抽象接口</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 通过构造函数注入具体实现</span></span><br><span class="line">    <span class="built_in">UserService</span>(Database&amp; db) : <span class="built_in">database</span>(db) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">createUser</span><span class="params">(<span class="type">const</span> std::string&amp; username)</span> </span>&#123;</span><br><span class="line">        database.<span class="built_in">connect</span>();</span><br><span class="line">        database.<span class="built_in">query</span>(<span class="string">&quot;INSERT INTO users VALUES (&#x27;&quot;</span> + username + <span class="string">&quot;&#x27;)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="组合优于继承">组合优于继承</h4>
<p>组合是通过将对象作为成员变量包含在另一个对象中，而不是通过继承来实现功能复用。在许多情况下，组合比继承更加灵活。</p>
<h5 id="组合的优势">组合的优势</h5>
<ul>
<li><strong>避免紧耦合</strong>：组合不会创建继承层次结构中的紧耦合</li>
<li><strong>更好的封装</strong>：被组合的对象的实现细节对外不可见</li>
<li><strong>动态行为</strong>：可以在运行时更换被组合的对象，改变行为</li>
<li><strong>避免菱形继承问题</strong></li>
</ul>
<h5 id="组合示例">组合示例</h5>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Engine</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> horsepower;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Engine</span>(<span class="type">int</span> hp) : <span class="built_in">horsepower</span>(hp) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Engine started with &quot;</span> &lt;&lt; horsepower &lt;&lt; <span class="string">&quot; HP&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Transmission</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string type;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Transmission</span>(<span class="type">const</span> std::string&amp; t) : <span class="built_in">type</span>(t) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">shiftGear</span><span class="params">(<span class="type">int</span> gear)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; type &lt;&lt; <span class="string">&quot; transmission shifted to gear &quot;</span> &lt;&lt; gear &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 组合方式</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Engine engine;          <span class="comment">// 组合Engine对象</span></span><br><span class="line">    Transmission transmission;  <span class="comment">// 组合Transmission对象</span></span><br><span class="line">    std::string brand;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Car</span>(<span class="type">const</span> std::string&amp; b, <span class="type">int</span> hp, <span class="type">const</span> std::string&amp; transType)</span><br><span class="line">        : <span class="built_in">brand</span>(b), <span class="built_in">engine</span>(hp), <span class="built_in">transmission</span>(transType) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">drive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        engine.<span class="built_in">start</span>();</span><br><span class="line">        transmission.<span class="built_in">shiftGear</span>(<span class="number">1</span>);</span><br><span class="line">        std::cout &lt;&lt; brand &lt;&lt; <span class="string">&quot; is driving&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="设计模式基础">设计模式基础</h4>
<p>设计模式是针对软件设计中常见问题的可重用解决方案。以下是一些常用的设计模式：</p>
<h5 id="创建型模式">创建型模式</h5>
<ol>
<li><strong>单例模式（Singleton）</strong>：确保一个类只有一个实例，并提供全局访问点</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Logger</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> Logger* instance;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 私有构造函数，防止外部创建实例</span></span><br><span class="line">    <span class="built_in">Logger</span>() &#123;&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 全局访问点</span></span><br><span class="line">    <span class="function"><span class="type">static</span> Logger* <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="built_in">Logger</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">log</span><span class="params">(<span class="type">const</span> std::string&amp; message)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;[LOG] &quot;</span> &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态成员初始化</span></span><br><span class="line">Logger* Logger::instance = <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li><strong>工厂模式（Factory）</strong>：提供一个创建对象的接口，允许子类决定实例化的类</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Shape</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> : <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Drawing a circle&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> : <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Drawing a rectangle&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 工厂类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ShapeFactory</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> Shape* <span class="title">createShape</span><span class="params">(<span class="type">const</span> std::string&amp; shapeType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (shapeType == <span class="string">&quot;circle&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Circle</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (shapeType == <span class="string">&quot;rectangle&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Rectangle</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="结构型模式">结构型模式</h5>
<ol>
<li><strong>适配器模式（Adapter）</strong>：将一个类的接口转换成客户端期望的另一个接口</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 已有的不兼容接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OldPrinter</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printDocument</span><span class="params">(<span class="type">const</span> std::string&amp; document)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Old printer printing: &quot;</span> &lt;&lt; document &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端期望的接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NewPrinterInterface</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> std::string&amp; content)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">NewPrinterInterface</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 适配器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PrinterAdapter</span> : <span class="keyword">public</span> NewPrinterInterface &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    OldPrinter oldPrinter;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> std::string&amp; content)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        oldPrinter.<span class="built_in">printDocument</span>(content);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li><strong>装饰器模式（Decorator）</strong>：动态地给对象添加一些额外的职责</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Coffee</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">cost</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::string <span class="title">description</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Coffee</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SimpleCoffee</span> : <span class="keyword">public</span> Coffee &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">cost</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">std::string <span class="title">description</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Simple Coffee&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 装饰器基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CoffeeDecorator</span> : <span class="keyword">public</span> Coffee &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Coffee*</span><br><span class="line">estedCoffee;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CoffeeDecorator</span>(Coffee* coffee) : <span class="built_in">nestedCoffee</span>(coffee) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">cost</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nestedCoffee-&gt;<span class="built_in">cost</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">std::string <span class="title">description</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nestedCoffee-&gt;<span class="built_in">description</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ~<span class="built_in">CoffeeDecorator</span>() <span class="keyword">override</span> &#123;</span><br><span class="line">        <span class="keyword">delete</span> nestedCoffee;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MilkDecorator</span> : <span class="keyword">public</span> CoffeeDecorator &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MilkDecorator</span>(Coffee* coffee) : <span class="built_in">CoffeeDecorator</span>(coffee) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">cost</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> CoffeeDecorator::<span class="built_in">cost</span>() + <span class="number">0.5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">std::string <span class="title">description</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> CoffeeDecorator::<span class="built_in">description</span>() + <span class="string">&quot;, Milk&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="行为型模式">行为型模式</h5>
<ol>
<li><strong>观察者模式（Observer）</strong>：定义对象间的一种一对多依赖关系，当一个对象状态改变时，所有依赖它的对象都会得到通知</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">float</span> temperature)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Observer</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WeatherStation</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;Observer*&gt; observers;</span><br><span class="line">    <span class="type">float</span> temperature;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addObserver</span><span class="params">(Observer* observer)</span> </span>&#123;</span><br><span class="line">        observers.<span class="built_in">push_back</span>(observer);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">removeObserver</span><span class="params">(Observer* observer)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 移除观察者</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setTemperature</span><span class="params">(<span class="type">float</span> temp)</span> </span>&#123;</span><br><span class="line">        temperature = temp;</span><br><span class="line">        <span class="built_in">notifyObservers</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">notifyObservers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> observer : observers) &#123;</span><br><span class="line">            observer-&gt;<span class="built_in">update</span>(temperature);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DisplayDevice</span> : <span class="keyword">public</span> Observer &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string name;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">DisplayDevice</span>(<span class="type">const</span> std::string&amp; n) : <span class="built_in">name</span>(n) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">float</span> temperature)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; name &lt;&lt; <span class="string">&quot; shows temperature: &quot;</span> &lt;&lt; temperature &lt;&lt; <span class="string">&quot;°C&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li><strong>策略模式（Strategy）</strong>：定义一系列算法，把它们封装起来，并使它们可以互相替换</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PaymentStrategy</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">pay</span><span class="params">(<span class="type">double</span> amount)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">PaymentStrategy</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CreditCardPayment</span> : <span class="keyword">public</span> PaymentStrategy &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string cardNumber;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CreditCardPayment</span>(<span class="type">const</span> std::string&amp; card) : <span class="built_in">cardNumber</span>(card) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pay</span><span class="params">(<span class="type">double</span> amount)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Paid &quot;</span> &lt;&lt; amount &lt;&lt; <span class="string">&quot; using credit card: &quot;</span> &lt;&lt; cardNumber &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PayPalPayment</span> : <span class="keyword">public</span> PaymentStrategy &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string email;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">PayPalPayment</span>(<span class="type">const</span> std::string&amp; e) : <span class="built_in">email</span>(e) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pay</span><span class="params">(<span class="type">double</span> amount)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Paid &quot;</span> &lt;&lt; amount &lt;&lt; <span class="string">&quot; using PayPal account: &quot;</span> &lt;&lt; email &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ShoppingCart</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    PaymentStrategy* paymentStrategy;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setPaymentStrategy</span><span class="params">(PaymentStrategy* strategy)</span> </span>&#123;</span><br><span class="line">        paymentStrategy = strategy;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">checkout</span><span class="params">(<span class="type">double</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (paymentStrategy) &#123;</span><br><span class="line">            paymentStrategy-&gt;<span class="built_in">pay</span>(amount);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="4-3-文件操作">4.3 文件操作</h3>
<p>文件操作是程序与外部存储设备交互的重要方式。C++提供了两种主要的文件操作方式：基于C语言的文件操作和C++特有的面向对象文件操作。</p>
<h4 id="C风格文件操作">C风格文件操作</h4>
<p>C风格的文件操作主要使用<code>stdio.h</code>头文件中定义的函数，如<code>fopen</code>、<code>fclose</code>、<code>fread</code>、<code>fwrite</code>等。</p>
<h5 id="文件打开与关闭">文件打开与关闭</h5>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cStyleFileOperations</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 打开文件 - 模式包括：&quot;r&quot;(读取), &quot;w&quot;(写入), &quot;a&quot;(追加), &quot;r+&quot;(读写), &quot;wb&quot;(二进制写入)等</span></span><br><span class="line">    FILE* file = <span class="built_in">fopen</span>(<span class="string">&quot;example.txt&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (file == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;Failed to open file&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 文件操作...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 关闭文件 - 必须执行，否则可能导致资源泄漏</span></span><br><span class="line">    <span class="built_in">fclose</span>(file);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="文件写入操作">文件写入操作</h5>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">writeToFile</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    FILE* file = <span class="built_in">fopen</span>(<span class="string">&quot;output.txt&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (file == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;Failed to open file for writing&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 格式化写入</span></span><br><span class="line">    <span class="built_in">fprintf</span>(file, <span class="string">&quot;Hello, %s!\n&quot;</span>, <span class="string">&quot;World&quot;</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(file, <span class="string">&quot;Number: %d, Float: %.2f\n&quot;</span>, <span class="number">42</span>, <span class="number">3.14159</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 字符写入</span></span><br><span class="line">    <span class="built_in">fputc</span>(<span class="string">&#x27;A&#x27;</span>, file);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 字符串写入</span></span><br><span class="line">    <span class="built_in">fputs</span>(<span class="string">&quot;\nThis is a string.&quot;</span>, file);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">fclose</span>(file);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Data written to file successfully.\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="文件读取操作">文件读取操作</h5>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">readFromFile</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    FILE* file = <span class="built_in">fopen</span>(<span class="string">&quot;input.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (file == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;Failed to open file for reading&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 字符读取</span></span><br><span class="line">    <span class="type">int</span> ch;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Reading character by character:\n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> ((ch = <span class="built_in">fgetc</span>(file)) != EOF) &#123;</span><br><span class="line">        <span class="built_in">putchar</span>(ch);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 重置文件指针到开始位置</span></span><br><span class="line">    <span class="built_in">rewind</span>(file);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 行读取</span></span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">256</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n\nReading line by line:\n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">fgets</span>(buffer, <span class="built_in">sizeof</span>(buffer), file) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Read: %s&quot;</span>, buffer);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 格式化读取</span></span><br><span class="line">    <span class="built_in">rewind</span>(file);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n\nReading formatted data:\n&quot;</span>);</span><br><span class="line">    <span class="type">char</span> name[<span class="number">50</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fscanf</span>(file, <span class="string">&quot;%s %d&quot;</span>, name, &amp;age) == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Name: %s, Age: %d\n&quot;</span>, name, age);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">fclose</span>(file);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="文件位置操作">文件位置操作</h5>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">filePositioning</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    FILE* file = <span class="built_in">fopen</span>(<span class="string">&quot;example.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (file == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;Failed to open file&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取当前文件指针位置</span></span><br><span class="line">    <span class="type">long</span> currentPos = <span class="built_in">ftell</span>(file);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Initial position: %ld\n&quot;</span>, currentPos);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置文件指针到指定位置（偏移量，起始位置）</span></span><br><span class="line">    <span class="built_in">fseek</span>(file, <span class="number">10</span>, SEEK_SET);  <span class="comment">// 从文件开头偏移10个字节</span></span><br><span class="line">    currentPos = <span class="built_in">ftell</span>(file);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;After fseek: %ld\n&quot;</span>, currentPos);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 跳过5个字节</span></span><br><span class="line">    <span class="built_in">fseek</span>(file, <span class="number">5</span>, SEEK_CUR);</span><br><span class="line">    currentPos = <span class="built_in">ftell</span>(file);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;After skipping 5 bytes: %ld\n&quot;</span>, currentPos);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 移动到文件末尾</span></span><br><span class="line">    <span class="built_in">fseek</span>(file, <span class="number">0</span>, SEEK_END);</span><br><span class="line">    currentPos = <span class="built_in">ftell</span>(file);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;At end of file: %ld bytes\n&quot;</span>, currentPos);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 重置到文件开头</span></span><br><span class="line">    <span class="built_in">rewind</span>(file);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">fclose</span>(file);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="C-风格文件操作">C++风格文件操作</h4>
<p>C++提供了更安全、更面向对象的文件操作方式，主要通过<code>fstream</code>库中的类实现。</p>
<h5 id="主要的文件流类">主要的文件流类</h5>
<ul>
<li><strong>ofstream</strong>: 用于文件输出操作（写入文件）</li>
<li><strong>ifstream</strong>: 用于文件输入操作（读取文件）</li>
<li><strong>fstream</strong>: 兼具输入和输出功能</li>
</ul>
<h5 id="文件打开与关闭-2">文件打开与关闭</h5>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cppStyleFileOperations</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 打开文件进行写入</span></span><br><span class="line">    <span class="function">std::ofstream <span class="title">outFile</span><span class="params">(<span class="string">&quot;output_cpp.txt&quot;</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!outFile.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Failed to open file for writing&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 写入数据</span></span><br><span class="line">    outFile &lt;&lt; <span class="string">&quot;Hello, C++ File Operations!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 显式关闭（虽然析构函数会自动关闭，但显式关闭是好习惯）</span></span><br><span class="line">    outFile.<span class="built_in">close</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 打开文件进行读取</span></span><br><span class="line">    <span class="function">std::ifstream <span class="title">inFile</span><span class="params">(<span class="string">&quot;input_cpp.txt&quot;</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!inFile.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Failed to open file for reading&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 读取数据...</span></span><br><span class="line">    </span><br><span class="line">    inFile.<span class="built_in">close</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用构造函数参数指定打开模式</span></span><br><span class="line">    <span class="function">std::fstream <span class="title">file</span><span class="params">(<span class="string">&quot;data.txt&quot;</span>, std::ios::in | std::ios::out | std::ios::binary)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!file.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Failed to open file&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    file.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="文件打开模式">文件打开模式</h5>
<table>
<thead>
<tr>
<th>模式</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ios::in</code></td>
<td>打开文件进行读取</td>
</tr>
<tr>
<td><code>ios::out</code></td>
<td>打开文件进行写入（默认会截断文件）</td>
</tr>
<tr>
<td><code>ios::app</code></td>
<td>追加模式，写入到文件末尾</td>
</tr>
<tr>
<td><code>ios::ate</code></td>
<td>打开文件并移动到文件末尾</td>
</tr>
<tr>
<td><code>ios::trunc</code></td>
<td>如果文件存在，截断文件内容</td>
</tr>
<tr>
<td><code>ios::binary</code></td>
<td>以二进制模式打开文件</td>
</tr>
<tr>
<td><code>ios::nocreate</code></td>
<td>如果文件不存在，打开失败</td>
</tr>
<tr>
<td><code>ios::noreplace</code></td>
<td>如果文件已存在，打开失败</td>
</tr>
</tbody>
</table>
<h5 id="文件写入操作-2">文件写入操作</h5>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">writeToCppFile</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 打开文件进行写入</span></span><br><span class="line">    <span class="function">std::ofstream <span class="title">outFile</span><span class="params">(<span class="string">&quot;cpp_output.txt&quot;</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!outFile) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Error opening file for writing&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用流插入运算符写入</span></span><br><span class="line">    std::string message = <span class="string">&quot;C++ File Writing Example&quot;</span>;</span><br><span class="line">    <span class="type">int</span> number = <span class="number">42</span>;</span><br><span class="line">    <span class="type">double</span> value = <span class="number">3.14159</span>;</span><br><span class="line">    </span><br><span class="line">    outFile &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">    outFile &lt;&lt; <span class="string">&quot;Number: &quot;</span> &lt;&lt; number &lt;&lt; std::endl;</span><br><span class="line">    outFile &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用write方法写入字符数组</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* binaryData = <span class="string">&quot;Binary data&quot;</span>;</span><br><span class="line">    outFile.<span class="built_in">write</span>(binaryData, <span class="built_in">strlen</span>(binaryData));</span><br><span class="line">    </span><br><span class="line">    outFile.<span class="built_in">close</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Data written to file successfully.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="文件读取操作-2">文件读取操作</h5>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">readFromCppFile</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 打开文件进行读取</span></span><br><span class="line">    <span class="function">std::ifstream <span class="title">inFile</span><span class="params">(<span class="string">&quot;cpp_input.txt&quot;</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!inFile) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Error opening file for reading&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 方法1：逐行读取</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Reading line by line:\n&quot;</span>;</span><br><span class="line">    std::string line;</span><br><span class="line">    <span class="keyword">while</span> (std::<span class="built_in">getline</span>(inFile, line)) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Read: &quot;</span> &lt;&lt; line &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 重置文件指针到开头</span></span><br><span class="line">    inFile.<span class="built_in">clear</span>();  <span class="comment">// 清除EOF标志</span></span><br><span class="line">    inFile.<span class="built_in">seekg</span>(<span class="number">0</span>); <span class="comment">// 移动到文件开头</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 方法2：使用流提取运算符（会自动跳过空白字符）</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\nReading word by word:\n&quot;</span>;</span><br><span class="line">    std::string word;</span><br><span class="line">    <span class="keyword">while</span> (inFile &gt;&gt; word) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Word: &quot;</span> &lt;&lt; word &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 重置文件指针到开头</span></span><br><span class="line">    inFile.<span class="built_in">clear</span>();</span><br><span class="line">    inFile.<span class="built_in">seekg</span>(<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 方法3：使用read方法读取指定数量的字符</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\nReading binary data:\n&quot;</span>;</span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">100</span>];</span><br><span class="line">    inFile.<span class="built_in">read</span>(buffer, <span class="built_in">sizeof</span>(buffer) - <span class="number">1</span>);</span><br><span class="line">    buffer[inFile.<span class="built_in">gcount</span>()] = <span class="string">&#x27;\0&#x27;</span>; <span class="comment">// 添加字符串结束符</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Read &quot;</span> &lt;&lt; inFile.<span class="built_in">gcount</span>() &lt;&lt; <span class="string">&quot; characters: &quot;</span> &lt;&lt; buffer &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    inFile.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="文件位置操作-2">文件位置操作</h5>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">cppFilePositioning</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::fstream <span class="title">file</span><span class="params">(<span class="string">&quot;position.txt&quot;</span>, std::ios::in | std::ios::out | std::ios::trunc)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!file) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Error opening file&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 写入一些数据</span></span><br><span class="line">    file &lt;&lt; <span class="string">&quot;0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取当前写指针位置</span></span><br><span class="line">    std::streampos writePos = file.<span class="built_in">tellp</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Current write position: &quot;</span> &lt;&lt; writePos &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置读取位置</span></span><br><span class="line">    file.<span class="built_in">seekg</span>(<span class="number">5</span>); <span class="comment">// 移动到第6个字符位置</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 读取并显示字符</span></span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    file.<span class="built_in">get</span>(ch);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Character at position 5: &quot;</span> &lt;&lt; ch &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 相对位置移动</span></span><br><span class="line">    file.<span class="built_in">seekg</span>(<span class="number">10</span>, std::ios::cur); <span class="comment">// 从当前位置向后移动10个字符</span></span><br><span class="line">    file.<span class="built_in">get</span>(ch);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Character 10 positions from current: &quot;</span> &lt;&lt; ch &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 移动到文件末尾</span></span><br><span class="line">    file.<span class="built_in">seekg</span>(<span class="number">0</span>, std::ios::end);</span><br><span class="line">    std::streampos fileSize = file.<span class="built_in">tellg</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;File size: &quot;</span> &lt;&lt; fileSize &lt;&lt; <span class="string">&quot; bytes&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 移动到文件开头</span></span><br><span class="line">    file.<span class="built_in">seekg</span>(<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    file.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="二进制文件与文本文件">二进制文件与文本文件</h4>
<p>文件可以分为文本文件和二进制文件两种主要类型。</p>
<h5 id="文本文件">文本文件</h5>
<ul>
<li><strong>特点</strong>：以字符序列形式存储，每个字符对应一个或多个字节</li>
<li><strong>可读性</strong>：可以用文本编辑器直接查看和编辑</li>
<li><strong>适用场景</strong>：存储文本数据，如配置文件、日志文件等</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">textFileExample</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 写入文本文件</span></span><br><span class="line">    <span class="function">std::ofstream <span class="title">textFile</span><span class="params">(<span class="string">&quot;text_data.txt&quot;</span>)</span></span>;</span><br><span class="line">    textFile &lt;&lt; <span class="string">&quot;This is a text file.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    textFile &lt;&lt; <span class="string">&quot;Numbers: 123, 456, 789&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    textFile.<span class="built_in">close</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 读取文本文件</span></span><br><span class="line">    <span class="function">std::ifstream <span class="title">inTextFile</span><span class="params">(<span class="string">&quot;text_data.txt&quot;</span>)</span></span>;</span><br><span class="line">    std::string line;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Text file content:\n&quot;</span>;</span><br><span class="line">    <span class="keyword">while</span> (std::<span class="built_in">getline</span>(inTextFile, line)) &#123;</span><br><span class="line">        std::cout &lt;&lt; line &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    inTextFile.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="二进制文件">二进制文件</h5>
<ul>
<li><strong>特点</strong>：以字节序列形式直接存储数据的二进制表示</li>
<li><strong>效率</strong>：读写效率更高，节省空间</li>
<li><strong>适用场景</strong>：存储图像、音频、视频等二进制数据，或需要高效存储的结构化数据</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">50</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">double</span> salary;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">binaryFileExample</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 写入二进制文件</span></span><br><span class="line">    <span class="function">std::ofstream <span class="title">binaryFile</span><span class="params">(<span class="string">&quot;binary_data.dat&quot;</span>, std::ios::binary)</span></span>;</span><br><span class="line">    </span><br><span class="line">    Person person1 = &#123;<span class="string">&quot;John Doe&quot;</span>, <span class="number">30</span>, <span class="number">50000.50</span>&#125;;</span><br><span class="line">    Person person2 = &#123;<span class="string">&quot;Jane Smith&quot;</span>, <span class="number">25</span>, <span class="number">45000.75</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    binaryFile.<span class="built_in">write</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> <span class="type">char</span>*&gt;(&amp;person1), <span class="built_in">sizeof</span>(Person));</span><br><span class="line">    binaryFile.<span class="built_in">write</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> <span class="type">char</span>*&gt;(&amp;person2), <span class="built_in">sizeof</span>(Person));</span><br><span class="line">    binaryFile.<span class="built_in">close</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 读取二进制文件</span></span><br><span class="line">    <span class="function">std::ifstream <span class="title">inBinaryFile</span><span class="params">(<span class="string">&quot;binary_data.dat&quot;</span>, std::ios::binary)</span></span>;</span><br><span class="line">    Person readPerson;</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Binary file content:\n&quot;</span>;</span><br><span class="line">    <span class="keyword">while</span> (inBinaryFile.<span class="built_in">read</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span>*&gt;(&amp;readPerson), <span class="built_in">sizeof</span>(Person))) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Name: &quot;</span> &lt;&lt; readPerson.name &lt;&lt; <span class="string">&quot;, Age: &quot;</span> &lt;&lt; readPerson.age </span><br><span class="line">                  &lt;&lt; <span class="string">&quot;, Salary: &quot;</span> &lt;&lt; readPerson.salary &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    inBinaryFile.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="文件读写操作的最佳实践">文件读写操作的最佳实践</h4>
<ol>
<li>
<p><strong>始终检查文件是否成功打开</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::ifstream <span class="title">file</span><span class="params">(<span class="string">&quot;data.txt&quot;</span>)</span></span>;</span><br><span class="line"><span class="keyword">if</span> (!file) &#123;</span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;Failed to open file!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>使用RAII原则管理文件资源</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">processFile</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::ifstream <span class="title">file</span><span class="params">(<span class="string">&quot;data.txt&quot;</span>)</span></span>;  <span class="comment">// RAII - 自动管理生命周期</span></span><br><span class="line">    <span class="keyword">if</span> (file) &#123;</span><br><span class="line">        <span class="comment">// 使用文件...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 文件自动关闭，无需手动调用close()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>处理文件读取错误</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::string <span class="title">readData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::ifstream <span class="title">file</span><span class="params">(<span class="string">&quot;data.txt&quot;</span>)</span></span>;</span><br><span class="line">    std::string data;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!file) &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Failed to open file&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    std::string line;</span><br><span class="line">    <span class="keyword">while</span> (std::<span class="built_in">getline</span>(file, line)) &#123;</span><br><span class="line">        data += line + <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (file.<span class="built_in">bad</span>()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;I/O error while reading file&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>使用异常处理文件操作</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">safeFileOperation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="function">std::ofstream <span class="title">file</span><span class="params">(<span class="string">&quot;output.txt&quot;</span>)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (!file) &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::ios_base::<span class="built_in">failure</span>(<span class="string">&quot;Unable to open file for writing&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 设置异常掩码，使流操作失败时抛出异常</span></span><br><span class="line">        file.<span class="built_in">exceptions</span>(std::ofstream::failbit | std::ofstream::badbit);</span><br><span class="line">        </span><br><span class="line">        file &lt;&lt; <span class="string">&quot;Critical data&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::exception&amp; e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;File operation failed: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>处理大文件时考虑分块读写</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">copyLargeFile</span><span class="params">(<span class="type">const</span> std::string&amp; source, <span class="type">const</span> std::string&amp; destination)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">size_t</span> BUFFER_SIZE = <span class="number">4096</span>;</span><br><span class="line">    <span class="type">char</span> buffer[BUFFER_SIZE];</span><br><span class="line">    </span><br><span class="line">    <span class="function">std::ifstream <span class="title">src</span><span class="params">(source, std::ios::binary)</span></span>;</span><br><span class="line">    <span class="function">std::ofstream <span class="title">dst</span><span class="params">(destination, std::ios::binary)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!src || !dst) &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Failed to open files&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (src.<span class="built_in">read</span>(buffer, BUFFER_SIZE)) &#123;</span><br><span class="line">        dst.<span class="built_in">write</span>(buffer, src.<span class="built_in">gcount</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 处理最后一次读取（可能不完整）</span></span><br><span class="line">    dst.<span class="built_in">write</span>(buffer, src.<span class="built_in">gcount</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="4-4-多线程编程">4.4 多线程编程</h3>
<p>多线程编程是现代软件开发中的重要技术，它允许程序并发执行多个任务，从而提高程序的性能和响应性。C++11引入了标准的线程库，使得多线程编程更加简单和跨平台。</p>
<h4 id="C-11线程库">C++11线程库</h4>
<p>C++11提供了<code>&lt;thread&gt;</code>头文件，其中定义了<code>std::thread</code>类，用于创建和管理线程。此外，还有其他相关的头文件和类，如<code>&lt;mutex&gt;</code>、<code>&lt;condition_variable&gt;</code>、<code>&lt;atomic&gt;</code>等，用于线程同步和通信。</p>
<h5 id="主要组件">主要组件</h5>
<ul>
<li><strong><code>std::thread</code></strong>: 线程类，用于创建和管理线程</li>
<li><strong><code>std::mutex</code></strong>: 互斥锁，用于保护共享数据</li>
<li><strong><code>std::condition_variable</code></strong>: 条件变量，用于线程间的同步通信</li>
<li><strong><code>std::atomic</code></strong>: 原子类型，用于无锁的线程安全操作</li>
<li><strong><code>std::lock_guard</code>/<code>std::unique_lock</code></strong>: RAII风格的锁管理工具</li>
<li><strong><code>std::future</code>/<code>std::promise</code>/<code>std::async</code></strong>: 用于异步任务的结果获取和同步</li>
</ul>
<h4 id="线程创建与管理">线程创建与管理</h4>
<h5 id="基本线程创建">基本线程创建</h5>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">threadFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello from thread! Thread ID: &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个新线程，执行threadFunction</span></span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(threadFunction)</span></span>;</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello from main! Thread ID: &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 等待线程t完成执行</span></span><br><span class="line">    <span class="keyword">if</span> (t.<span class="built_in">joinable</span>()) &#123;</span><br><span class="line">        t.<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="使用函数对象创建线程">使用函数对象创建线程</h5>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadTask</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Hello from function object thread!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">createThreadWithFunctionObject</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用函数对象</span></span><br><span class="line">    ThreadTask task;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(task)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用临时函数对象，需要使用额外的括号或使用std::ref</span></span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(ThreadTask())</span></span>;</span><br><span class="line">    </span><br><span class="line">    t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">    t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="使用lambda表达式创建线程">使用lambda表达式创建线程</h5>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">createThreadWithLambda</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> data = <span class="number">42</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用lambda表达式创建线程，通过引用捕获变量</span></span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">([&amp;data]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        std::cout &lt;&lt; <span class="string">&quot;Lambda thread, data: &quot;</span> &lt;&lt; data &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">        data = <span class="number">100</span>; <span class="comment">// 修改引用捕获的变量</span></span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;)</span></span>;</span><br><span class="line">    </span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Main thread, modified data: &quot;</span> &lt;&lt; data &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="传递参数给线程函数">传递参数给线程函数</h5>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">threadWithArguments</span><span class="params">(<span class="type">int</span> a, <span class="type">double</span> b, std::string c)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Thread arguments: a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;, b = &quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot;, c = &quot;</span> &lt;&lt; c &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">passArgumentsToThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line">    <span class="type">double</span> y = <span class="number">3.14</span>;</span><br><span class="line">    std::string z = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 参数默认按值传递</span></span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(threadWithArguments, x, y, z)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用std::ref或std::cref进行引用传递</span></span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">([](<span class="type">int</span>&amp; ref_param) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        std::cout &lt;&lt; <span class="string">&quot;Reference parameter: &quot;</span> &lt;&lt; ref_param &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">        ref_param = <span class="number">20</span>; <span class="comment">// 修改会影响到原始变量</span></span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;, std::ref(x))</span></span>;</span><br><span class="line">    </span><br><span class="line">    t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">    t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Modified x: &quot;</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="线程分离">线程分离</h5>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">detachThreadExample</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">([]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        std::this_thread::sleep_for(std::chrono::seconds(<span class="number">2</span>));</span></span></span><br><span class="line"><span class="params"><span class="function">        std::cout &lt;&lt; <span class="string">&quot;Detached thread finished&quot;</span> &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 分离线程，不再需要join</span></span><br><span class="line">    t.<span class="built_in">detach</span>();</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Main thread continues&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 主线程需要等待足够长的时间，否则程序可能在分离线程完成前结束</span></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">3</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="线程移动">线程移动</h5>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">threadMoveExample</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">([]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        std::cout &lt;&lt; <span class="string">&quot;Thread function&quot;</span> &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 线程对象可以移动但不能复制</span></span><br><span class="line">    std::thread t2 = std::<span class="built_in">move</span>(t1);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 此时t1不再拥有线程，joinable()返回false</span></span><br><span class="line">    <span class="keyword">if</span> (!t<span class="number">1.</span><span class="built_in">joinable</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;t1 is no longer joinable&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    t<span class="number">2.</span><span class="built_in">join</span>(); <span class="comment">// 必须join或detach t2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="互斥锁与条件变量">互斥锁与条件变量</h4>
<p>在多线程环境中，多个线程访问共享资源可能会导致数据竞争和不一致。互斥锁（mutex）用于保护共享数据，确保同一时间只有一个线程可以访问该数据。</p>
<h5 id="基本互斥锁使用">基本互斥锁使用</h5>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::mutex g_mutex; <span class="comment">// 全局互斥锁</span></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; g_sharedData;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addToSharedData</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 锁定互斥锁</span></span><br><span class="line">    g_mutex.<span class="built_in">lock</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 访问共享数据</span></span><br><span class="line">        g_sharedData.<span class="built_in">push_back</span>(value);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 解锁互斥锁</span></span><br><span class="line">        g_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">    &#125; <span class="built_in">catch</span> (...) &#123;</span><br><span class="line">        <span class="comment">// 发生异常时也要解锁</span></span><br><span class="line">        g_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">        <span class="keyword">throw</span>; <span class="comment">// 重新抛出异常</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="使用std-lock-guard（RAII风格锁）">使用std::lock_guard（RAII风格锁）</h5>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">safeAddToSharedData</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// std::lock_guard在构造时锁定，析构时解锁，使用RAII原则</span></span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(g_mutex)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 访问共享数据</span></span><br><span class="line">    g_sharedData.<span class="built_in">push_back</span>(value);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// lock_guard析构时自动解锁，即使发生异常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="使用std-unique-lock（更灵活的锁）">使用std::unique_lock（更灵活的锁）</h5>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">flexibleLockExample</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(g_mutex)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用条件变量时，可能需要暂时释放锁</span></span><br><span class="line">    <span class="comment">// ... 在某些条件变量操作中可能会调用lock.unlock()和lock.lock()</span></span><br><span class="line">    </span><br><span class="line">    g_sharedData.<span class="built_in">push_back</span>(<span class="number">100</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 可以手动提前解锁</span></span><br><span class="line">    lock.<span class="built_in">unlock</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 执行不需要锁的操作</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 可以重新锁定</span></span><br><span class="line">    lock.<span class="built_in">lock</span>();</span><br><span class="line">    g_sharedData.<span class="built_in">push_back</span>(<span class="number">200</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 析构时如果仍然持有锁，会自动解锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="死锁问题与解决方案">死锁问题与解决方案</h5>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 死锁示例：两个线程互相等待对方持有的锁</span></span><br><span class="line">std::mutex mutex1, mutex2;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mutex<span class="number">1.l</span>ock();</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">10</span>)); <span class="comment">// 故意延迟，增加死锁可能性</span></span><br><span class="line">    mutex<span class="number">2.l</span>ock();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 临界区</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Thread1: Critical section&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    mutex<span class="number">2.</span><span class="built_in">unlock</span>();</span><br><span class="line">    mutex<span class="number">1.</span><span class="built_in">unlock</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mutex<span class="number">2.l</span>ock();</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">10</span>));</span><br><span class="line">    mutex<span class="number">1.l</span>ock();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 临界区</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Thread2: Critical section&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    mutex<span class="number">1.</span><span class="built_in">unlock</span>();</span><br><span class="line">    mutex<span class="number">2.</span><span class="built_in">unlock</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解决方案1：使用std::lock同时锁定多个互斥锁</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">safeThread1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::<span class="built_in">lock</span>(mutex1, mutex2); <span class="comment">// 同时锁定两个互斥锁，避免死锁</span></span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock1</span><span class="params">(mutex1, std::adopt_lock)</span></span>;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock2</span><span class="params">(mutex2, std::adopt_lock)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 临界区</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;SafeThread1: Critical section&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解决方案2：始终按照相同的顺序获取锁</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">safeThreadOrder1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock1</span><span class="params">(mutex1)</span></span>; <span class="comment">// 先锁1，再锁2</span></span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock2</span><span class="params">(mutex2)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 临界区</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">safeThreadOrder2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock1</span><span class="params">(mutex1)</span></span>; <span class="comment">// 同样先锁1，再锁2</span></span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock2</span><span class="params">(mutex2)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 临界区</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="条件变量">条件变量</h5>
<p>条件变量用于线程间的通知机制，允许一个线程等待特定条件发生，而另一个线程在条件满足时通知等待的线程。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::mutex queueMutex;</span><br><span class="line">std::condition_variable queueCondVar;</span><br><span class="line">std::queue&lt;<span class="type">int</span>&gt; messageQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者线程函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">producer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        &#123;   <span class="comment">// 作用域控制锁的生命周期</span></span><br><span class="line">            <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(queueMutex)</span></span>;</span><br><span class="line">            messageQueue.<span class="built_in">push</span>(i);</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Produced: &quot;</span> &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 通知等待的消费者线程</span></span><br><span class="line">        queueCondVar.<span class="built_in">notify_one</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 模拟生产延迟</span></span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 发送结束信号</span></span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(queueMutex)</span></span>;</span><br><span class="line">        messageQueue.<span class="built_in">push</span>(<span class="number">-1</span>); <span class="comment">// -1表示结束</span></span><br><span class="line">    &#125;</span><br><span class="line">    queueCondVar.<span class="built_in">notify_one</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者线程函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">consumer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(queueMutex)</span></span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 等待直到队列非空</span></span><br><span class="line">        queueCondVar.<span class="built_in">wait</span>(lock, []&#123; <span class="keyword">return</span> !messageQueue.<span class="built_in">empty</span>(); &#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获取队列中的消息</span></span><br><span class="line">        <span class="type">int</span> message = messageQueue.<span class="built_in">front</span>();</span><br><span class="line">        messageQueue.<span class="built_in">pop</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 解锁，允许其他线程访问队列</span></span><br><span class="line">        lock.<span class="built_in">unlock</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 检查是否结束</span></span><br><span class="line">        <span class="keyword">if</span> (message == <span class="number">-1</span>) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Consumer: Exiting&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 处理消息</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Consumed: &quot;</span> &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">conditionVariableExample</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">prodThread</span><span class="params">(producer)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">consThread</span><span class="params">(consumer)</span></span>;</span><br><span class="line">    </span><br><span class="line">    prodThread.<span class="built_in">join</span>();</span><br><span class="line">    consThread.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="原子操作">原子操作</h4>
<p>原子操作是线程安全的操作，无需使用互斥锁就能保证在多线程环境中的正确性。C++11引入了<code>&lt;atomic&gt;</code>头文件，提供了原子类型和操作。</p>
<h5 id="基本原子类型">基本原子类型</h5>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::atomic&lt;<span class="type">int</span>&gt; <span class="title">atomicCounter</span><span class="params">(<span class="number">0</span>)</span></span>; <span class="comment">// 原子计数器</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">incrementCounter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; ++i) &#123;</span><br><span class="line">        atomicCounter++; <span class="comment">// 原子操作，线程安全</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">atomicExample</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(incrementCounter)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(incrementCounter)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t3</span><span class="params">(incrementCounter)</span></span>;</span><br><span class="line">    </span><br><span class="line">    t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">    t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line">    t<span class="number">3.</span><span class="built_in">join</span>();</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Final counter value: &quot;</span> &lt;&lt; atomicCounter &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// 应该输出300000，而不是一个不确定的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="原子类型的其他操作">原子类型的其他操作</h5>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">atomicOperations</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::atomic&lt;<span class="type">int</span>&gt; <span class="title">value</span><span class="params">(<span class="number">100</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 读取操作</span></span><br><span class="line">    <span class="type">int</span> x = value.<span class="built_in">load</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Initial value: &quot;</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 写入操作</span></span><br><span class="line">    value.<span class="built_in">store</span>(<span class="number">200</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;After store: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 交换操作</span></span><br><span class="line">    <span class="type">int</span> oldValue = value.<span class="built_in">exchange</span>(<span class="number">300</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Old value: &quot;</span> &lt;&lt; oldValue &lt;&lt; <span class="string">&quot;, New value: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 比较并交换 (CAS) 操作</span></span><br><span class="line">    <span class="type">int</span> expected = <span class="number">300</span>;</span><br><span class="line">    <span class="type">bool</span> result = value.<span class="built_in">compare_exchange_strong</span>(expected, <span class="number">400</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;CAS result: &quot;</span> &lt;&lt; (result ? <span class="string">&quot;success&quot;</span> : <span class="string">&quot;failure&quot;</span>) &lt;&lt; <span class="string">&quot;, New value: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// fetch_add操作：原子地增加值并返回旧值</span></span><br><span class="line">    <span class="type">int</span> prev = value.<span class="built_in">fetch_add</span>(<span class="number">50</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Before fetch_add: &quot;</span> &lt;&lt; prev &lt;&lt; <span class="string">&quot;, After: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// fetch_sub操作：原子地减少值并返回旧值</span></span><br><span class="line">    prev = value.<span class="built_in">fetch_sub</span>(<span class="number">25</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Before fetch_sub: &quot;</span> &lt;&lt; prev &lt;&lt; <span class="string">&quot;, After: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="内存序">内存序</h5>
<p>原子操作可以指定不同的内存序（memory order），用于控制原子操作周围的内存访问如何排序。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">memoryOrderExample</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::atomic&lt;<span class="type">int</span>&gt; <span class="title">flag</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 默认是memory_order_seq_cst (顺序一致)</span></span><br><span class="line">    flag.<span class="built_in">store</span>(<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 显式指定内存序</span></span><br><span class="line">    flag.<span class="built_in">store</span>(<span class="number">2</span>, std::memory_order_relaxed);</span><br><span class="line">    <span class="type">int</span> value = flag.<span class="built_in">load</span>(std::memory_order_acquire);</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value with acquire order: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="线程池">线程池</h4>
<p>线程池是一种并发设计模式，预先创建一组工作线程，用于执行提交的任务队列。这样可以避免频繁创建和销毁线程的开销，提高程序性能。</p>
<h5 id="简单线程池实现">简单线程池实现</h5>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadPool</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;std::thread&gt; workers;        <span class="comment">// 工作线程</span></span><br><span class="line">    std::queue&lt;std::function&lt;<span class="type">void</span>()&gt;&gt; tasks;  <span class="comment">// 任务队列</span></span><br><span class="line">    </span><br><span class="line">    std::mutex queueMutex;                     <span class="comment">// 保护任务队列的互斥锁</span></span><br><span class="line">    std::condition_variable condition;         <span class="comment">// 条件变量，用于通知工作线程有新任务</span></span><br><span class="line">    std::atomic&lt;<span class="type">bool</span>&gt; stop;                 <span class="comment">// 停止标志</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数，创建指定数量的线程</span></span><br><span class="line">    <span class="built_in">ThreadPool</span>(<span class="type">size_t</span> numThreads) : <span class="built_in">stop</span>(<span class="literal">false</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; numThreads; ++i) &#123;</span><br><span class="line">            workers.<span class="built_in">emplace_back</span>([<span class="keyword">this</span>] &#123;</span><br><span class="line">                <span class="comment">// 工作线程函数</span></span><br><span class="line">                <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                    std::function&lt;<span class="built_in">void</span>()&gt; task;</span><br><span class="line">                    </span><br><span class="line">                    &#123;   <span class="comment">// 锁定互斥锁</span></span><br><span class="line">                        std::unique_lock&lt;std::mutex&gt; <span class="built_in">lock</span>(<span class="keyword">this</span>-&gt;queueMutex);</span><br><span class="line">                        </span><br><span class="line">                        <span class="comment">// 等待直到有任务或者需要停止</span></span><br><span class="line">                        <span class="keyword">this</span>-&gt;condition.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>] &#123;</span><br><span class="line">                            <span class="keyword">return</span> <span class="keyword">this</span>-&gt;stop || !<span class="keyword">this</span>-&gt;tasks.<span class="built_in">empty</span>();</span><br><span class="line">                        &#125;);</span><br><span class="line">                        </span><br><span class="line">                        <span class="comment">// 如果停止标志为true且队列为空，退出循环</span></span><br><span class="line">                        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;stop &amp;&amp; <span class="keyword">this</span>-&gt;tasks.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                            <span class="keyword">return</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        </span><br><span class="line">                        <span class="comment">// 取出任务</span></span><br><span class="line">                        task = std::<span class="built_in">move</span>(<span class="keyword">this</span>-&gt;tasks.<span class="built_in">front</span>());</span><br><span class="line">                        <span class="keyword">this</span>-&gt;tasks.<span class="built_in">pop</span>();</span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// 执行任务（此时已经解锁，可以并发执行）</span></span><br><span class="line">                    <span class="built_in">task</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 注意：完整实现ThreadPool类需要包含以下头文件：</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    #include &lt;iostream&gt;</span></span><br><span class="line"><span class="comment">    #include &lt;vector&gt;</span></span><br><span class="line"><span class="comment">    #include &lt;queue&gt;</span></span><br><span class="line"><span class="comment">    #include &lt;thread&gt;</span></span><br><span class="line"><span class="comment">    #include &lt;mutex&gt;</span></span><br><span class="line"><span class="comment">    #include &lt;condition_variable&gt;</span></span><br><span class="line"><span class="comment">    #include &lt;future&gt;</span></span><br><span class="line"><span class="comment">    #include &lt;functional&gt;</span></span><br><span class="line"><span class="comment">    #include &lt;memory&gt;</span></span><br><span class="line"><span class="comment">    #include &lt;chrono&gt;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 禁止拷贝构造函数和拷贝赋值运算符</span></span><br><span class="line">    <span class="built_in">ThreadPool</span>(<span class="type">const</span> ThreadPool&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    ThreadPool&amp; <span class="keyword">operator</span>=(<span class="type">const</span> ThreadPool&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 提交任务到线程池</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> F, <span class="keyword">class</span>... Args&gt;</span></span><br><span class="line"><span class="function">    <span class="keyword">auto</span> <span class="title">enqueue</span><span class="params">(F&amp;&amp; f, Args&amp;&amp;... args)</span> </span></span><br><span class="line"><span class="function">        -&gt; std::future&lt;<span class="title">decltype</span><span class="params">(f(args...))</span>&gt; </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建一个共享指针，指向一个包装好的任务</span></span><br><span class="line">        <span class="keyword">using</span> return_type = <span class="keyword">decltype</span>(<span class="built_in">f</span>(args...));</span><br><span class="line">        <span class="keyword">auto</span> task = std::make_shared&lt;std::packaged_task&lt;<span class="built_in">return_type</span>()&gt;&gt;(</span><br><span class="line">            std::<span class="built_in">bind</span>(std::forward&lt;F&gt;(f), std::forward&lt;Args&gt;(args)...)</span><br><span class="line">        );</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获取future，用于获取任务的返回值</span></span><br><span class="line">        std::future&lt;return_type&gt; result = task-&gt;<span class="built_in">get_future</span>();</span><br><span class="line">        </span><br><span class="line">        &#123;   <span class="comment">// 锁定互斥锁，将任务添加到队列</span></span><br><span class="line">            <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(queueMutex)</span></span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 如果线程池已经停止，不能添加新任务</span></span><br><span class="line">            <span class="keyword">if</span> (stop) &#123;</span><br><span class="line">                <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;enqueue on stopped ThreadPool&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 添加任务到队列</span></span><br><span class="line">            tasks.<span class="built_in">emplace</span>([task]() &#123; (*task)(); &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 通知一个等待的线程</span></span><br><span class="line">        condition.<span class="built_in">notify_one</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 返回future</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 析构函数，停止所有线程</span></span><br><span class="line">    ~<span class="built_in">ThreadPool</span>() &#123;</span><br><span class="line">        &#123;   <span class="comment">// 锁定互斥锁，设置停止标志</span></span><br><span class="line">            <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(queueMutex)</span></span>;</span><br><span class="line">            stop = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 通知所有等待的线程</span></span><br><span class="line">        condition.<span class="built_in">notify_all</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 等待所有线程完成</span></span><br><span class="line">        <span class="keyword">for</span> (std::thread&amp; worker : workers) &#123;</span><br><span class="line">            <span class="keyword">if</span> (worker.<span class="built_in">joinable</span>()) &#123;</span><br><span class="line">                worker.<span class="built_in">join</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用线程池的示例</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">threadPoolExample</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个有4个线程的线程池</span></span><br><span class="line">    <span class="function">ThreadPool <span class="title">pool</span><span class="params">(<span class="number">4</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 保存所有任务的future</span></span><br><span class="line">    std::vector&lt;std::future&lt;<span class="type">int</span>&gt;&gt; results;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 提交10个任务到线程池</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        results.<span class="built_in">emplace_back</span>(</span><br><span class="line">            pool.<span class="built_in">enqueue</span>([i] &#123;</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;Task &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; running on thread &quot;</span> </span><br><span class="line">                          &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; std::endl;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 模拟耗时操作</span></span><br><span class="line">                std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> i * i; <span class="comment">// 返回结果</span></span><br><span class="line">            &#125;)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取并输出所有任务的结果</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; results.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Result of task &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; results[i].<span class="built_in">get</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;All tasks completed&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="多线程编程最佳实践">多线程编程最佳实践</h4>
<ol>
<li>
<p><strong>避免共享可变状态</strong></p>
<ul>
<li>尽量使用局部变量和不可变对象</li>
<li>当必须共享数据时，使用适当的同步机制</li>
</ul>
</li>
<li>
<p><strong>优先使用高级同步机制</strong></p>
<ul>
<li>使用<code>std::future</code>和<code>std::async</code>进行简单的异步操作</li>
<li>使用线程安全的数据结构（如<code>std::atomic</code>）而不是手动加锁</li>
</ul>
</li>
<li>
<p><strong>正确使用互斥锁</strong></p>
<ul>
<li>锁的范围要尽可能小</li>
<li>避免在持有锁的状态下调用外部函数</li>
<li>使用RAII风格的锁管理工具（<code>std::lock_guard</code>、<code>std::unique_lock</code>）</li>
</ul>
</li>
<li>
<p><strong>避免死锁</strong></p>
<ul>
<li>始终以相同的顺序获取多个锁</li>
<li>使用<code>std::lock</code>同时获取多个锁</li>
<li>设置适当的超时机制</li>
</ul>
</li>
<li>
<p><strong>处理线程异常</strong></p>
<ul>
<li>确保异常不会导致资源泄漏（尤其是锁）</li>
<li>使用RAII原则管理所有资源</li>
</ul>
</li>
<li>
<p><strong>考虑使用并发安全的数据结构</strong></p>
<ul>
<li>在C++17中引入了<code>std::shared_mutex</code>、<code>std::shared_lock</code>等</li>
<li>在C++20中引入了更多的并发数据结构</li>
</ul>
</li>
<li>
<p><strong>合理设计线程数量</strong></p>
<ul>
<li>通常线程数量不超过CPU核心数的2倍</li>
<li>IO密集型任务可以有更多线程</li>
<li>计算密集型任务的线程数通常等于或略大于CPU核心数</li>
</ul>
</li>
<li>
<p><strong>避免忙等待</strong></p>
<ul>
<li>使用条件变量而不是循环检查标志</li>
<li>适当使用<code>std::this_thread::sleep_for</code>减少CPU占用</li>
</ul>
</li>
<li>
<p><strong>使用线程池管理线程资源</strong></p>
<ul>
<li>避免频繁创建和销毁线程的开销</li>
<li>更好地控制并发度</li>
</ul>
</li>
<li>
<p><strong>使用<code>std::async</code>进行简单的异步操作</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">asyncExample</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 异步执行函数，返回future</span></span><br><span class="line">    std::future&lt;<span class="type">int</span>&gt; future = std::<span class="built_in">async</span>(std::launch::async, [] &#123;</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">2</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">42</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 执行其他操作</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Doing other work...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取异步操作的结果（如果操作未完成，会阻塞等待）</span></span><br><span class="line">    <span class="type">int</span> result = future.<span class="built_in">get</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Async result: &quot;</span> &lt;&lt; result &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="4-5-模板元编程">4.5 模板元编程</h3>
<p>模板元编程（Template Metaprogramming, TMP）是一种在编译时执行计算的编程技术，它利用C++模板系统的特性来进行编译期计算和类型操作。模板元编程可以生成高效的代码，实现高级的编译期优化和类型安全的设计模式。</p>
<h4 id="编译期计算">编译期计算</h4>
<p>编译期计算允许在程序编译时而非运行时执行计算，从而提高运行时性能。</p>
<h5 id="编译期常量计算">编译期常量计算</h5>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编译期计算斐波那契数列</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="type">unsigned</span> <span class="type">int</span> n&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Fibonacci</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">unsigned</span> <span class="type">int</span> value = Fibonacci&lt;n<span class="number">-1</span>&gt;::value + Fibonacci&lt;n<span class="number">-2</span>&gt;::value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 特化：基本情况</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Fibonacci</span>&lt;<span class="number">0</span>&gt; &#123;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">unsigned</span> <span class="type">int</span> value = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Fibonacci</span>&lt;<span class="number">1</span>&gt; &#123;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">unsigned</span> <span class="type">int</span> value = <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">compileTimeComputation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 编译期计算，不会产生运行时开销</span></span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">unsigned</span> <span class="type">int</span> fib10 = Fibonacci&lt;<span class="number">10</span>&gt;::value; <span class="comment">// 55</span></span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">unsigned</span> <span class="type">int</span> fib20 = Fibonacci&lt;<span class="number">20</span>&gt;::value; <span class="comment">// 6765</span></span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Fibonacci(10) = &quot;</span> &lt;&lt; fib10 &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Fibonacci(20) = &quot;</span> &lt;&lt; fib20 &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译期阶乘计算</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="type">unsigned</span> <span class="type">int</span> n&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Factorial</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">unsigned</span> <span class="type">int</span> value = n * Factorial&lt;n<span class="number">-1</span>&gt;::value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Factorial</span>&lt;<span class="number">0</span>&gt; &#123;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">unsigned</span> <span class="type">int</span> value = <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">factorialExample</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 编译期计算阶乘</span></span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">unsigned</span> <span class="type">int</span> fact5 = Factorial&lt;<span class="number">5</span>&gt;::value;  <span class="comment">// 120</span></span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">unsigned</span> <span class="type">int</span> fact10 = Factorial&lt;<span class="number">10</span>&gt;::value; <span class="comment">// 3628800</span></span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Factorial(5) = &quot;</span> &lt;&lt; fact5 &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Factorial(10) = &quot;</span> &lt;&lt; fact10 &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="使用constexpr函数（C-11及更高版本）">使用constexpr函数（C++11及更高版本）</h5>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// constexpr函数可以在编译期计算</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">factorial</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n &lt;= <span class="number">1</span> ? <span class="number">1</span> : n * <span class="built_in">factorial</span>(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b == <span class="number">0</span> ? a : <span class="built_in">gcd</span>(b, a % b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">constexprFunctionExample</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 编译期计算</span></span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">int</span> fact10 = <span class="built_in">factorial</span>(<span class="number">10</span>); <span class="comment">// 3628800</span></span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">int</span> gcdResult = <span class="built_in">gcd</span>(<span class="number">48</span>, <span class="number">30</span>); <span class="comment">// 6</span></span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;10! = &quot;</span> &lt;&lt; fact10 &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;gcd(48, 30) = &quot;</span> &lt;&lt; gcdResult &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 也可以在运行时使用</span></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Enter a number: &quot;</span>;</span><br><span class="line">    std::cin &gt;&gt; n;</span><br><span class="line">    std::cout &lt;&lt; n &lt;&lt; <span class="string">&quot;! = &quot;</span> &lt;&lt; <span class="built_in">factorial</span>(n) &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="编译期类型选择">编译期类型选择</h5>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编译期条件类型选择</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="type">bool</span> B, <span class="keyword">typename</span> T, <span class="keyword">typename</span> F&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">conditional</span> &#123;</span><br><span class="line">    <span class="keyword">using</span> type = T;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> F&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">conditional</span>&lt;<span class="literal">false</span>, T, F&gt; &#123;</span><br><span class="line">    <span class="keyword">using</span> type = F;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">compileTimeTypeSelection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 编译期根据条件选择类型</span></span><br><span class="line">    <span class="keyword">using</span> Type1 = <span class="keyword">typename</span> conditional&lt;<span class="literal">true</span>, <span class="type">int</span>, <span class="type">double</span>&gt;::type;    <span class="comment">// int</span></span><br><span class="line">    <span class="keyword">using</span> Type2 = <span class="keyword">typename</span> conditional&lt;<span class="literal">false</span>, <span class="type">int</span>, <span class="type">double</span>&gt;::type;   <span class="comment">// double</span></span><br><span class="line">    </span><br><span class="line">    Type1 x = <span class="number">42</span>;      <span class="comment">// int类型</span></span><br><span class="line">    Type2 y = <span class="number">3.14</span>;    <span class="comment">// double类型</span></span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;x type size: &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(x) &lt;&lt; <span class="string">&quot; bytes&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;y type size: &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(y) &lt;&lt; <span class="string">&quot; bytes&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="类型特征（Type-Traits）">类型特征（Type Traits）</h4>
<p>类型特征是模板元编程的重要工具，用于在编译期检查和修改类型的属性。C++11引入了标准库中的<code>&lt;type_traits&gt;</code>头文件，提供了丰富的类型特征功能。</p>
<h5 id="基本类型特征">基本类型特征</h5>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">basicTypeTraits</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 检查类型属性</span></span><br><span class="line">    std::cout &lt;&lt; std::boolalpha;</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;std::is_integral&lt;int&gt;::value: &quot;</span> &lt;&lt; std::is_integral&lt;<span class="type">int</span>&gt;::value &lt;&lt; std::endl;          <span class="comment">// true</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;std::is_floating_point&lt;double&gt;::value: &quot;</span> &lt;&lt; std::is_floating_point&lt;<span class="type">double</span>&gt;::value &lt;&lt; std::endl;  <span class="comment">// true</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;std::is_pointer&lt;int*&gt;::value: &quot;</span> &lt;&lt; std::is_pointer&lt;<span class="type">int</span>*&gt;::value &lt;&lt; std::endl;           <span class="comment">// true</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;std::is_reference&lt;int&amp;&gt;::value: &quot;</span> &lt;&lt; std::is_reference&lt;<span class="type">int</span>&amp;&gt;::value &lt;&lt; std::endl;        <span class="comment">// true</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;std::is_const&lt;const int&gt;::value: &quot;</span> &lt;&lt; std::is_const&lt;<span class="type">const</span> <span class="type">int</span>&gt;::value &lt;&lt; std::endl;        <span class="comment">// true</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 类型关系</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;std::is_same&lt;int, int&gt;::value: &quot;</span> &lt;&lt; std::is_same&lt;<span class="type">int</span>, <span class="type">int</span>&gt;::value &lt;&lt; std::endl;            <span class="comment">// true</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;std::is_same&lt;int, double&gt;::value: &quot;</span> &lt;&lt; std::is_same&lt;<span class="type">int</span>, <span class="type">double</span>&gt;::value &lt;&lt; std::endl;       <span class="comment">// false</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 类型修饰符移除</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;std::is_same&lt;std::remove_reference&lt;int&amp;&gt;::type, int&gt;::value: &quot;</span> </span><br><span class="line">              &lt;&lt; std::is_same&lt;std::remove_reference&lt;<span class="type">int</span>&amp;&gt;::type, <span class="type">int</span>&gt;::value &lt;&lt; std::endl; <span class="comment">// true</span></span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;std::is_same&lt;std::remove_const&lt;const int&gt;::type, int&gt;::value: &quot;</span> </span><br><span class="line">              &lt;&lt; std::is_same&lt;std::remove_const&lt;<span class="type">const</span> <span class="type">int</span>&gt;::type, <span class="type">int</span>&gt;::value &lt;&lt; std::endl; <span class="comment">// true</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 组合使用</span></span><br><span class="line">    <span class="keyword">using</span> CleanType = <span class="keyword">typename</span> std::remove_cv&lt;std::remove_reference&lt;<span class="type">const</span> <span class="type">int</span>&amp;&gt;::type&gt;::type;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;std::is_same&lt;CleanType, int&gt;::value: &quot;</span> &lt;&lt; std::is_same&lt;CleanType, <span class="type">int</span>&gt;::value &lt;&lt; std::endl; <span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="自定义类型特征">自定义类型特征</h5>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义类型特征，检查一个类型是否有特定成员函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 主模板（默认为false）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> = <span class="type">void</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> has_size_method : std::false_type &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 特化版本，当T有size()成员函数时为true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">has_size_method</span>&lt;T, </span><br><span class="line">    <span class="keyword">typename</span> std::enable_if&lt;</span><br><span class="line">        std::is_same&lt;</span><br><span class="line">            <span class="keyword">decltype</span>(std::<span class="built_in">declval</span>&lt;T&gt;().<span class="built_in">size</span>()),</span><br><span class="line">            <span class="type">size_t</span></span><br><span class="line">        &gt;::value</span><br><span class="line">    &gt;::type</span><br><span class="line">&gt; : std::true_type &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试自定义类型特征</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ContainerWithSize</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="number">42</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ContainerWithoutSize</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dummy</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">customTypeTraits</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; std::boolalpha;</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;has_size_method&lt;std::vector&lt;int&gt;&gt;::value: &quot;</span> &lt;&lt; has_size_method&lt;std::vector&lt;<span class="type">int</span>&gt;&gt;::value &lt;&lt; std::endl;      <span class="comment">// true</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;has_size_method&lt;ContainerWithSize&gt;::value: &quot;</span> &lt;&lt; has_size_method&lt;ContainerWithSize&gt;::value &lt;&lt; std::endl;     <span class="comment">// true</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;has_size_method&lt;ContainerWithoutSize&gt;::value: &quot;</span> &lt;&lt; has_size_method&lt;ContainerWithoutSize&gt;::value &lt;&lt; std::endl; <span class="comment">// false</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;has_size_method&lt;int&gt;::value: &quot;</span> &lt;&lt; has_size_method&lt;<span class="type">int</span>&gt;::value &lt;&lt; std::endl;                           <span class="comment">// false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="使用类型特征进行编译期决策">使用类型特征进行编译期决策</h5>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据类型特征选择不同的实现</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> std::enable_if&lt;std::is_integral&lt;T&gt;::value, std::string&gt;::<span class="function">type</span></span><br><span class="line"><span class="function"><span class="title">processValue</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Processing integral value: &quot;</span> + std::<span class="built_in">to_string</span>(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> std::enable_if&lt;std::is_floating_point&lt;T&gt;::value, std::string&gt;::<span class="function">type</span></span><br><span class="line"><span class="function"><span class="title">processValue</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Processing floating point value: &quot;</span> + std::<span class="built_in">to_string</span>(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> std::enable_if&lt;!std::is_arithmetic&lt;T&gt;::value, std::string&gt;::<span class="function">type</span></span><br><span class="line"><span class="function"><span class="title">processValue</span><span class="params">(<span class="type">const</span> T&amp; value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Processing non-arithmetic type&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">typeTraitsInAction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">processValue</span>(<span class="number">42</span>) &lt;&lt; std::endl;          <span class="comment">// 调用整数版本</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">processValue</span>(<span class="number">3.14</span>) &lt;&lt; std::endl;        <span class="comment">// 调用浮点版本</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">processValue</span>(std::<span class="built_in">string</span>(<span class="string">&quot;hello&quot;</span>)) &lt;&lt; std::endl; <span class="comment">// 调用非算术版本</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="可变参数模板">可变参数模板</h4>
<p>可变参数模板（Variadic Templates）允许模板接受任意数量和类型的参数，这是C++11引入的重要特性。</p>
<h5 id="基本可变参数模板">基本可变参数模板</h5>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基本可变参数模板</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printAll</span><span class="params">(Args... args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 展开参数包</span></span><br><span class="line">    (std::cout &lt;&lt; ... &lt;&lt; args) &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// C++17之前的参数包展开方式</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printOne</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; t &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归终止条件（空参数列表）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printRecursive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归打印所有参数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printRecursive</span><span class="params">(T first, Args... rest)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printOne</span>(first);</span><br><span class="line">    <span class="built_in">printRecursive</span>(rest...); <span class="comment">// 递归调用，减少参数数量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">variadicTemplateExample</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// C++17折叠表达式</span></span><br><span class="line">    <span class="built_in">printAll</span>(<span class="number">1</span>, <span class="string">&quot;hello&quot;</span>, <span class="number">3.14</span>, <span class="string">&#x27;A&#x27;</span>); <span class="comment">// 输出: 1hello3.14A</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// C++11/14递归方式</span></span><br><span class="line">    <span class="built_in">printRecursive</span>(<span class="number">1</span>, <span class="string">&quot;hello&quot;</span>, <span class="number">3.14</span>, <span class="string">&#x27;A&#x27;</span>); <span class="comment">// 输出: 1 hello 3.14 A </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="可变参数模板类">可变参数模板类</h5>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归模板类定义</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TupleSize</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 特化：空参数列表</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TupleSize</span>&lt;&gt; &#123;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">size_t</span> value = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 特化：至少一个参数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Head, <span class="keyword">typename</span>... Tail&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TupleSize</span>&lt;Head, Tail...&gt; &#123;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">size_t</span> value = <span class="number">1</span> + TupleSize&lt;Tail...&gt;::value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">variadicTemplateClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">size_t</span> size1 = TupleSize&lt;&gt;::value;        <span class="comment">// 0</span></span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">size_t</span> size2 = TupleSize&lt;<span class="type">int</span>&gt;::value;       <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">size_t</span> size3 = TupleSize&lt;<span class="type">int</span>, <span class="type">double</span>, std::string&gt;::value;  <span class="comment">// 3</span></span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;TupleSize&lt;&gt; = &quot;</span> &lt;&lt; size1 &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;TupleSize&lt;int&gt; = &quot;</span> &lt;&lt; size2 &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;TupleSize&lt;int, double, std::string&gt; = &quot;</span> &lt;&lt; size3 &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="使用可变参数模板实现工厂模式">使用可变参数模板实现工厂模式</h5>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简单工厂类，使用可变参数模板创建对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Factory</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 创建对象并返回共享指针</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function">    <span class="type">static</span> std::shared_ptr&lt;T&gt; <span class="title">create</span><span class="params">(Args&amp;&amp;... args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">make_shared</span>&lt;T&gt;(std::forward&lt;Args&gt;(args)...);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">const</span> std::string&amp; n, <span class="type">int</span> a) : <span class="built_in">name</span>(n), <span class="built_in">age</span>(a) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Person created: &quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; age &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">introduce</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Hi, I&#x27;m &quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; age &lt;&lt; <span class="string">&quot; years old.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">factoryPatternWithVariadicTemplates</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用工厂创建对象</span></span><br><span class="line">    <span class="keyword">auto</span> person1 = Factory::<span class="built_in">create</span>&lt;Person&gt;(<span class="string">&quot;Alice&quot;</span>, <span class="number">30</span>);</span><br><span class="line">    <span class="keyword">auto</span> person2 = Factory::<span class="built_in">create</span>&lt;Person&gt;(<span class="string">&quot;Bob&quot;</span>, <span class="number">25</span>);</span><br><span class="line">    </span><br><span class="line">    person1-&gt;<span class="built_in">introduce</span>();</span><br><span class="line">    person2-&gt;<span class="built_in">introduce</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="完美转发">完美转发</h5>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 完美转发示例，保留参数的值类别（左值或右值）</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">wrapper</span><span class="params">(T&amp;&amp; arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// std::forward保留参数的原始值类别</span></span><br><span class="line">    <span class="built_in">function_that_uses_arg</span>(std::forward&lt;T&gt;(arg));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">function_that_uses_arg</span><span class="params">(<span class="type">int</span>&amp; arg)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Lvalue argument: &quot;</span> &lt;&lt; arg &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">function_that_uses_arg</span><span class="params">(<span class="type">int</span>&amp;&amp; arg)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Rvalue argument: &quot;</span> &lt;&lt; arg &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 完美转发在可变参数模板中的应用</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">perfectForwarder</span><span class="params">(Args&amp;&amp;... args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 完美转发所有参数</span></span><br><span class="line">    <span class="built_in">function_with_multiple_args</span>(std::forward&lt;Args&gt;(args)...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">function_with_multiple_args</span><span class="params">(<span class="type">int</span> a, <span class="type">double</span> b, std::string c)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Args: &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; c &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">perfectForwardingExample</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">42</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 测试完美转发</span></span><br><span class="line">    <span class="built_in">wrapper</span>(x);               <span class="comment">// 传递左值</span></span><br><span class="line">    <span class="built_in">wrapper</span>(<span class="number">100</span>);             <span class="comment">// 传递右值</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 测试可变参数的完美转发</span></span><br><span class="line">    std::string str = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="built_in">perfectForwarder</span>(<span class="number">10</span>, <span class="number">3.14</span>, str);            <span class="comment">// 混合传递</span></span><br><span class="line">    <span class="built_in">perfectForwarder</span>(<span class="number">20</span>, <span class="number">2.71</span>, std::<span class="built_in">string</span>(<span class="string">&quot;world&quot;</span>)); <span class="comment">// 传递右值引用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="SFINAE技术">SFINAE技术</h4>
<p>SFINAE（Substitution Failure Is Not An Error，替换失败不是错误）是模板元编程中的一个重要概念。当模板参数替换导致无效代码时，编译器不会报错，而是简单地从重载解析集中排除该模板，继续寻找其他可行的重载。</p>
<h5 id="基本SFINAE示例">基本SFINAE示例</h5>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SFINAE基本示例</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 仅当T有size()成员函数时此重载有效</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> std::enable_if&lt;std::is_same&lt;<span class="keyword">decltype</span>(std::<span class="built_in">declval</span>&lt;T&gt;().<span class="built_in">size</span>()), <span class="type">size_t</span>&gt;::value,</span><br><span class="line">                       <span class="type">size_t</span>&gt;::<span class="function">type</span></span><br><span class="line"><span class="function"><span class="title">getSize</span><span class="params">(<span class="type">const</span> T&amp; t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 仅当T没有size()成员函数但可以转换为整数时此重载有效</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> std::enable_if&lt;std::is_convertible&lt;T, <span class="type">size_t</span>&gt;::value &amp;&amp;</span><br><span class="line">                       !std::is_same&lt;<span class="keyword">decltype</span>(std::<span class="built_in">declval</span>&lt;T&gt;().<span class="built_in">size</span>()), <span class="type">size_t</span>&gt;::value,</span><br><span class="line">                       <span class="type">size_t</span>&gt;::<span class="function">type</span></span><br><span class="line"><span class="function"><span class="title">getSize</span><span class="params">(<span class="type">const</span> T&amp; t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;<span class="type">size_t</span>&gt;(t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sfinaeBasicExample</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Vector size: &quot;</span> &lt;&lt; <span class="built_in">getSize</span>(vec) &lt;&lt; std::endl; <span class="comment">// 调用第一个重载</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> value = <span class="number">42</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value as size: &quot;</span> &lt;&lt; <span class="built_in">getSize</span>(value) &lt;&lt; std::endl; <span class="comment">// 调用第二个重载</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="使用std-void-t（C-17）">使用std::void_t（C++17）</h5>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用std::void_t简化SFINAE表达式</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查类型是否有特定成员变量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> = <span class="type">void</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> has_member_data : std::false_type &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">has_member_data</span>&lt;T, std::<span class="type">void_t</span>&lt;<span class="keyword">decltype</span>(T::data)&gt;&gt; : std::true_type &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查类型是否有特定成员函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> = <span class="type">void</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> has_member_func : std::false_type &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">has_member_func</span>&lt;T, std::<span class="type">void_t</span>&lt;<span class="keyword">decltype</span>(std::<span class="built_in">declval</span>&lt;T&gt;().<span class="built_in">func</span>())&gt;&gt; : std::true_type &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试类</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">WithMember</span> &#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">WithoutMember</span> &#123;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">other_func</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">voidTSFINAEExample</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; std::boolalpha;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;has_member_data&lt;WithMember&gt;::value: &quot;</span> </span><br><span class="line">              &lt;&lt; has_member_data&lt;WithMember&gt;::value &lt;&lt; std::endl;       <span class="comment">// true</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;has_member_data&lt;WithoutMember&gt;::value: &quot;</span> </span><br><span class="line">              &lt;&lt; has_member_data&lt;WithoutMember&gt;::value &lt;&lt; std::endl;    <span class="comment">// false</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;has_member_func&lt;WithMember&gt;::value: &quot;</span> </span><br><span class="line">              &lt;&lt; has_member_func&lt;WithMember&gt;::value &lt;&lt; std::endl;       <span class="comment">// true</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;has_member_func&lt;WithoutMember&gt;::value: &quot;</span> </span><br><span class="line">              &lt;&lt; has_member_func&lt;WithoutMember&gt;::value &lt;&lt; std::endl;    <span class="comment">// false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="SFINAE在函数重载中的应用">SFINAE在函数重载中的应用</h5>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SFINAE在函数重载中的高级应用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 为算术类型提供特化版本</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">std::<span class="type">enable_if_t</span>&lt;std::is_arithmetic&lt;T&gt;::value, std::string&gt;</span><br><span class="line"><span class="built_in">convertToString</span>(T value) &#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">to_string</span>(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为字符串类型提供特化版本</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">std::<span class="type">enable_if_t</span>&lt;std::is_convertible&lt;T, std::string&gt;::value &amp;&amp; </span><br><span class="line">                !std::is_arithmetic&lt;T&gt;::value, std::string&gt;</span><br><span class="line"><span class="built_in">convertToString</span>(T value) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;std::string&gt;(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为有toString()方法的类型提供特化版本</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">std::<span class="type">enable_if_t</span>&lt;!std::is_arithmetic&lt;T&gt;::value &amp;&amp; </span><br><span class="line">                !std::is_convertible&lt;T, std::string&gt;::value &amp;&amp;</span><br><span class="line">                std::is_same&lt;<span class="keyword">decltype</span>(std::<span class="built_in">declval</span>&lt;T&gt;().<span class="built_in">toString</span>()), std::string&gt;::value,</span><br><span class="line">                std::string&gt;</span><br><span class="line"><span class="built_in">convertToString</span>(<span class="type">const</span> T&amp; value) &#123;</span><br><span class="line">    <span class="keyword">return</span> value.<span class="built_in">toString</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CustomClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">std::string <span class="title">toString</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;CustomClass instance&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sfinaeOverloadingExample</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;int to string: &quot;</span> &lt;&lt; <span class="built_in">convertToString</span>(<span class="number">42</span>) &lt;&lt; std::endl;              <span class="comment">// 算术版本</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;double to string: &quot;</span> &lt;&lt; <span class="built_in">convertToString</span>(<span class="number">3.14</span>) &lt;&lt; std::endl;        <span class="comment">// 算术版本</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;string to string: &quot;</span> &lt;&lt; <span class="built_in">convertToString</span>(std::<span class="built_in">string</span>(<span class="string">&quot;hello&quot;</span>)) &lt;&lt; std::endl; <span class="comment">// 字符串版本</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* cstr = <span class="string">&quot;world&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;const char* to string: &quot;</span> &lt;&lt; <span class="built_in">convertToString</span>(cstr) &lt;&lt; std::endl;  <span class="comment">// 字符串版本</span></span><br><span class="line">    </span><br><span class="line">    CustomClass obj;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;CustomClass to string: &quot;</span> &lt;&lt; <span class="built_in">convertToString</span>(obj) &lt;&lt; std::endl;   <span class="comment">// toString版本</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="检测模板实例化的有效性">检测模板实例化的有效性</h5>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 检测模板实例化是否有效</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">is_constructible_helper</span> &#123;</span><br><span class="line">    <span class="comment">// 测试函数：尝试用Args构造T</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> U, <span class="keyword">typename</span>... Ts&gt;</span></span><br><span class="line"><span class="function">    <span class="type">static</span> <span class="keyword">auto</span> <span class="title">test</span><span class="params">(<span class="type">int</span>)</span> -&gt; <span class="title">decltype</span><span class="params">(U(std::declval&lt;Ts&gt;()...), std::true_type&#123;&#125;)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 失败回退函数</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>, <span class="keyword">typename</span>...&gt;</span></span><br><span class="line"><span class="function">    <span class="type">static</span> std::false_type <span class="title">test</span><span class="params">(...)</span></span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 根据测试结果选择类型</span></span><br><span class="line">    <span class="keyword">using</span> type = <span class="keyword">decltype</span>(<span class="built_in">test</span>&lt;T, Args...&gt;(<span class="number">0</span>));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简化的类型特征</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="keyword">using</span> is_constructible = <span class="keyword">typename</span> is_constructible_helper&lt;T, Args...&gt;::type;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TestClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">TestClass</span>(<span class="type">int</span>, <span class="type">double</span>) &#123;&#125;  <span class="comment">// 只接受int和double参数的构造函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">templateInstantiationCheck</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; std::boolalpha;</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;is_constructible&lt;TestClass, int, double&gt;::value: &quot;</span> </span><br><span class="line">              &lt;&lt; is_constructible&lt;TestClass, <span class="type">int</span>, <span class="type">double</span>&gt;::value &lt;&lt; std::endl;     <span class="comment">// true</span></span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;is_constructible&lt;TestClass, int&gt;::value: &quot;</span> </span><br><span class="line">              &lt;&lt; is_constructible&lt;TestClass, <span class="type">int</span>&gt;::value &lt;&lt; std::endl;            <span class="comment">// false</span></span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;is_constructible&lt;std::string, const char*&gt;::value: &quot;</span> </span><br><span class="line">              &lt;&lt; is_constructible&lt;std::string, <span class="type">const</span> <span class="type">char</span>*&gt;::value &lt;&lt; std::endl;   <span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="模板元编程最佳实践">模板元编程最佳实践</h4>
<ol>
<li>
<p><strong>使用标准库提供的类型特征</strong></p>
<ul>
<li>优先使用<code>&lt;type_traits&gt;</code>中的标准类型特征，而不是自定义</li>
<li>这些类型特征经过优化，更加可靠</li>
</ul>
</li>
<li>
<p><strong>避免过度复杂的元编程</strong></p>
<ul>
<li>模板元编程可能导致编译时间增加</li>
<li>过于复杂的元编程会降低代码可读性和可维护性</li>
<li>仅在需要编译期计算或类型操作时使用</li>
</ul>
</li>
<li>
<p><strong>使用C++17折叠表达式简化参数包处理</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++17折叠表达式比递归更简洁</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printAll</span><span class="params">(Args... args)</span> </span>&#123;</span><br><span class="line">    (std::cout &lt;&lt; ... &lt;&lt; args) &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>使用std::void_t简化SFINAE表达式（C++17）</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> = <span class="type">void</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> has_member : std::false_type &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">has_member</span>&lt;T, std::<span class="type">void_t</span>&lt;<span class="keyword">decltype</span>(T::member)&gt;&gt; : std::true_type &#123;&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>提供编译期错误消息</strong></p>
<ul>
<li>使用<code>static_assert</code>为无效的模板参数组合提供清晰的错误消息</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">processOnlyIntegral</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">static_assert</span>(std::is_integral&lt;T&gt;::value, <span class="string">&quot;T must be an integral type&quot;</span>);</span><br><span class="line">    <span class="comment">// 函数实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>利用可变参数模板进行代码复用</strong></p>
<ul>
<li>在工厂函数、构造包装器等场景中使用可变参数模板</li>
<li>实现通用的参数转发机制</li>
</ul>
</li>
<li>
<p><strong>考虑使用编译期性能分析</strong></p>
<ul>
<li>过于复杂的模板元编程可能显著增加编译时间</li>
<li>可以使用<code>-ftime-trace</code>（GCC/Clang）等选项分析编译性能</li>
</ul>
</li>
<li>
<p><strong>使用概念（C++20）简化SFINAE</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++20概念示例</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">concept</span> Arithmetic = std::is_arithmetic_v&lt;T&gt;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;Arithmetic T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">add</span><span class="params">(T a, T b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>模板元编程是C++中一种强大但复杂的技术。通过在编译期执行计算和类型操作，它可以生成高效的代码，实现高级的抽象和类型安全的接口。然而，过度使用或过于复杂的模板元编程可能导致编译时间增加和代码可读性下降，因此应该谨慎使用，并在必要时提供清晰的注释和文档。</p>
<h3 id="4-6-C-新标准特性">4.6 C++新标准特性</h3>
<p>C++语言不断演进，从C++11开始引入了许多重要的新特性，这些特性大幅提升了语言的表达能力、安全性和开发效率。本节将概述C++11、C++14、C++17和C++20中的主要新特性。</p>
<h4 id="C-11新特性">C++11新特性</h4>
<p>C++11是C++语言的一次重大更新，引入了许多现代编程语言的特性。</p>
<h5 id="自动类型推导（auto和decltype）">自动类型推导（auto和decltype）</h5>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">autoAndDecltype</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// auto自动推导变量类型</span></span><br><span class="line">    <span class="keyword">auto</span> i = <span class="number">42</span>;            <span class="comment">// int类型</span></span><br><span class="line">    <span class="keyword">auto</span> d = <span class="number">3.14</span>;          <span class="comment">// double类型</span></span><br><span class="line">    <span class="keyword">auto</span> s = <span class="string">&quot;hello&quot;</span>;       <span class="comment">// const char*类型</span></span><br><span class="line">    <span class="keyword">auto</span> vec = std::vector&lt;<span class="type">int</span>&gt;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;; <span class="comment">// std::vector&lt;int&gt;类型</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// decltype获取表达式类型</span></span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">decltype</span>(x) y = <span class="number">20</span>;     <span class="comment">// y是int类型</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// decltype与auto结合用于复杂类型</span></span><br><span class="line">    <span class="keyword">decltype</span>(x + d) z = x + d;  <span class="comment">// z是double类型</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 用于函数返回类型（C++14简化了这种语法）</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span></span><br><span class="line"><span class="function">    <span class="keyword">auto</span> <span class="title">add</span><span class="params">(T t, U u)</span> -&gt; <span class="title">decltype</span><span class="params">(t + u)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t + u;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="范围for循环">范围for循环</h5>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">rangeBasedForLoop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 范围for循环遍历容器</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> n : numbers) &#123;</span><br><span class="line">        std::cout &lt;&lt; n &lt;&lt; <span class="string">&quot; &quot;</span>;  <span class="comment">// 输出: 1 2 3 4 5</span></span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用引用修改元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span>&amp; n : numbers) &#123;</span><br><span class="line">        n *= <span class="number">2</span>;  <span class="comment">// 所有元素乘以2</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用const引用避免复制</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; n : numbers) &#123;</span><br><span class="line">        std::cout &lt;&lt; n &lt;&lt; <span class="string">&quot; &quot;</span>;  <span class="comment">// 输出: 2 4 6 8 10</span></span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="Lambda表达式-2">Lambda表达式</h5>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">lambdaExpressions</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 基本lambda表达式</span></span><br><span class="line">    <span class="keyword">auto</span> add = [](<span class="type">int</span> a, <span class="type">int</span> b) &#123; <span class="keyword">return</span> a + b; &#125;;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;5 + 3 = &quot;</span> &lt;&lt; <span class="built_in">add</span>(<span class="number">5</span>, <span class="number">3</span>) &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 带有捕获列表的lambda（捕获外部变量）</span></span><br><span class="line">    <span class="type">int</span> factor = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">auto</span> multiply = [factor](<span class="type">int</span> x) &#123; <span class="keyword">return</span> x * factor; &#125;;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;10 * &quot;</span> &lt;&lt; factor &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; <span class="built_in">multiply</span>(<span class="number">10</span>) &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 按引用捕获</span></span><br><span class="line">    <span class="keyword">auto</span> increment = [&amp;factor]() &#123; factor++; &#125;;</span><br><span class="line">    <span class="built_in">increment</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;After increment: &quot;</span> &lt;&lt; factor &lt;&lt; std::endl;  <span class="comment">// 3</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 捕获所有变量</span></span><br><span class="line">    <span class="keyword">auto</span> complexFunc = [=, &amp;factor](<span class="type">int</span> x) &#123;</span><br><span class="line">        <span class="keyword">return</span> x * factor + <span class="number">10</span>;  <span class="comment">// factor按引用捕获，其他按值捕获</span></span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在STL算法中使用lambda</span></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    std::for_each(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>(), [&amp;sum](<span class="type">int</span> n) &#123; sum += n; &#125;);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Sum: &quot;</span> &lt;&lt; sum &lt;&lt; std::endl;  <span class="comment">// 15</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="智能指针">智能指针</h5>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">smartPointers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// std::unique_ptr（独占所有权）</span></span><br><span class="line">    std::unique_ptr&lt;<span class="type">int</span>&gt; up1 = std::<span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt;(<span class="number">42</span>);</span><br><span class="line">    <span class="comment">// 或在C++11中使用</span></span><br><span class="line">    <span class="function">std::unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">up2</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">100</span>))</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 所有权转移</span></span><br><span class="line">    <span class="keyword">auto</span> up3 = std::<span class="built_in">move</span>(up2);  <span class="comment">// up2现在为空</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// std::shared_ptr（共享所有权）</span></span><br><span class="line">    std::shared_ptr&lt;<span class="type">int</span>&gt; sp1 = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">10</span>);</span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">auto</span> sp2 = sp1;  <span class="comment">// 引用计数增加到2</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Use count: &quot;</span> &lt;&lt; sp<span class="number">1.</span><span class="built_in">use_count</span>() &lt;&lt; std::endl;  <span class="comment">// 2</span></span><br><span class="line">    &#125;  </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Use count: &quot;</span> &lt;&lt; sp<span class="number">1.</span><span class="built_in">use_count</span>() &lt;&lt; std::endl;  <span class="comment">// 1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// std::weak_ptr（不增加引用计数的观察者）</span></span><br><span class="line">    std::weak_ptr&lt;<span class="type">int</span>&gt; wp = sp1;  </span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span> temp = wp.<span class="built_in">lock</span>()) &#123;  <span class="comment">// 检查对象是否仍然存在</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; *temp &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="右值引用和移动语义">右值引用和移动语义</h5>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">moveSemantics</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 右值引用使用&amp;&amp;符号</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">processValue</span><span class="params">(<span class="type">int</span>&amp;&amp; value)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Rvalue processed: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 传递右值</span></span><br><span class="line">    <span class="built_in">processValue</span>(<span class="number">42</span>);  <span class="comment">// 正确，42是右值</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>;  </span><br><span class="line">    <span class="comment">// processValue(x);  // 错误，x是左值</span></span><br><span class="line">    <span class="built_in">processValue</span>(std::<span class="built_in">move</span>(x));  <span class="comment">// 正确，std::move将左值转换为右值引用</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 自定义类的移动构造函数和移动赋值运算符</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">MyString</span> &#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">char</span>* data;</span><br><span class="line">        <span class="type">size_t</span> size;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">// 构造函数</span></span><br><span class="line">        <span class="built_in">MyString</span>(<span class="type">const</span> <span class="type">char</span>* str) &#123;</span><br><span class="line">            size = <span class="built_in">strlen</span>(str);</span><br><span class="line">            data = <span class="keyword">new</span> <span class="type">char</span>[size + <span class="number">1</span>];</span><br><span class="line">            std::<span class="built_in">memcpy</span>(data, str, size + <span class="number">1</span>);</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Constructor&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 析构函数</span></span><br><span class="line">        ~<span class="built_in">MyString</span>() &#123;</span><br><span class="line">            <span class="keyword">delete</span>[] data;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Destructor&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 移动构造函数</span></span><br><span class="line">        <span class="built_in">MyString</span>(MyString&amp;&amp; other) <span class="keyword">noexcept</span> : <span class="built_in">data</span>(other.data), <span class="built_in">size</span>(other.size) &#123;</span><br><span class="line">            other.data = <span class="literal">nullptr</span>;  <span class="comment">// 防止被析构</span></span><br><span class="line">            other.size = <span class="number">0</span>;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Move Constructor&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 移动赋值运算符</span></span><br><span class="line">        MyString&amp; <span class="keyword">operator</span>=(MyString&amp;&amp; other) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;other) &#123;</span><br><span class="line">                <span class="keyword">delete</span>[] data;  <span class="comment">// 释放当前资源</span></span><br><span class="line">                data = other.data;</span><br><span class="line">                size = other.size;</span><br><span class="line">                other.data = <span class="literal">nullptr</span>;</span><br><span class="line">                other.size = <span class="number">0</span>;</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;Move Assignment&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获取字符串</span></span><br><span class="line">        <span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">c_str</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> data; &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用移动语义</span></span><br><span class="line">    <span class="function">MyString <span class="title">s1</span><span class="params">(<span class="string">&quot;Hello&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">MyString <span class="title">s2</span><span class="params">(std::move(s1))</span></span>;  <span class="comment">// 调用移动构造函数</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;s2: &quot;</span> &lt;&lt; s<span class="number">2.</span><span class="built_in">c_str</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="nullptr">nullptr</h5>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">nullptrExample</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用nullptr代替NULL或0</span></span><br><span class="line">    <span class="type">int</span>* p1 = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="type">char</span>* p2 = <span class="literal">nullptr</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// nullptr是强类型的，不同于NULL（可能被解释为整数）</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    <span class="type">void</span> <span class="title">func</span><span class="params">(T* ptr)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Pointer version&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    <span class="type">void</span> <span class="title">func</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Value version&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">func</span>(<span class="literal">NULL</span>);      <span class="comment">// 调用值版本（如果NULL被定义为0）</span></span><br><span class="line">    <span class="built_in">func</span>(<span class="literal">nullptr</span>);   <span class="comment">// 调用指针版本</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="C-14新特性">C++14新特性</h4>
<p>C++14是C++11的增量更新，进一步简化了语言并增强了功能。</p>
<h5 id="泛型Lambda表达式">泛型Lambda表达式</h5>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">genericLambda</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 泛型lambda，参数类型由编译器推导</span></span><br><span class="line">    <span class="keyword">auto</span> add = [](<span class="keyword">auto</span> a, <span class="keyword">auto</span> b) &#123; <span class="keyword">return</span> a + b; &#125;;</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">add</span>(<span class="number">5</span>, <span class="number">3</span>) &lt;&lt; std::endl;       <span class="comment">// 整数相加：8</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">add</span>(<span class="number">3.14</span>, <span class="number">2.71</span>) &lt;&lt; std::endl; <span class="comment">// 浮点数相加：5.85</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">add</span>(std::<span class="built_in">string</span>(<span class="string">&quot;Hello&quot;</span>), <span class="string">&quot; World&quot;</span>) &lt;&lt; std::endl; <span class="comment">// 字符串拼接</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="返回类型推导">返回类型推导</h5>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">returnTypeDeduction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// C++14允许从return语句推导函数返回类型</span></span><br><span class="line">    <span class="function"><span class="keyword">auto</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">42</span>;  <span class="comment">// 返回类型推导为int</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 推导更复杂的类型</span></span><br><span class="line">    <span class="function"><span class="keyword">auto</span> <span class="title">createVector</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">        <span class="keyword">return</span> v;  <span class="comment">// 返回类型推导为std::vector&lt;int&gt;</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在模板函数中使用</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span></span><br><span class="line"><span class="function">    <span class="keyword">auto</span> <span class="title">multiply</span><span class="params">(T t, U u)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t * u;  <span class="comment">// 返回类型是T和U的乘积类型</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="二进制字面量和数字分隔符">二进制字面量和数字分隔符</h5>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">binaryLiterals</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 二进制字面量（C++14引入）</span></span><br><span class="line">    <span class="type">int</span> binary = <span class="number">0b101010</span>;  <span class="comment">// 等于十进制的42</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Binary 0b101010 = &quot;</span> &lt;&lt; binary &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 数字分隔符（单引号），提高可读性</span></span><br><span class="line">    <span class="type">long</span> largeNumber = <span class="number">1&#x27;000&#x27;000&#x27;000</span>;  <span class="comment">// 10亿</span></span><br><span class="line">    <span class="type">double</span> pi = <span class="number">3.141&#x27;592&#x27;653&#x27;59</span>;</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Large number: &quot;</span> &lt;&lt; largeNumber &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Pi: &quot;</span> &lt;&lt; pi &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="std-make-unique">std::make_unique</h5>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">makeUnique</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// C++14引入的std::make_unique函数</span></span><br><span class="line">    <span class="keyword">auto</span> up1 = std::<span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt;(<span class="number">42</span>);</span><br><span class="line">    <span class="keyword">auto</span> up2 = std::make_unique&lt;std::vector&lt;<span class="type">int</span>&gt;&gt;(<span class="number">10</span>, <span class="number">0</span>);  <span class="comment">// 创建包含10个0的vector</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 更安全和高效，避免了显式的new调用</span></span><br><span class="line">    <span class="comment">// C++11中需要使用:</span></span><br><span class="line">    <span class="comment">// auto up3 = std::unique_ptr&lt;int&gt;(new int(100));</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="C-17新特性">C++17新特性</h4>
<p>C++17引入了许多实用的功能，进一步提高了开发效率。</p>
<h5 id="结构化绑定">结构化绑定</h5>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">structuredBindings</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 分解pair</span></span><br><span class="line">    <span class="function">std::pair&lt;<span class="type">int</span>, std::string&gt; <span class="title">p</span><span class="params">(<span class="number">42</span>, <span class="string">&quot;hello&quot;</span>)</span></span>;</span><br><span class="line">    <span class="keyword">auto</span> [value, text] = p;  <span class="comment">// 结构化绑定</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; value &lt;&lt; <span class="string">&quot;, Text: &quot;</span> &lt;&lt; text &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 分解tuple</span></span><br><span class="line">    <span class="function">std::tuple&lt;<span class="type">int</span>, <span class="type">double</span>, std::string&gt; <span class="title">t</span><span class="params">(<span class="number">1</span>, <span class="number">3.14</span>, <span class="string">&quot;world&quot;</span>)</span></span>;</span><br><span class="line">    <span class="keyword">auto</span> [i, d, s] = t;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;i: &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;, d: &quot;</span> &lt;&lt; d &lt;&lt; <span class="string">&quot;, s: &quot;</span> &lt;&lt; s &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 分解自定义类型（需要提供get&lt;&gt;函数和tuple_size）</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="type">int</span> y;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    Point pt&#123;<span class="number">10</span>, <span class="number">20</span>&#125;;</span><br><span class="line">    <span class="keyword">auto</span> [x, y] = pt;  <span class="comment">// C++17支持直接分解聚合类型</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;x: &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;, y: &quot;</span> &lt;&lt; y &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在循环中使用</span></span><br><span class="line">    std::map&lt;<span class="type">int</span>, std::string&gt; numbers = &#123;&#123;<span class="number">1</span>, <span class="string">&quot;one&quot;</span>&#125;, &#123;<span class="number">2</span>, <span class="string">&quot;two&quot;</span>&#125;, &#123;<span class="number">3</span>, <span class="string">&quot;three&quot;</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; [key, value] : numbers) &#123;</span><br><span class="line">        std::cout &lt;&lt; key &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="if-switch初始化语句">if/switch初始化语句</h5>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">initStatementsInConditionals</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// if语句中的初始化</span></span><br><span class="line">    <span class="keyword">if</span> (std::vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;; v.<span class="built_in">size</span>() &gt; <span class="number">3</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Vector has more than 3 elements&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;  <span class="comment">// v的作用域仅限于if语句</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// switch语句中的初始化</span></span><br><span class="line">    <span class="keyword">switch</span> (<span class="type">int</span> n = <span class="built_in">rand</span>(); n % <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Divisible by 3&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Remainder 1&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Remainder 2&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="折叠表达式">折叠表达式</h5>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">foldExpressions</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 一元左折叠：( ... op pack )</span></span><br><span class="line">    <span class="keyword">auto</span> sum = [](<span class="keyword">auto</span>&amp;&amp;... args) &#123;</span><br><span class="line">        <span class="built_in">return</span> (... + args);  <span class="comment">// 展开为 ((arg1 + arg2) + arg3) + ...</span></span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Sum: &quot;</span> &lt;&lt; <span class="built_in">sum</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>) &lt;&lt; std::endl;  <span class="comment">// 15</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 一元右折叠：( pack op ... )</span></span><br><span class="line">    <span class="keyword">auto</span> subtract = [](<span class="keyword">auto</span>&amp;&amp;... args) &#123;</span><br><span class="line">        <span class="built_in">return</span> (args - ...);  <span class="comment">// 展开为 arg1 - (arg2 - (arg3 - ... ))</span></span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Subtract: &quot;</span> &lt;&lt; <span class="built_in">subtract</span>(<span class="number">10</span>, <span class="number">5</span>, <span class="number">2</span>) &lt;&lt; std::endl;  <span class="comment">// 7 (10 - (5 - 2))</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 二元折叠</span></span><br><span class="line">    <span class="keyword">auto</span> printAll = [](<span class="keyword">auto</span>&amp;&amp;... args) &#123;</span><br><span class="line">        (std::cout &lt;&lt; ... &lt;&lt; args) &lt;&lt; std::endl;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printAll</span>(<span class="number">1</span>, <span class="string">&quot; &quot;</span>, <span class="number">3.14</span>, <span class="string">&quot; &quot;</span>, <span class="string">&quot;hello&quot;</span>);  <span class="comment">// 1 3.14 hello</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用逗号运算符的折叠表达式</span></span><br><span class="line">    <span class="keyword">auto</span> process = [](<span class="keyword">auto</span>&amp;&amp;... args) &#123;</span><br><span class="line">        (<span class="built_in">processOne</span>(args), ...);  <span class="comment">// 对每个参数调用processOne</span></span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 带有初始值的二元折叠</span></span><br><span class="line">    <span class="keyword">auto</span> addToVector = [](std::vector&lt;<span class="type">int</span>&gt;&amp; vec, <span class="keyword">auto</span>&amp;&amp;... args) &#123;</span><br><span class="line">        (vec.<span class="built_in">push_back</span>(args), ...);  <span class="comment">// 将所有参数添加到vector</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="std-optional">std::optional</h5>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">optionalExample</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// std::optional表示可能存在或不存在的值</span></span><br><span class="line">    std::optional&lt;<span class="type">int</span>&gt; maybeValue;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 检查是否有值</span></span><br><span class="line">    <span class="keyword">if</span> (!maybeValue.<span class="built_in">has_value</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;No value&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置值</span></span><br><span class="line">    maybeValue = <span class="number">42</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 访问值的几种方式</span></span><br><span class="line">    <span class="keyword">if</span> (maybeValue) &#123;  <span class="comment">// 布尔上下文</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; *maybeValue &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; maybeValue.<span class="built_in">value</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取值，如果不存在则返回默认值</span></span><br><span class="line">    <span class="type">int</span> value = maybeValue.<span class="built_in">value_or</span>(<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 函数返回std::optional</span></span><br><span class="line">    <span class="function">std::optional&lt;<span class="type">int</span>&gt; <span class="title">findInVector</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt;&amp; vec, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> it = std::<span class="built_in">find</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), target);</span><br><span class="line">        <span class="keyword">if</span> (it != vec.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> *it;  <span class="comment">// 返回找到的值</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="literal">nullopt</span>;  <span class="comment">// 返回空</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="std-variant">std::variant</h5>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">variantExample</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// std::variant可以保存几种不同类型的值中的一种</span></span><br><span class="line">    std::variant&lt;<span class="type">int</span>, <span class="type">double</span>, std::string&gt; var;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 默认构造为第一个类型（int），值为0</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Default value: &quot;</span> &lt;&lt; std::<span class="built_in">get</span>&lt;<span class="type">int</span>&gt;(var) &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 赋值</span></span><br><span class="line">    var = <span class="number">3.14</span>;  <span class="comment">// 现在保存double类型</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 访问值（需要知道当前类型）</span></span><br><span class="line">    <span class="keyword">if</span> (std::<span class="built_in">holds_alternative</span>&lt;<span class="type">double</span>&gt;(var)) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Double value: &quot;</span> &lt;&lt; std::<span class="built_in">get</span>&lt;<span class="type">double</span>&gt;(var) &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    var = <span class="string">&quot;hello&quot;</span>;  <span class="comment">// 现在保存string类型</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用std::visit访问variant（更安全的方式）</span></span><br><span class="line">    std::<span class="built_in">visit</span>([](<span class="keyword">auto</span>&amp;&amp; arg) &#123;</span><br><span class="line">        <span class="keyword">using</span> T = std::<span class="type">decay_t</span>&lt;<span class="keyword">decltype</span>(arg)&gt;;</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">constexpr</span> (std::is_same_v&lt;T, <span class="type">int</span>&gt;) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Int: &quot;</span> &lt;&lt; arg &lt;&lt; std::endl;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">constexpr</span> (std::is_same_v&lt;T, <span class="type">double</span>&gt;) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Double: &quot;</span> &lt;&lt; arg &lt;&lt; std::endl;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">constexpr</span> (std::is_same_v&lt;T, std::string&gt;) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;String: &quot;</span> &lt;&lt; arg &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, var);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="std-any">std::any</h5>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">anyExample</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// std::any可以保存任何类型的值</span></span><br><span class="line">    std::any value;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置值</span></span><br><span class="line">    value = <span class="number">42</span>;  <span class="comment">// 现在保存int</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 检查类型并访问</span></span><br><span class="line">    <span class="keyword">if</span> (value.<span class="built_in">type</span>() == <span class="built_in">typeid</span>(<span class="type">int</span>)) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Int value: &quot;</span> &lt;&lt; std::<span class="built_in">any_cast</span>&lt;<span class="type">int</span>&gt;(value) &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 修改保存的值</span></span><br><span class="line">    value = std::<span class="built_in">string</span>(<span class="string">&quot;hello&quot;</span>);  <span class="comment">// 现在保存string</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 错误的类型转换会抛出异常</span></span><br><span class="line">        <span class="type">int</span> wrong = std::<span class="built_in">any_cast</span>&lt;<span class="type">int</span>&gt;(value);</span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::bad_any_cast&amp; e) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Exception: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用指针版本，失败时返回nullptr而不是抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span> strPtr = std::<span class="built_in">any_cast</span>&lt;std::string&gt;(&amp;value)) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;String value: &quot;</span> &lt;&lt; *strPtr &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="C-20新特性">C++20新特性</h4>
<p>C++20是C++的另一次重大更新，引入了许多高级特性。</p>
<h5 id="概念（Concepts）">概念（Concepts）</h5>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">conceptsExample</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义概念</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="keyword">concept</span> Arithmetic = std::is_arithmetic_v&lt;T&gt;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用概念约束模板参数</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;Arithmetic T&gt;</span></span><br><span class="line"><span class="function">    T <span class="title">add</span><span class="params">(T a, T b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 可以编译</span></span><br><span class="line">    <span class="built_in">add</span>(<span class="number">5</span>, <span class="number">3</span>);      <span class="comment">// int是算术类型</span></span><br><span class="line">    <span class="built_in">add</span>(<span class="number">3.14</span>, <span class="number">2.71</span>);  <span class="comment">// double是算术类型</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 编译错误</span></span><br><span class="line">    <span class="comment">// add(std::string(&quot;hello&quot;), std::string(&quot;world&quot;));  // string不是算术类型</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用requires表达式定义更复杂的概念</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="keyword">concept</span> Iterable = <span class="built_in">requires</span>(T t) &#123;</span><br><span class="line">        &#123; t.<span class="built_in">begin</span>() &#125; -&gt; std::input_iterator;</span><br><span class="line">        &#123; t.<span class="built_in">end</span>() &#125; -&gt; std::input_iterator;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;Iterable T&gt;</span></span><br><span class="line"><span class="function">    <span class="type">void</span> <span class="title">iterate</span><span class="params">(T&amp; container)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp;&amp; item : container) &#123;</span><br><span class="line">            <span class="comment">// 处理每个元素</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 复合概念</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="keyword">concept</span> Sortable = Iterable&lt;T&gt; &amp;&amp; <span class="built_in">requires</span>(T t) &#123;</span><br><span class="line">        &#123; std::<span class="built_in">sort</span>(t.<span class="built_in">begin</span>(), t.<span class="built_in">end</span>()) &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="范围库（Ranges）">范围库（Ranges）</h5>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">rangesExample</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用视图（views）进行惰性求值</span></span><br><span class="line">    <span class="keyword">auto</span> evenNumbers = numbers | std::views::<span class="built_in">filter</span>([](<span class="type">int</span> n) &#123; <span class="keyword">return</span> n % <span class="number">2</span> == <span class="number">0</span>; &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 转换和过滤可以链式调用</span></span><br><span class="line">    <span class="keyword">auto</span> result = numbers</span><br><span class="line">        | std::views::<span class="built_in">filter</span>([](<span class="type">int</span> n) &#123; <span class="keyword">return</span> n % <span class="number">2</span> == <span class="number">1</span>; &#125;)  <span class="comment">// 只保留奇数</span></span><br><span class="line">        | std::views::<span class="built_in">transform</span>([](<span class="type">int</span> n) &#123; <span class="keyword">return</span> n * <span class="number">2</span>; &#125;)    <span class="comment">// 乘以2</span></span><br><span class="line">        | std::views::<span class="built_in">take</span>(<span class="number">3</span>);  <span class="comment">// 只取前3个</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 视图是惰性的，直到被使用才会计算</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> n : result) &#123;</span><br><span class="line">        std::cout &lt;&lt; n &lt;&lt; <span class="string">&quot; &quot;</span>;  <span class="comment">// 输出: 2 6 10</span></span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 范围适配器组合</span></span><br><span class="line">    <span class="keyword">auto</span> allResults = numbers</span><br><span class="line">        | std::views::<span class="built_in">drop</span>(<span class="number">2</span>)        <span class="comment">// 跳过前2个元素</span></span><br><span class="line">        | std::views::reverse        <span class="comment">// 反转</span></span><br><span class="line">        | std::views::<span class="built_in">filter</span>([](<span class="type">int</span> n) &#123; <span class="keyword">return</span> n &gt; <span class="number">5</span>; &#125;);  <span class="comment">// 只保留大于5的元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="协程（Coroutines）">协程（Coroutines）</h5>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">coroutinesExample</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// C++20协程示例（简化版）</span></span><br><span class="line">    <span class="comment">// 注意：实际使用需要包含&lt;coroutine&gt;头文件和实现协程特性的支持库</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 生成器示例</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Generator</span> &#123;</span><br><span class="line">        <span class="comment">// 协程句柄类型</span></span><br><span class="line">        <span class="keyword">using</span> promise_type = GeneratorPromise&lt;T&gt;;</span><br><span class="line">        <span class="keyword">using</span> handle_type = std::coroutine_handle&lt;promise_type&gt;;</span><br><span class="line">        </span><br><span class="line">        handle_type handle;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 构造函数和析构函数</span></span><br><span class="line">        <span class="built_in">Generator</span>(handle_type h) : <span class="built_in">handle</span>(h) &#123;&#125;  </span><br><span class="line">        ~<span class="built_in">Generator</span>() &#123; <span class="keyword">if</span> (handle) handle.<span class="built_in">destroy</span>(); &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 移动构造和移动赋值</span></span><br><span class="line">        <span class="built_in">Generator</span>(Generator&amp;&amp; other) <span class="keyword">noexcept</span> : <span class="built_in">handle</span>(other.handle) &#123; other.handle = <span class="literal">nullptr</span>; &#125;</span><br><span class="line">        Generator&amp; <span class="keyword">operator</span>=(Generator&amp;&amp; other) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;other) &#123; </span><br><span class="line">                <span class="keyword">if</span> (handle) handle.<span class="built_in">destroy</span>();</span><br><span class="line">                handle = other.handle;</span><br><span class="line">                other.handle = <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 禁止拷贝</span></span><br><span class="line">        <span class="built_in">Generator</span>(<span class="type">const</span> Generator&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">        Generator&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Generator&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 迭代器接口</span></span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">iterator</span> &#123;</span><br><span class="line">            handle_type handle;</span><br><span class="line">            </span><br><span class="line">            <span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> iterator&amp;) <span class="type">const</span> &#123; <span class="keyword">return</span> !handle.<span class="built_in">done</span>(); &#125;</span><br><span class="line">            <span class="type">void</span> <span class="keyword">operator</span>++() &#123; handle.<span class="built_in">resume</span>(); &#125;</span><br><span class="line">            T <span class="keyword">operator</span>*() &#123; <span class="keyword">return</span> handle.<span class="built_in">promise</span>().value; &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>&#123; </span><br><span class="line">            <span class="keyword">if</span> (handle) handle.<span class="built_in">resume</span>();</span><br><span class="line">            <span class="keyword">return</span> &#123;handle&#125;; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> &#123;<span class="literal">nullptr</span>&#125;; &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">GeneratorPromise</span> &#123;</span><br><span class="line">        T value;</span><br><span class="line">        </span><br><span class="line">        <span class="function">Generator&lt;T&gt; <span class="title">get_return_object</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> &#123;std::coroutine_handle&lt;GeneratorPromise&gt;::<span class="built_in">from_promise</span>(*<span class="keyword">this</span>)&#125;; &#125;</span><br><span class="line">        <span class="function">std::suspend_always <span class="title">initial_suspend</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> &#123;&#125;; &#125;</span><br><span class="line">        <span class="function">std::suspend_always <span class="title">yield_value</span><span class="params">(T val)</span> </span>&#123; </span><br><span class="line">            value = val;</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">return_void</span><span class="params">()</span> </span>&#123;&#125;  </span><br><span class="line">        <span class="function">std::suspend_never <span class="title">final_suspend</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> &#123;&#125;; &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">unhandled_exception</span><span class="params">()</span> </span>&#123; std::<span class="built_in">terminate</span>(); &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用生成器</span></span><br><span class="line">    <span class="function">Generator&lt;<span class="type">int</span>&gt; <span class="title">fibonacci</span><span class="params">(<span class="type">int</span> count)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> a = <span class="number">0</span>, b = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; count; ++i) &#123;</span><br><span class="line">            <span class="keyword">co_yield</span> a;  <span class="comment">// 生成当前值并挂起</span></span><br><span class="line">            <span class="type">int</span> temp = a;</span><br><span class="line">            a = b;</span><br><span class="line">            b = temp + b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用生成器</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> n : <span class="built_in">fibonacci</span>(<span class="number">10</span>)) &#123;</span><br><span class="line">        std::cout &lt;&lt; n &lt;&lt; <span class="string">&quot; &quot;</span>;  <span class="comment">// 输出: 0 1 1 2 3 5 8 13 21 34</span></span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="模块（Modules）">模块（Modules）</h5>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模块示例（简化语法）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// math.cppm - 模块接口文件</span></span><br><span class="line"><span class="keyword">module</span>;</span><br><span class="line"><span class="comment">// 全局模块片段（可选）</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">module</span> Math;</span><br><span class="line"><span class="comment">// 导出声明</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">export</span> <span class="type">double</span> <span class="title">square</span><span class="params">(<span class="type">double</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">export</span> <span class="type">double</span> <span class="title">cube</span><span class="params">(<span class="type">double</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * x * x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">namespace</span> geometry &#123;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">circleArea</span><span class="params">(<span class="type">double</span> radius)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> M_PI * radius * radius;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主程序文件</span></span><br><span class="line"><span class="keyword">import</span> Math;</span><br><span class="line"><span class="keyword">import</span> std.core;  <span class="comment">// 导入标准库模块</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">double</span> x = <span class="number">2.0</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Square of &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; is &quot;</span> &lt;&lt; <span class="built_in">square</span>(x) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Cube of &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; is &quot;</span> &lt;&lt; <span class="built_in">cube</span>(x) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Area of circle with radius &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; is &quot;</span> &lt;&lt; geometry::<span class="built_in">circleArea</span>(x) &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="三路比较运算符（Spaceship-Operator）">三路比较运算符（Spaceship Operator）</h5>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">spaceshipOperator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// &lt;=&gt; 三路比较运算符返回三种可能的结果：小于、等于或大于</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 对于基本类型</span></span><br><span class="line">    <span class="type">int</span> a = <span class="number">5</span>, b = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">auto</span> result = a &lt;=&gt; b;  <span class="comment">// 返回std::strong_ordering::less</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (result &lt; <span class="number">0</span>) std::cout &lt;&lt; <span class="string">&quot;a &lt; b&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (result &gt; <span class="number">0</span>) std::cout &lt;&lt; <span class="string">&quot;a &gt; b&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">else</span> std::cout &lt;&lt; <span class="string">&quot;a == b&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 为自定义类型定义三路比较运算符</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">        <span class="type">int</span> x, y;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 合成的三路比较运算符（C++20）</span></span><br><span class="line">        <span class="keyword">auto</span> <span class="built_in">operator</span>&lt;=&gt;(<span class="type">const</span> Point&amp;) <span class="type">const</span> = <span class="keyword">default</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* 等价于手动实现：</span></span><br><span class="line"><span class="comment">        std::strong_ordering operator&lt;=&gt;(const Point&amp; other) const &#123;</span></span><br><span class="line"><span class="comment">            if (auto cmp = x &lt;=&gt; other.x; cmp != 0) return cmp;</span></span><br><span class="line"><span class="comment">            return y &lt;=&gt; other.y;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    Point p1&#123;<span class="number">1</span>, <span class="number">2</span>&#125;, p2&#123;<span class="number">1</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span> (p1 &lt; p2) std::cout &lt;&lt; <span class="string">&quot;p1 &lt; p2&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 定义了&lt;=&gt;后，编译器会自动生成所有比较运算符</span></span><br><span class="line">    <span class="comment">// 包括&lt;, &lt;=, &gt;, &gt;=, ==, !=</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="约束与概念的结合">约束与概念的结合</h5>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">constrainedTemplates</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用requires子句约束模板</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    <span class="type">void</span> <span class="title">sortIfPossible</span><span class="params">(T&amp; container)</span> <span class="keyword">requires</span> Iterable&lt;T&gt; </span>&#123;</span><br><span class="line">        <span class="comment">// 只有当T满足Iterable概念时才能编译</span></span><br><span class="line">        std::<span class="built_in">sort</span>(container.<span class="built_in">begin</span>(), container.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 结合auto和概念进行参数推导</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">processArithmetic</span><span class="params">(<span class="keyword">auto</span> value)</span> <span class="keyword">requires</span> Arithmetic&lt;<span class="title">decltype</span><span class="params">(value)</span>&gt; </span>&#123;</span><br><span class="line">        <span class="comment">// 处理算术类型</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用简写形式</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;Arithmetic T&gt;</span></span><br><span class="line"><span class="function">    <span class="type">void</span> <span class="title">process</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 与上面等价</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 多概念约束</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="keyword">concept</span> Printable = <span class="built_in">requires</span>(T t) &#123;</span><br><span class="line">        &#123; std::cout &lt;&lt; t &#125; -&gt; std::convertible_to&lt;std::ostream&amp;&gt;;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">requires</span> Arithmetic&lt;T&gt; &amp;&amp; Printable&lt;T&gt;</span></span><br><span class="line"><span class="function">    <span class="type">void</span> <span class="title">printAndCompute</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">        <span class="comment">// 进行算术运算</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="选择合适的C-标准版本">选择合适的C++标准版本</h4>
<p>选择使用哪个C++标准版本时，需要考虑以下因素：</p>
<ol>
<li><strong>编译器支持</strong>：确保目标平台的编译器支持你选择的标准版本</li>
<li><strong>库支持</strong>：检查第三方库是否支持该标准版本</li>
<li><strong>项目需求</strong>：评估是否真的需要新版本的特性</li>
<li><strong>编译时间</strong>：较新的标准可能会增加编译时间</li>
<li><strong>团队熟悉度</strong>：团队成员是否熟悉新特性</li>
</ol>
<h4 id="逐步采用新特性的策略">逐步采用新特性的策略</h4>
<ol>
<li><strong>从小处开始</strong>：先在非关键代码中尝试新特性</li>
<li><strong>团队培训</strong>：确保团队成员了解新特性的用法和最佳实践</li>
<li><strong>代码审查</strong>：特别关注新特性的使用是否恰当</li>
<li><strong>增量迁移</strong>：逐步将现有代码迁移到新的标准</li>
<li><strong>性能测试</strong>：某些新特性可能对性能有影响，需要进行测试</li>
</ol>
<p>C++标准的不断演进为开发人员提供了更强大、更安全、更高效的工具。了解这些新特性并恰当地应用它们，可以显著提高代码质量和开发效率。随着C++23和未来版本的推出，C++语言将继续发展，为现代软件开发提供更好的支持。</p>
<ul>
<li>C++11新特性</li>
<li>C++14新特性</li>
<li>C++17新特性</li>
<li>C++20新特性</li>
</ul>
<h2 id="5-编程实践与常见问题">5. 编程实践与常见问题</h2>
<p>编写高质量的C++代码不仅仅是掌握语法和特性，还需要遵循良好的编程实践，掌握调试技巧和性能优化方法。本章将介绍C++编程中的一些重要实践和常见问题解决方案。</p>
<h3 id="5-1-编码规范">5.1 编码规范</h3>
<p>编码规范是团队协作开发的基础，良好的编码规范可以提高代码的可读性、可维护性和可靠性。</p>
<h4 id="命名约定">命名约定</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类/结构体/枚举命名 - PascalCase</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DataProcessor</span> &#123;</span><br><span class="line">    <span class="comment">// 类成员变量 - 通常以m_开头或以下划线结尾</span></span><br><span class="line">    std::string m_dataPath;</span><br><span class="line">    <span class="type">int</span> m_bufferSize;  <span class="comment">// 或者使用mBufferSize</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 成员函数 - PascalCase</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ProcessData</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">IsReady</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结构体</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point3D</span> &#123;</span><br><span class="line">    <span class="type">double</span> x, y, z;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 枚举 - PascalCase</span></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">Color</span> &#123;</span><br><span class="line">    Red,</span><br><span class="line">    Green,</span><br><span class="line">    Blue</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数参数和局部变量 - camelCase</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">calculateDistance</span><span class="params">(<span class="type">const</span> Point3D&amp; startPoint, <span class="type">const</span> Point3D&amp; endPoint)</span> </span>&#123;</span><br><span class="line">    <span class="type">double</span> distanceSquared = <span class="number">0.0</span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 常量 - 全大写，下划线分隔</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX_BUFFER_SIZE = <span class="number">1024</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI = <span class="number">3.14159265359</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模板参数 - 单个大写字母或描述性名称</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Allocator&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyContainer</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="代码格式">代码格式</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 缩进 - 通常使用4个空格或1个Tab</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">wellFormattedFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (condition) &#123;</span><br><span class="line">        <span class="comment">// 代码块内缩进</span></span><br><span class="line">        <span class="built_in">performAction</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (subCondition) &#123;</span><br><span class="line">            <span class="comment">// 嵌套缩进</span></span><br><span class="line">            <span class="built_in">handleSubCondition</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// else与if在同一行或换行</span></span><br><span class="line">        <span class="built_in">handleElseCase</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 函数链式调用的格式</span></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; result = <span class="built_in">getData</span>()</span><br><span class="line">        .<span class="built_in">filter</span>([](<span class="type">int</span> n) &#123; <span class="keyword">return</span> n % <span class="number">2</span> == <span class="number">0</span>; &#125;)</span><br><span class="line">        .<span class="built_in">map</span>([](<span class="type">int</span> n) &#123; <span class="keyword">return</span> n * <span class="number">2</span>; &#125;)</span><br><span class="line">        .<span class="built_in">collect</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 长行拆分</span></span><br><span class="line">    <span class="keyword">auto</span> complexResult = <span class="built_in">calculateSomething</span>(param1, param2, param3, </span><br><span class="line">                                           param4, param5);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="注释规范">注释规范</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 行注释 - 用于简单说明</span></span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>;  <span class="comment">// 当前计数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 块注释 - 用于函数、类等的详细说明</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 计算两个点之间的欧几里得距离</span></span><br><span class="line"><span class="comment"> * @param p1 第一个点</span></span><br><span class="line"><span class="comment"> * @param p2 第二个点</span></span><br><span class="line"><span class="comment"> * @return 两点之间的距离</span></span><br><span class="line"><span class="comment"> * @throw std::invalid_argument 如果输入参数无效</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">calculateDistance</span><span class="params">(<span class="type">const</span> Point3D&amp; p1, <span class="type">const</span> Point3D&amp; p2)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 参数校验</span></span><br><span class="line">    <span class="comment">// 计算逻辑</span></span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">sqrt</span>(std::<span class="built_in">pow</span>(p<span class="number">2.</span>x - p<span class="number">1.</span>x, <span class="number">2</span>) + </span><br><span class="line">                     std::<span class="built_in">pow</span>(p<span class="number">2.</span>y - p<span class="number">1.</span>y, <span class="number">2</span>) + </span><br><span class="line">                     std::<span class="built_in">pow</span>(p<span class="number">2.</span>z - p<span class="number">1.</span>z, <span class="number">2</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 文件头部注释</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @file data_processor.cpp</span></span><br><span class="line"><span class="comment"> * @brief 数据处理模块的实现文件</span></span><br><span class="line"><span class="comment"> * @author 作者名</span></span><br><span class="line"><span class="comment"> * @date 2023-04-15</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 类注释</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @class DatabaseConnector</span></span><br><span class="line"><span class="comment"> * @brief 数据库连接管理类</span></span><br><span class="line"><span class="comment"> * 负责处理与数据库的连接、查询执行和结果处理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DatabaseConnector</span> &#123;</span><br><span class="line">    <span class="comment">// 类定义</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="最佳实践">最佳实践</h4>
<ol>
<li><strong>作用域最小化</strong></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不好的做法</span></span><br><span class="line">std::string result;</span><br><span class="line"><span class="comment">// 大量代码...</span></span><br><span class="line">result = <span class="built_in">calculateResult</span>();  <span class="comment">// 变量过早定义</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 好的做法</span></span><br><span class="line"><span class="comment">// 大量代码...</span></span><br><span class="line">std::string result = <span class="built_in">calculateResult</span>();  <span class="comment">// 尽可能靠近使用的地方定义</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 尤其注意循环变量</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;  <span class="comment">// i的作用域仅限于循环</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li><strong>避免魔数</strong></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不好的做法</span></span><br><span class="line"><span class="keyword">if</span> (statusCode == <span class="number">404</span>) &#123;  <span class="comment">// 404是什么？</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 好的做法</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> HTTP_NOT_FOUND = <span class="number">404</span>;</span><br><span class="line"><span class="keyword">if</span> (statusCode == HTTP_NOT_FOUND) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li><strong>使用初始化列表</strong></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string name;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; data;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 使用初始化列表</span></span><br><span class="line">    <span class="built_in">MyClass</span>(std::string n, <span class="type">int</span> i, std::vector&lt;<span class="type">int</span>&gt; d)</span><br><span class="line">        : <span class="built_in">name</span>(std::<span class="built_in">move</span>(n)), <span class="built_in">id</span>(i), <span class="built_in">data</span>(std::<span class="built_in">move</span>(d)) &#123;</span><br><span class="line">        <span class="comment">// 构造函数体内的逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li><strong>避免使用C风格转换</strong></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不好的做法</span></span><br><span class="line"><span class="type">void</span>* ptr = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">42</span>);</span><br><span class="line"><span class="type">int</span>* intPtr = (<span class="type">int</span>*)ptr;  <span class="comment">// C风格转换</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 好的做法</span></span><br><span class="line"><span class="type">int</span>* intPtr2 = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>*&gt;(ptr);  <span class="comment">// 明确的转换类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 更安全的做法（如果可能）</span></span><br><span class="line">std::unique_ptr&lt;<span class="type">int</span>&gt; safePtr = std::<span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt;(<span class="number">42</span>);</span><br></pre></td></tr></table></figure>
<ol start="5">
<li><strong>使用RAII管理资源</strong></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不好的做法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">riskyFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span>* data = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">if</span> (someCondition) &#123;</span><br><span class="line">        <span class="keyword">return</span>;  <span class="comment">// 内存泄漏！</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span>[] data;  <span class="comment">// 可能永远不会执行</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 好的做法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">safeFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">data</span><span class="params">(<span class="number">100</span>)</span></span>;  <span class="comment">// RAII容器自动管理内存</span></span><br><span class="line">    <span class="keyword">if</span> (someCondition) &#123;</span><br><span class="line">        <span class="keyword">return</span>;  <span class="comment">// 没问题，会自动释放</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-2-调试技巧">5.2 调试技巧</h3>
<p>有效的调试是解决问题的关键。掌握各种调试技巧可以大大提高开发效率。</p>
<h4 id="调试器使用">调试器使用</h4>
<p><strong>使用GDB调试器</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 编译时添加调试信息</span></span><br><span class="line">g++ -g program.cpp -o program</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动调试器</span></span><br><span class="line">gdb program</span><br><span class="line"></span><br><span class="line"><span class="comment"># GDB常用命令</span></span><br><span class="line">(gdb) <span class="built_in">break</span> main      <span class="comment"># 在main函数设置断点</span></span><br><span class="line">(gdb) <span class="built_in">break</span> filename.cpp:line_number  <span class="comment"># 在特定文件的特定行设置断点</span></span><br><span class="line">(gdb) run             <span class="comment"># 运行程序</span></span><br><span class="line">(gdb) next            <span class="comment"># 单步执行，不进入函数</span></span><br><span class="line">(gdb) step            <span class="comment"># 单步执行，进入函数</span></span><br><span class="line">(gdb) <span class="built_in">print</span> variable  <span class="comment"># 打印变量值</span></span><br><span class="line">(gdb) backtrace       <span class="comment"># 显示调用栈</span></span><br><span class="line">(gdb) <span class="built_in">continue</span>        <span class="comment"># 继续执行程序</span></span><br><span class="line">(gdb) quit            <span class="comment"># 退出调试器</span></span><br></pre></td></tr></table></figure>
<p><strong>使用Visual Studio调试器</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置断点 - 点击行号旁边或按F9</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> result = <span class="built_in">calculate</span>();  <span class="comment">// 设置断点</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调试快捷键</span></span><br><span class="line"><span class="comment">// F5 - 开始调试</span></span><br><span class="line"><span class="comment">// F10 - 单步跳过</span></span><br><span class="line"><span class="comment">// F11 - 单步进入</span></span><br><span class="line"><span class="comment">// Shift+F11 - 单步跳出</span></span><br><span class="line"><span class="comment">// Ctrl+Shift+B - 编译</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看变量</span></span><br><span class="line"><span class="comment">// 鼠标悬停在变量上</span></span><br><span class="line"><span class="comment">// 或在监视窗口添加变量</span></span><br><span class="line"><span class="comment">// 或在即时窗口中输入变量名</span></span><br></pre></td></tr></table></figure>
<h4 id="日志记录">日志记录</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;log4cpp/Category.hh&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;log4cpp/PropertyConfigurator.hh&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 日志级别枚举</span></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">LogLevel</span> &#123;</span><br><span class="line">    DEBUG,</span><br><span class="line">    INFO,</span><br><span class="line">    WARNING,</span><br><span class="line">    ERROR,</span><br><span class="line">    FATAL</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简单的日志类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Logger</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> LogLevel m_minLevel;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">setLogLevel</span><span class="params">(LogLevel level)</span> </span>&#123;</span><br><span class="line">        m_minLevel = level;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function">    <span class="type">static</span> <span class="type">void</span> <span class="title">log</span><span class="params">(LogLevel level, <span class="type">const</span> <span class="type">char</span>* format, Args... args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (level &lt; m_minLevel) <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获取当前时间</span></span><br><span class="line">        std::<span class="type">time_t</span> now = std::<span class="built_in">time</span>(<span class="literal">nullptr</span>);</span><br><span class="line">        <span class="type">char</span> timeStr[<span class="number">64</span>];</span><br><span class="line">        std::<span class="built_in">strftime</span>(timeStr, <span class="built_in">sizeof</span>(timeStr), <span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>, std::<span class="built_in">localtime</span>(&amp;now));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 打印日志级别</span></span><br><span class="line">        <span class="type">const</span> <span class="type">char</span>* levelStr = <span class="string">&quot;UNKNOWN&quot;</span>;</span><br><span class="line">        <span class="keyword">switch</span> (level) &#123;</span><br><span class="line">            <span class="keyword">case</span> LogLevel::DEBUG:   levelStr = <span class="string">&quot;DEBUG&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> LogLevel::INFO:    levelStr = <span class="string">&quot;INFO&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> LogLevel::WARNING: levelStr = <span class="string">&quot;WARNING&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> LogLevel::ERROR:   levelStr = <span class="string">&quot;ERROR&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> LogLevel::FATAL:   levelStr = <span class="string">&quot;FATAL&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 打印日志</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[%s] [%s] &quot;</span>, timeStr, levelStr);</span><br><span class="line">        <span class="built_in">printf</span>(format, args...);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 便捷方法</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function">    <span class="type">static</span> <span class="type">void</span> <span class="title">debug</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* format, Args... args)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">log</span>(LogLevel::DEBUG, format, args...);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function">    <span class="type">static</span> <span class="type">void</span> <span class="title">info</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* format, Args... args)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">log</span>(LogLevel::INFO, format, args...);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function">    <span class="type">static</span> <span class="type">void</span> <span class="title">warning</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* format, Args... args)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">log</span>(LogLevel::WARNING, format, args...);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function">    <span class="type">static</span> <span class="type">void</span> <span class="title">error</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* format, Args... args)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">log</span>(LogLevel::ERROR, format, args...);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function">    <span class="type">static</span> <span class="type">void</span> <span class="title">fatal</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* format, Args... args)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">log</span>(LogLevel::FATAL, format, args...);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">LogLevel Logger::m_minLevel = LogLevel::INFO;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用示例</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">processData</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt;&amp; data)</span> </span>&#123;</span><br><span class="line">    Logger::<span class="built_in">info</span>(<span class="string">&quot;Processing %zu items&quot;</span>, data.<span class="built_in">size</span>());</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (data.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        Logger::<span class="built_in">warning</span>(<span class="string">&quot;Empty data vector received&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; data.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            Logger::<span class="built_in">debug</span>(<span class="string">&quot;Processing item %zu: %d&quot;</span>, i, data[i]);</span><br><span class="line">            <span class="comment">// 处理数据</span></span><br><span class="line">            <span class="keyword">if</span> (data[i] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                Logger::<span class="built_in">error</span>(<span class="string">&quot;Negative value at index %zu&quot;</span>, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::exception&amp; e) &#123;</span><br><span class="line">        Logger::<span class="built_in">fatal</span>(<span class="string">&quot;Exception during processing: %s&quot;</span>, e.<span class="built_in">what</span>());</span><br><span class="line">        <span class="keyword">throw</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Logger::<span class="built_in">info</span>(<span class="string">&quot;Processing completed successfully&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="断言使用">断言使用</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 基本断言</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">divide</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 断言b不为0</span></span><br><span class="line">    <span class="built_in">assert</span>(b != <span class="number">0</span> &amp;&amp; <span class="string">&quot;Division by zero&quot;</span>);</span><br><span class="line">    <span class="type">int</span> result = a / b;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义断言宏</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CHECK(condition, message) \</span></span><br><span class="line"><span class="meta">    do &#123; \</span></span><br><span class="line"><span class="meta">        <span class="keyword">if</span> (!(condition)) &#123; \</span></span><br><span class="line"><span class="meta">            std::cerr &lt;&lt; <span class="string">&quot;CHECK FAILED: &quot;</span> &lt;&lt; message \</span></span><br><span class="line"><span class="meta">                      &lt;&lt; <span class="string">&quot; at &quot;</span> &lt;&lt; __FILE__ \</span></span><br><span class="line"><span class="meta">                      &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; __LINE__ \</span></span><br><span class="line"><span class="meta">                      &lt;&lt; <span class="string">&quot;\n&quot;</span>; \</span></span><br><span class="line"><span class="meta">            std::abort(); \</span></span><br><span class="line"><span class="meta">        &#125; \</span></span><br><span class="line"><span class="meta">    &#125; while (0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用自定义断言</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">processArray</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">size_t</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">CHECK</span>(index &lt; arr.<span class="built_in">size</span>(), <span class="string">&quot;Index out of bounds&quot;</span>);</span><br><span class="line">    <span class="comment">// 处理数组元素</span></span><br><span class="line">    std::cout &lt;&lt; arr[index] &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在单元测试中使用断言</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">testAddFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(<span class="built_in">add</span>(<span class="number">2</span>, <span class="number">3</span>) == <span class="number">5</span>);</span><br><span class="line">    <span class="built_in">assert</span>(<span class="built_in">add</span>(<span class="number">-1</span>, <span class="number">1</span>) == <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="常见错误排查">常见错误排查</h4>
<ol>
<li><strong>段错误（Segmentation Fault）</strong></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 常见原因：空指针解引用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">segmentationFaultExample</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span>* ptr = <span class="literal">nullptr</span>;</span><br><span class="line">    *ptr = <span class="number">42</span>;  <span class="comment">// 段错误！</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 排查方法：</span></span><br><span class="line"><span class="comment">// - 使用调试器设置断点，定位错误发生的位置</span></span><br><span class="line"><span class="comment">// - 检查指针是否正确初始化</span></span><br><span class="line"><span class="comment">// - 使用Valgrind等工具检测内存错误</span></span><br><span class="line"><span class="comment">// - 添加空指针检查</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">safeFunction</span><span class="params">(<span class="type">int</span>* ptr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ptr == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Error: Null pointer passed&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    *ptr = <span class="number">42</span>;  <span class="comment">// 安全操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li><strong>内存泄漏</strong></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 常见原因：忘记释放动态分配的内存</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">memoryLeakExample</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span>* data = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">100</span>];</span><br><span class="line">    <span class="comment">// 使用data...</span></span><br><span class="line">    <span class="comment">// 忘记delete[] data;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解决方案：</span></span><br><span class="line"><span class="comment">// - 使用智能指针管理内存</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">noLeakExample</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> data = std::<span class="built_in">make_unique</span>&lt;<span class="type">int</span>[]&gt;(<span class="number">100</span>);</span><br><span class="line">    <span class="comment">// 使用data...</span></span><br><span class="line">    <span class="comment">// 不需要手动释放，会在作用域结束时自动释放</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// - 使用RAII容器</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">betterApproach</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">data</span><span class="params">(<span class="number">100</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 使用data...</span></span><br><span class="line">    <span class="comment">// 自动管理内存</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li><strong>悬垂指针</strong></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 常见原因：使用已经释放的内存</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">danglingPointerExample</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span>* ptr = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">42</span>);</span><br><span class="line">    <span class="keyword">delete</span> ptr;</span><br><span class="line">    std::cout &lt;&lt; *ptr &lt;&lt; std::endl;  <span class="comment">// 未定义行为！</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解决方案：</span></span><br><span class="line"><span class="comment">// - 释放后将指针设为nullptr</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">safeApproach</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span>* ptr = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">42</span>);</span><br><span class="line">    <span class="keyword">delete</span> ptr;</span><br><span class="line">    ptr = <span class="literal">nullptr</span>;  <span class="comment">// 避免悬垂指针</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 检查后再使用</span></span><br><span class="line">    <span class="keyword">if</span> (ptr != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; *ptr &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li><strong>整数溢出</strong></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 常见原因：整数运算结果超出类型范围</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">integerOverflowExample</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> maxInt = INT_MAX;</span><br><span class="line">    <span class="type">int</span> result = maxInt + <span class="number">1</span>;  <span class="comment">// 溢出！</span></span><br><span class="line">    std::cout &lt;&lt; result &lt;&lt; std::endl;  <span class="comment">// 输出可能是-2147483648</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解决方案：</span></span><br><span class="line"><span class="comment">// - 检查可能的溢出</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">addSafe</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span>&amp; result)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 检查加法溢出</span></span><br><span class="line">    <span class="keyword">if</span> ((b &gt; <span class="number">0</span> &amp;&amp; a &gt; INT_MAX - b) || </span><br><span class="line">        (b &lt; <span class="number">0</span> &amp;&amp; a &lt; INT_MIN - b)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// 会溢出</span></span><br><span class="line">    &#125;</span><br><span class="line">    result = a + b;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// - 使用更大范围的类型</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">useLongLong</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> largeResult = <span class="built_in">static_cast</span>&lt;<span class="type">long</span> <span class="type">long</span>&gt;(INT_MAX) + <span class="number">1</span>;</span><br><span class="line">    std::cout &lt;&lt; largeResult &lt;&lt; std::endl;  <span class="comment">// 正确输出2147483648</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="5">
<li><strong>死锁</strong></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 常见原因：多线程中循环等待锁</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">deadlockExample</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::mutex mutex1, mutex2;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 线程1</span></span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">([&amp;mutex1, &amp;mutex2]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        mutex<span class="number">1.l</span>ock();</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="comment">// 模拟一些工作</span></span></span></span><br><span class="line"><span class="params"><span class="function">        std::this_thread::sleep_for(std::chrono::milliseconds(<span class="number">10</span>));</span></span></span><br><span class="line"><span class="params"><span class="function">        mutex<span class="number">2.l</span>ock();  <span class="comment">// 尝试获取已被线程2持有的锁</span></span></span></span><br><span class="line"><span class="params"><span class="function">        </span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="comment">// 临界区</span></span></span></span><br><span class="line"><span class="params"><span class="function">        mutex<span class="number">2.</span>unlock();</span></span></span><br><span class="line"><span class="params"><span class="function">        mutex<span class="number">1.</span>unlock();</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 线程2</span></span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">([&amp;mutex1, &amp;mutex2]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        mutex<span class="number">2.l</span>ock();</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="comment">// 模拟一些工作</span></span></span></span><br><span class="line"><span class="params"><span class="function">        std::this_thread::sleep_for(std::chrono::milliseconds(<span class="number">10</span>));</span></span></span><br><span class="line"><span class="params"><span class="function">        mutex<span class="number">1.l</span>ock();  <span class="comment">// 尝试获取已被线程1持有的锁</span></span></span></span><br><span class="line"><span class="params"><span class="function">        </span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="comment">// 临界区</span></span></span></span><br><span class="line"><span class="params"><span class="function">        mutex<span class="number">1.</span>unlock();</span></span></span><br><span class="line"><span class="params"><span class="function">        mutex<span class="number">2.</span>unlock();</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;)</span></span>;</span><br><span class="line">    </span><br><span class="line">    t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">    t<span class="number">2.</span><span class="built_in">join</span>();  <span class="comment">// 可能永远不会完成</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解决方案：</span></span><br><span class="line"><span class="comment">// - 按相同顺序获取锁</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">avoidDeadlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::mutex mutex1, mutex2;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 线程1</span></span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">([&amp;mutex1, &amp;mutex2]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        mutex<span class="number">1.l</span>ock();  <span class="comment">// 总是先获取mutex1</span></span></span></span><br><span class="line"><span class="params"><span class="function">        mutex<span class="number">2.l</span>ock();</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="comment">// 临界区</span></span></span></span><br><span class="line"><span class="params"><span class="function">        mutex<span class="number">2.</span>unlock();</span></span></span><br><span class="line"><span class="params"><span class="function">        mutex<span class="number">1.</span>unlock();</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 线程2</span></span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">([&amp;mutex1, &amp;mutex2]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        mutex<span class="number">1.l</span>ock();  <span class="comment">// 总是先获取mutex1</span></span></span></span><br><span class="line"><span class="params"><span class="function">        mutex<span class="number">2.l</span>ock();</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="comment">// 临界区</span></span></span></span><br><span class="line"><span class="params"><span class="function">        mutex<span class="number">2.</span>unlock();</span></span></span><br><span class="line"><span class="params"><span class="function">        mutex<span class="number">1.</span>unlock();</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;)</span></span>;</span><br><span class="line">    </span><br><span class="line">    t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">    t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// - 使用std::lock同时获取多个锁</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">useStdLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::mutex mutex1, mutex2;</span><br><span class="line">    </span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">([&amp;mutex1, &amp;mutex2]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        std::lock(mutex1, mutex2);  <span class="comment">// 原子地获取两个锁</span></span></span></span><br><span class="line"><span class="params"><span class="function">        </span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="comment">// 使用std::lock_guard在作用域结束时自动释放锁</span></span></span></span><br><span class="line"><span class="params"><span class="function">        std::lock_guard&lt;std::mutex&gt; lock1(mutex1, std::adopt_lock);</span></span></span><br><span class="line"><span class="params"><span class="function">        std::lock_guard&lt;std::mutex&gt; lock2(mutex2, std::adopt_lock);</span></span></span><br><span class="line"><span class="params"><span class="function">        </span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="comment">// 临界区</span></span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;)</span></span>;  <span class="comment">// 自动释放锁</span></span><br><span class="line">    </span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-3-性能优化">5.3 性能优化</h3>
<p>性能优化是软件开发中的重要环节，但过早优化往往是不必要的。本节介绍一些C++中的性能优化技术。</p>
<h4 id="算法优化">算法优化</h4>
<ol>
<li><strong>选择合适的算法</strong></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不好的做法：使用O(n²)的排序算法处理大数据</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">inefficientSort</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt;&amp; data)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 冒泡排序 - O(n²)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; data.<span class="built_in">size</span>() - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> j = <span class="number">0</span>; j &lt; data.<span class="built_in">size</span>() - i - <span class="number">1</span>; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (data[j] &gt; data[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                std::<span class="built_in">swap</span>(data[j], data[j + <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 好的做法：使用高效的排序算法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">efficientSort</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt;&amp; data)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 快速排序/归并排序 - O(n log n)</span></span><br><span class="line">    std::<span class="built_in">sort</span>(data.<span class="built_in">begin</span>(), data.<span class="built_in">end</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li><strong>避免不必要的计算</strong></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不好的做法：重复计算相同的值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">redundantCalculation</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt;&amp; data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; data.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="comment">// sqrt是昂贵的操作，但在每次迭代中都重新计算</span></span><br><span class="line">        <span class="keyword">if</span> (data[i] &gt; std::<span class="built_in">sqrt</span>(MAX_VALUE)) &#123;</span><br><span class="line">            <span class="comment">// 处理...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 好的做法：预先计算并缓存结果</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">optimizedCalculation</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt;&amp; data)</span> </span>&#123;</span><br><span class="line">    <span class="type">double</span> sqrtMaxValue = std::<span class="built_in">sqrt</span>(MAX_VALUE);  <span class="comment">// 计算一次</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; data.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (data[i] &gt; sqrtMaxValue) &#123;</span><br><span class="line">            <span class="comment">// 处理...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li><strong>提前终止条件</strong></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线性搜索中的提前终止</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">containsValue</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt;&amp; data, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> value : data) &#123;</span><br><span class="line">        <span class="keyword">if</span> (value == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">// 找到立即返回</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// 未找到</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="数据结构选择">数据结构选择</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据访问模式选择合适的容器</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 需要频繁随机访问 - 使用std::vector</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">randomAccessExample</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; data = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="comment">// O(1)时间复杂度的随机访问</span></span><br><span class="line">    <span class="type">int</span> value = data[<span class="number">2</span>];  <span class="comment">// 直接访问索引2处的元素</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 需要频繁插入/删除 - 使用std::list或std::deque</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">frequentModificationExample</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::list&lt;<span class="type">int</span>&gt; data = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="comment">// O(1)时间复杂度的插入（在已知位置）</span></span><br><span class="line">    <span class="keyword">auto</span> it = std::<span class="built_in">next</span>(data.<span class="built_in">begin</span>(), <span class="number">2</span>);</span><br><span class="line">    data.<span class="built_in">insert</span>(it, <span class="number">10</span>);  <span class="comment">// 在位置2插入10</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 需要快速查找 - 使用std::unordered_map/std::unordered_set</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fastLookupExample</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::unordered_map&lt;std::string, <span class="type">int</span>&gt; nameToId = &#123;</span><br><span class="line">        &#123;<span class="string">&quot;Alice&quot;</span>, <span class="number">1</span>&#125;, &#123;<span class="string">&quot;Bob&quot;</span>, <span class="number">2</span>&#125;, &#123;<span class="string">&quot;Charlie&quot;</span>, <span class="number">3</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// O(1)平均时间复杂度的查找</span></span><br><span class="line">    <span class="keyword">if</span> (nameToId.<span class="built_in">count</span>(<span class="string">&quot;Bob&quot;</span>)) &#123;</span><br><span class="line">        <span class="type">int</span> id = nameToId[<span class="string">&quot;Bob&quot;</span>];  <span class="comment">// 快速获取Bob的ID</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 需要有序集合 - 使用std::map/std::set</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">orderedCollectionExample</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::set&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">5</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">9</span>&#125;;</span><br><span class="line">    <span class="comment">// 自动排序，按顺序访问</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : numbers) &#123;</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;  <span class="comment">// 输出: 1 2 5 8 9</span></span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="内存优化">内存优化</h4>
<ol>
<li><strong>避免不必要的拷贝</strong></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不好的做法：传递大对象时按值传递</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">passByValue</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt; data)</span> </span>&#123;  <span class="comment">// 创建了data的副本</span></span><br><span class="line">    <span class="comment">// 处理data...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 好的做法：传递大对象时按引用传递</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">passByReference</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt;&amp; data)</span> </span>&#123;  <span class="comment">// 无拷贝</span></span><br><span class="line">    <span class="comment">// 处理data...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 需要修改参数时使用非常量引用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modifyByReference</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt;&amp; data)</span> </span>&#123;</span><br><span class="line">    data.<span class="built_in">push_back</span>(<span class="number">42</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li><strong>使用移动语义</strong></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 利用移动语义避免不必要的拷贝</span></span><br><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">createLargeVector</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">vec</span><span class="params">(<span class="number">1000000</span>, <span class="number">1</span>)</span></span>;  <span class="comment">// 创建大向量</span></span><br><span class="line">    <span class="keyword">return</span> vec;  <span class="comment">// C++11后会自动移动而非拷贝</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">useMoveSemantics</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; largeVec = <span class="built_in">createLargeVector</span>();  <span class="comment">// 移动构造</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 显式使用std::move</span></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; anotherVec = std::<span class="built_in">move</span>(largeVec);  <span class="comment">// largeVec现在为空</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在函数参数中使用移动语义</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">processAndStore</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt;&amp;&amp; data)</span> </span>&#123;  <span class="comment">// 右值引用</span></span><br><span class="line">        m_data = std::<span class="built_in">move</span>(data);  <span class="comment">// 移动赋值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li><strong>内存池</strong></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简单的内存池实现</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MemoryPool</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span>* m_memory;</span><br><span class="line">    <span class="type">size_t</span> m_blockSize;</span><br><span class="line">    <span class="type">size_t</span> m_numBlocks;</span><br><span class="line">    std::vector&lt;<span class="type">char</span>*&gt; m_freeList;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MemoryPool</span>(<span class="type">size_t</span> blockSize, <span class="type">size_t</span> numBlocks) </span><br><span class="line">        : <span class="built_in">m_blockSize</span>(blockSize), <span class="built_in">m_numBlocks</span>(numBlocks) &#123;</span><br><span class="line">        m_memory = <span class="keyword">new</span> <span class="type">char</span>[blockSize * numBlocks];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 初始化空闲块列表</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; numBlocks; ++i) &#123;</span><br><span class="line">            m_freeList.<span class="built_in">push_back</span>(&amp;m_memory[i * blockSize]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ~<span class="built_in">MemoryPool</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] m_memory;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span>* <span class="title">allocate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (m_freeList.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;  <span class="comment">// 内存池已满</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">void</span>* block = m_freeList.<span class="built_in">back</span>();</span><br><span class="line">        m_freeList.<span class="built_in">pop_back</span>();</span><br><span class="line">        <span class="keyword">return</span> block;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">deallocate</span><span class="params">(<span class="type">void</span>* ptr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ptr) &#123;</span><br><span class="line">            m_freeList.<span class="built_in">push_back</span>(<span class="built_in">static_cast</span>&lt;<span class="type">char</span>*&gt;(ptr));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 禁止拷贝和移动</span></span><br><span class="line">    <span class="built_in">MemoryPool</span>(<span class="type">const</span> MemoryPool&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    MemoryPool&amp; <span class="keyword">operator</span>=(<span class="type">const</span> MemoryPool&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用内存池</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">useMemoryPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">MemoryPool <span class="title">pool</span><span class="params">(<span class="keyword">sizeof</span>(MyObject), <span class="number">100</span>)</span></span>;  <span class="comment">// 为MyObject类型创建内存池</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从池中分配内存</span></span><br><span class="line">    <span class="type">void</span>* memory = pool.<span class="built_in">allocate</span>();</span><br><span class="line">    <span class="comment">// 在分配的内存上构造对象</span></span><br><span class="line">    MyObject* obj = <span class="built_in">new</span> (memory) <span class="built_in">MyObject</span>();  <span class="comment">// placement new</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用对象...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 销毁对象</span></span><br><span class="line">    obj-&gt;~<span class="built_in">MyObject</span>();</span><br><span class="line">    <span class="comment">// 释放内存回池</span></span><br><span class="line">    pool.<span class="built_in">deallocate</span>(memory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li><strong>减少堆分配</strong></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不好的做法：频繁的小堆分配</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">frequentAllocations</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; ++i) &#123;</span><br><span class="line">        <span class="type">int</span>* ptr = <span class="keyword">new</span> <span class="built_in">int</span>(i);  <span class="comment">// 堆分配</span></span><br><span class="line">        <span class="comment">// 使用ptr...</span></span><br><span class="line">        <span class="keyword">delete</span> ptr;  <span class="comment">// 堆释放</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 好的做法：使用栈分配（小对象）或预先分配</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">stackAllocation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> value = i;  <span class="comment">// 栈分配</span></span><br><span class="line">        <span class="comment">// 使用value...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用对象池或容器</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">useContainer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; values;</span><br><span class="line">    values.<span class="built_in">reserve</span>(<span class="number">1000</span>);  <span class="comment">// 预先分配足够的空间</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; ++i) &#123;</span><br><span class="line">        values.<span class="built_in">push_back</span>(i);  <span class="comment">// 不会触发多次重新分配</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="编译器优化">编译器优化</h4>
<ol>
<li><strong>启用编译器优化</strong></li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># GCC/Clang优化级别</span></span><br><span class="line"><span class="comment"># -O0: 无优化（默认，用于调试）</span></span><br><span class="line"><span class="comment"># -O1: 基本优化</span></span><br><span class="line"><span class="comment"># -O2: 更多优化</span></span><br><span class="line"><span class="comment"># -O3: 最大优化</span></span><br><span class="line"><span class="comment"># -Ofast: 快速优化（可能违反IEEE标准）</span></span><br><span class="line"><span class="comment"># -Os: 针对代码大小的优化</span></span><br><span class="line"></span><br><span class="line">g++ -O3 program.cpp -o program</span><br><span class="line"></span><br><span class="line"><span class="comment"># Visual Studio优化设置</span></span><br><span class="line"><span class="comment"># 在项目属性 -&gt; C/C++ -&gt; 优化中设置</span></span><br><span class="line"><span class="comment"># /O0: 无优化</span></span><br><span class="line"><span class="comment"># /O1: 最小化大小</span></span><br><span class="line"><span class="comment"># /O2: 最大化速度</span></span><br><span class="line"><span class="comment"># /Ox: 完全优化</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li><strong>使用const和constexpr</strong></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// const变量可以被编译器优化</span></span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI = <span class="number">3.14159265359</span>;  <span class="comment">// 可能被内联</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// constexpr在编译期计算</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">factorial</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n &lt;= <span class="number">1</span> ? <span class="number">1</span> : n * <span class="built_in">factorial</span>(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> FACT_10 = <span class="built_in">factorial</span>(<span class="number">10</span>);  <span class="comment">// 在编译期计算为3628800</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用const引用传递不会被修改的参数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">processData</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt;&amp; data)</span> </span>&#123;  <span class="comment">// 编译器知道data不会被修改</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li><strong>内联函数</strong></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 小型频繁调用的函数使用inline</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;  <span class="comment">// 可能在调用点展开，减少函数调用开销</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类内定义的成员函数默认内联</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Utility</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">multiply</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;  <span class="comment">// 默认内联</span></span><br><span class="line">        <span class="keyword">return</span> a * b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="性能分析工具">性能分析工具</h4>
<ol>
<li><strong>使用gprof进行性能分析</strong></li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 编译时添加-pg选项</span></span><br><span class="line">g++ -pg program.cpp -o program</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行程序</span></span><br><span class="line">./program</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成性能分析报告</span></span><br><span class="line">gprof program gmon.out &gt; analysis.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看报告</span></span><br><span class="line"><span class="built_in">cat</span> analysis.txt</span><br></pre></td></tr></table></figure>
<ol start="2">
<li><strong>使用Valgrind的Callgrind</strong></li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装Valgrind（Linux）</span></span><br><span class="line"><span class="built_in">sudo</span> apt-get install valgrind</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行程序并收集性能数据</span></span><br><span class="line">valgrind --tool=callgrind ./program</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用KCachegrind可视化结果（Linux）</span></span><br><span class="line">kcachegrind callgrind.out.&lt;pid&gt;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li><strong>使用性能计数器API</strong></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">measureExecutionTime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> start = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 要测量的代码块</span></span><br><span class="line">    <span class="built_in">expensiveOperation</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">auto</span> end = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line">    <span class="keyword">auto</span> duration = std::chrono::<span class="built_in">duration_cast</span>&lt;std::chrono::microseconds&gt;(end - start);</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Execution time: &quot;</span> &lt;&lt; duration.<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot; microseconds&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li><strong>使用现代IDE的性能分析工具</strong></li>
</ol>
<ul>
<li><strong>Visual Studio</strong>: 诊断工具、性能探查器</li>
<li><strong>CLion</strong>: 内置CPU和内存分析器</li>
<li><strong>Xcode</strong>: Instruments工具集</li>
</ul>
<h4 id="性能优化的原则">性能优化的原则</h4>
<ol>
<li>
<p><strong>先测量，后优化</strong></p>
<ul>
<li>使用性能分析工具找出真正的瓶颈</li>
<li>不要优化猜测中的瓶颈，而是基于实际数据</li>
</ul>
</li>
<li>
<p><strong>保持代码的可读性和可维护性</strong></p>
<ul>
<li>不要过度优化，牺牲代码质量</li>
<li>确保优化后的代码仍然易于理解和维护</li>
</ul>
</li>
<li>
<p><strong>考虑编译器的优化能力</strong></p>
<ul>
<li>相信现代编译器的优化能力</li>
<li>编写清晰、符合直觉的代码，让编译器更容易优化</li>
</ul>
</li>
<li>
<p><strong>权衡空间和时间</strong></p>
<ul>
<li>有时可以通过增加内存使用来提高速度（缓存、预计算等）</li>
<li>有时需要在两者之间找到平衡</li>
</ul>
</li>
<li>
<p><strong>优化热点代码</strong></p>
<ul>
<li>集中精力优化那些执行频率高的代码部分</li>
<li>80/20法则：20%的代码可能占用了80%的执行时间</li>
</ul>
</li>
<li>
<p><strong>考虑平台特性</strong></p>
<ul>
<li>利用现代CPU的特性（流水线、缓存、SIMD指令等）</li>
<li>针对目标平台进行特定优化</li>
</ul>
</li>
</ol>
<p>记住，优化应该是一个持续的过程，而不是一次性的工作。良好的设计和代码组织是性能的基础，过度优化反而可能导致代码难以维护和扩展。始终保持性能和可维护性之间的平衡。</p>
<h3 id="5-4-常见陷阱与避免">5.4 常见陷阱与避免</h3>
<ul>
<li>空指针引用</li>
<li>缓冲区溢出</li>
<li>内存泄漏</li>
<li>野指针</li>
<li>未定义行为</li>
<li>线程安全问题</li>
</ul>
<h2 id="6-实战项目与练习">6. 实战项目与练习</h2>
<p>在这一部分，我们将介绍一些经典的C/C++实战项目和练习，帮助你巩固所学知识并提升编程能力。</p>
<h3 id="6-1-C语言经典项目">6.1 C语言经典项目</h3>
<h4 id="6-1-1-简易计算器">6.1.1 简易计算器</h4>
<p><strong>项目描述</strong>：实现一个支持基本算术运算的命令行计算器。</p>
<p><strong>核心功能</strong>：</p>
<ul>
<li>支持加、减、乘、除四则运算</li>
<li>支持括号优先级</li>
<li>支持浮点数计算</li>
<li>错误处理机制</li>
</ul>
<p><strong>实现思路</strong>：</p>
<ol>
<li>词法分析：将输入字符串转换为标记（tokens）</li>
<li>语法分析：使用递归下降或栈方法解析表达式</li>
<li>表达式求值：计算最终结果</li>
</ol>
<p><strong>核心代码示例</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 表达式求值函数</span></span><br><span class="line"><span class="type">double</span> <span class="title function_">evaluate_expression</span><span class="params">(<span class="type">const</span> <span class="type">char</span> **expr)</span> &#123;</span><br><span class="line">    <span class="type">double</span> result = evaluate_term(expr);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (**expr == <span class="string">&#x27;+&#x27;</span> || **expr == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">        <span class="type">char</span> op = *(*expr)++;</span><br><span class="line">        <span class="type">double</span> term = evaluate_term(expr);</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="string">&#x27;+&#x27;</span>) result += term;</span><br><span class="line">        <span class="keyword">else</span> result -= term;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> expr[<span class="number">100</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;简易计算器（输入&#x27;q&#x27;退出）\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;&gt;&gt; &quot;</span>);</span><br><span class="line">        fgets(expr, <span class="keyword">sizeof</span>(expr), <span class="built_in">stdin</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (expr[<span class="number">0</span>] == <span class="string">&#x27;q&#x27;</span> || expr[<span class="number">0</span>] == <span class="string">&#x27;Q&#x27;</span>) <span class="keyword">break</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="type">const</span> <span class="type">char</span> *ptr = expr;</span><br><span class="line">        <span class="type">double</span> result = evaluate_expression(&amp;ptr);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;= %.2lf\n&quot;</span>, result);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="6-1-2-文件管理器">6.1.2 文件管理器</h4>
<p><strong>项目描述</strong>：实现一个简单的文件管理工具，支持基本的文件操作。</p>
<p><strong>核心功能</strong>：</p>
<ul>
<li>列出目录内容</li>
<li>创建/删除文件和目录</li>
<li>复制/移动文件</li>
<li>文件内容查看</li>
</ul>
<p><strong>实现思路</strong>：</p>
<ol>
<li>使用系统API进行文件操作（Windows: Win32 API, Linux: POSIX API）</li>
<li>实现命令解析和执行</li>
<li>添加错误处理和用户提示</li>
</ol>
<p><strong>核心代码示例</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line">    <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 列出目录内容</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">list_directory</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path)</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line">    WIN32_FIND_DATA findFileData;</span><br><span class="line">    HANDLE hFind = INVALID_HANDLE_VALUE;</span><br><span class="line">    <span class="type">char</span> searchPath[<span class="number">1024</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">sprintf</span>(searchPath, <span class="string">&quot;%s\\*&quot;</span>, path);</span><br><span class="line">    hFind = FindFirstFile(searchPath, &amp;findFileData);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (hFind == INVALID_HANDLE_VALUE) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;无法打开目录: %s\n&quot;</span>, path);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\t&quot;</span>, findFileData.cFileName);</span><br><span class="line">    &#125; <span class="keyword">while</span> (FindNextFile(hFind, &amp;findFileData) != <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    FindClose(hFind);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    DIR *dir;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> *<span class="title">ent</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ((dir = opendir(path)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> ((ent = readdir(dir)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s\t&quot;</span>, ent-&gt;d_name);</span><br><span class="line">        &#125;</span><br><span class="line">        closedir(dir);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        perror(<span class="string">&quot;无法打开目录&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主函数实现命令行接口</span></span><br></pre></td></tr></table></figure>
<h4 id="6-1-3-简单数据库">6.1.3 简单数据库</h4>
<p><strong>项目描述</strong>：实现一个基于文件的简单键值存储数据库。</p>
<p><strong>核心功能</strong>：</p>
<ul>
<li>数据的增删改查操作</li>
<li>简单的事务支持</li>
<li>数据持久化</li>
<li>基本的索引功能</li>
</ul>
<p><strong>实现思路</strong>：</p>
<ol>
<li>使用哈希表在内存中存储数据</li>
<li>实现文件格式和IO操作</li>
<li>添加简单的锁机制支持事务</li>
</ol>
<p><strong>核心代码示例</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_KEY_SIZE 100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_VALUE_SIZE 1000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 键值对结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> key[MAX_KEY_SIZE];</span><br><span class="line">    <span class="type">char</span> value[MAX_VALUE_SIZE];</span><br><span class="line">&#125; KeyValuePair;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据库结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    KeyValuePair *data;</span><br><span class="line">    <span class="type">int</span> capacity;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    FILE *db_file;</span><br><span class="line">&#125; SimpleDB;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化数据库</span></span><br><span class="line">SimpleDB* <span class="title function_">init_db</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename)</span> &#123;</span><br><span class="line">    SimpleDB *db = (SimpleDB*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(SimpleDB));</span><br><span class="line">    db-&gt;capacity = <span class="number">100</span>;</span><br><span class="line">    db-&gt;size = <span class="number">0</span>;</span><br><span class="line">    db-&gt;data = (KeyValuePair*)<span class="built_in">malloc</span>(db-&gt;capacity * <span class="keyword">sizeof</span>(KeyValuePair));</span><br><span class="line">    </span><br><span class="line">    db-&gt;db_file = fopen(filename, <span class="string">&quot;rb+&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (db-&gt;db_file == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        db-&gt;db_file = fopen(filename, <span class="string">&quot;wb+&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 从文件加载数据</span></span><br><span class="line">        load_data_from_file(db);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> db;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入或更新数据</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">put</span><span class="params">(SimpleDB *db, <span class="type">const</span> <span class="type">char</span> *key, <span class="type">const</span> <span class="type">char</span> *value)</span> &#123;</span><br><span class="line">    <span class="comment">// 查找是否已存在</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; db-&gt;size; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(db-&gt;data[i].key, key) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">strcpy</span>(db-&gt;data[i].value, value);</span><br><span class="line">            save_to_file(db);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 插入新数据</span></span><br><span class="line">    <span class="keyword">if</span> (db-&gt;size &gt;= db-&gt;capacity) &#123;</span><br><span class="line">        db-&gt;capacity *= <span class="number">2</span>;</span><br><span class="line">        db-&gt;data = (KeyValuePair*)<span class="built_in">realloc</span>(db-&gt;data, db-&gt;capacity * <span class="keyword">sizeof</span>(KeyValuePair));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">strcpy</span>(db-&gt;data[db-&gt;size].key, key);</span><br><span class="line">    <span class="built_in">strcpy</span>(db-&gt;data[db-&gt;size].value, value);</span><br><span class="line">    db-&gt;size++;</span><br><span class="line">    </span><br><span class="line">    save_to_file(db);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其他函数：get, delete, save_to_file, load_data_from_file 等</span></span><br></pre></td></tr></table></figure>
<h4 id="6-1-4-网络编程基础">6.1.4 网络编程基础</h4>
<p><strong>项目描述</strong>：实现基于TCP/IP的简单客户端-服务器应用。</p>
<p><strong>核心功能</strong>：</p>
<ul>
<li>服务器监听连接</li>
<li>客户端发起连接</li>
<li>双向数据通信</li>
<li>多客户端支持（可选）</li>
</ul>
<p><strong>实现思路</strong>：</p>
<ol>
<li>使用socket API创建网络连接</li>
<li>实现服务器端的监听和接受连接</li>
<li>实现客户端的连接和通信</li>
<li>添加简单的协议处理消息格式</li>
</ol>
<p><strong>核心代码示例</strong>：</p>
<p>服务器端：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line">    <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;winsock2.h&gt;</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;ws2_32.lib&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> SOCKET int</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> INVALID_SOCKET -1</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line">    WSADATA wsaData;</span><br><span class="line">    WSAStartup(MAKEWORD(<span class="number">2</span>, <span class="number">2</span>), &amp;wsaData);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建socket</span></span><br><span class="line">    SOCKET server_fd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (server_fd == INVALID_SOCKET) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Socket creation failed\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 绑定地址和端口</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>;</span></span><br><span class="line">    <span class="type">int</span> addrlen = <span class="keyword">sizeof</span>(address);</span><br><span class="line">    address.sin_family = AF_INET;</span><br><span class="line">    address.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">    address.sin_port = htons(<span class="number">8080</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (bind(server_fd, (<span class="keyword">struct</span> sockaddr *)&amp;address, <span class="keyword">sizeof</span>(address)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Bind failed\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 监听连接</span></span><br><span class="line">    <span class="keyword">if</span> (listen(server_fd, <span class="number">3</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Listen failed\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;服务器启动，等待连接...\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 接受连接并处理</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        SOCKET new_socket;</span><br><span class="line">        <span class="keyword">if</span> ((new_socket = accept(server_fd, (<span class="keyword">struct</span> sockaddr *)&amp;address, (<span class="type">socklen_t</span>*)&amp;addrlen)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Accept failed\n&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">char</span> buffer[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="type">int</span> valread = recv(new_socket, buffer, <span class="number">1024</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;接收到: %s\n&quot;</span>, buffer);</span><br><span class="line">        </span><br><span class="line">        <span class="type">const</span> <span class="type">char</span> *response = <span class="string">&quot;消息已收到&quot;</span>;</span><br><span class="line">        send(new_socket, response, <span class="built_in">strlen</span>(response), <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;已发送响应\n&quot;</span>);</span><br><span class="line">        </span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line">        closesocket(new_socket);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        close(new_socket);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line">    closesocket(server_fd);</span><br><span class="line">    WSACleanup();</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    close(server_fd);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>客户端：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类似服务器端的头文件包含</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 初始化Winsock（Windows）</span></span><br><span class="line">    <span class="comment">// 创建socket</span></span><br><span class="line">    <span class="comment">// 连接到服务器</span></span><br><span class="line">    <span class="comment">// 发送和接收数据</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-2-C-面向对象项目">6.2 C++面向对象项目</h3>
<h4 id="6-2-1-图形界面应用">6.2.1 图形界面应用</h4>
<p><strong>项目描述</strong>：使用C++实现一个简单的图形界面应用程序。</p>
<p><strong>推荐框架</strong>：</p>
<ul>
<li>Qt：跨平台GUI框架，功能强大</li>
<li>wxWidgets：轻量级跨平台GUI库</li>
<li>MFC：Windows平台原生框架</li>
</ul>
<p><strong>核心功能</strong>：</p>
<ul>
<li>基本窗口和控件</li>
<li>事件处理</li>
<li>数据绑定</li>
<li>图形绘制（可选）</li>
</ul>
<p><strong>Qt示例</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QMainWindow&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QPushButton&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QLabel&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QVBoxLayout&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QWidget&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyApplication</span> : <span class="keyword">public</span> QMainWindow &#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyApplication</span>(QWidget *parent = <span class="literal">nullptr</span>) : <span class="built_in">QMainWindow</span>(parent) &#123;</span><br><span class="line">        <span class="comment">// 设置窗口标题和大小</span></span><br><span class="line">        <span class="built_in">setWindowTitle</span>(<span class="string">&quot;简易Qt应用&quot;</span>);</span><br><span class="line">        <span class="built_in">setGeometry</span>(<span class="number">100</span>, <span class="number">100</span>, <span class="number">400</span>, <span class="number">300</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建中央部件</span></span><br><span class="line">        QWidget *centralWidget = <span class="keyword">new</span> <span class="built_in">QWidget</span>(<span class="keyword">this</span>);</span><br><span class="line">        <span class="built_in">setCentralWidget</span>(centralWidget);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建布局</span></span><br><span class="line">        QVBoxLayout *layout = <span class="keyword">new</span> <span class="built_in">QVBoxLayout</span>(centralWidget);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建标签和按钮</span></span><br><span class="line">        label = <span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="string">&quot;欢迎使用Qt应用&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line">        QPushButton *button = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;点击我&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 添加到布局</span></span><br><span class="line">        layout-&gt;<span class="built_in">addWidget</span>(label);</span><br><span class="line">        layout-&gt;<span class="built_in">addWidget</span>(button);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 连接信号和槽</span></span><br><span class="line">        <span class="built_in">connect</span>(button, &amp;QPushButton::clicked, <span class="keyword">this</span>, &amp;MyApplication::onButtonClicked);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> slots:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">onButtonClicked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        label-&gt;<span class="built_in">setText</span>(<span class="string">&quot;按钮已被点击！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    QLabel *label;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 需要包含此宏以使用信号和槽</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;main.moc&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line">    MyApplication window;</span><br><span class="line">    window.<span class="built_in">show</span>();</span><br><span class="line">    <span class="keyword">return</span> app.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="6-2-2-游戏开发基础">6.2.2 游戏开发基础</h4>
<p><strong>项目描述</strong>：实现一个简单的2D游戏，学习游戏开发的基本概念。</p>
<p><strong>核心功能</strong>：</p>
<ul>
<li>游戏循环</li>
<li>精灵和动画</li>
<li>碰撞检测</li>
<li>输入处理</li>
<li>简单的物理系统</li>
</ul>
<p><strong>实现思路</strong>：</p>
<ol>
<li>使用SDL2或SFML等多媒体库处理图形和输入</li>
<li>设计游戏对象的类层次结构</li>
<li>实现游戏主循环和状态管理</li>
</ol>
<p><strong>SDL2示例</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;SDL2/SDL.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Game</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Game</span>() : <span class="built_in">window</span>(<span class="literal">nullptr</span>), <span class="built_in">renderer</span>(<span class="literal">nullptr</span>), <span class="built_in">isRunning</span>(<span class="literal">false</span>) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">initialize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 初始化SDL</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">SDL_Init</span>(SDL_INIT_VIDEO) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            std::cerr &lt;&lt; <span class="string">&quot;SDL初始化失败: &quot;</span> &lt;&lt; <span class="built_in">SDL_GetError</span>() &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建窗口</span></span><br><span class="line">        window = <span class="built_in">SDL_CreateWindow</span>(<span class="string">&quot;简易游戏&quot;</span>, SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED,</span><br><span class="line">                                 <span class="number">800</span>, <span class="number">600</span>, SDL_WINDOW_SHOWN);</span><br><span class="line">        <span class="keyword">if</span> (!window) &#123;</span><br><span class="line">            std::cerr &lt;&lt; <span class="string">&quot;窗口创建失败: &quot;</span> &lt;&lt; <span class="built_in">SDL_GetError</span>() &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建渲染器</span></span><br><span class="line">        renderer = <span class="built_in">SDL_CreateRenderer</span>(window, <span class="number">-1</span>, SDL_RENDERER_ACCELERATED);</span><br><span class="line">        <span class="keyword">if</span> (!renderer) &#123;</span><br><span class="line">            std::cerr &lt;&lt; <span class="string">&quot;渲染器创建失败: &quot;</span> &lt;&lt; <span class="built_in">SDL_GetError</span>() &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        isRunning = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (isRunning) &#123;</span><br><span class="line">            <span class="built_in">handleEvents</span>();</span><br><span class="line">            <span class="built_in">update</span>();</span><br><span class="line">            <span class="built_in">render</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">handleEvents</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        SDL_Event event;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">SDL_PollEvent</span>(&amp;event) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (event.type == SDL_QUIT) &#123;</span><br><span class="line">                isRunning = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 更新游戏逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">render</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 清屏</span></span><br><span class="line">        <span class="built_in">SDL_SetRenderDrawColor</span>(renderer, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>);</span><br><span class="line">        <span class="built_in">SDL_RenderClear</span>(renderer);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 渲染游戏对象</span></span><br><span class="line">        <span class="built_in">SDL_SetRenderDrawColor</span>(renderer, <span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>);</span><br><span class="line">        SDL_Rect rect = &#123;<span class="number">400</span>, <span class="number">300</span>, <span class="number">50</span>, <span class="number">50</span>&#125;;</span><br><span class="line">        <span class="built_in">SDL_RenderFillRect</span>(renderer, &amp;rect);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 呈现</span></span><br><span class="line">        <span class="built_in">SDL_RenderPresent</span>(renderer);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">SDL_DestroyRenderer</span>(renderer);</span><br><span class="line">        <span class="built_in">SDL_DestroyWindow</span>(window);</span><br><span class="line">        <span class="built_in">SDL_Quit</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    SDL_Window *window;</span><br><span class="line">    SDL_Renderer *renderer;</span><br><span class="line">    <span class="type">bool</span> isRunning;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    Game game;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!game.<span class="built_in">initialize</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    game.<span class="built_in">run</span>();</span><br><span class="line">    game.<span class="built_in">shutdown</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="6-2-3-系统工具开发">6.2.3 系统工具开发</h4>
<p><strong>项目描述</strong>：开发一个有用的系统工具，如性能监控、日志分析或文件处理工具。</p>
<p><strong>示例项目</strong>：系统资源监控工具</p>
<p><strong>核心功能</strong>：</p>
<ul>
<li>CPU使用率监控</li>
<li>内存使用情况监控</li>
<li>磁盘空间分析</li>
<li>进程管理</li>
</ul>
<p><strong>实现思路</strong>：</p>
<ol>
<li>使用系统API获取硬件信息</li>
<li>实现数据收集和处理逻辑</li>
<li>添加数据可视化界面（可选）</li>
</ol>
<p><strong>Windows系统监控示例</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;psapi.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SystemMonitor</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 获取CPU使用率</span></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">getCPUUsage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        FILETIME idleTime, kernelTime, userTime;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">GetSystemTimes</span>(&amp;idleTime, &amp;kernelTime, &amp;userTime)) &#123;</span><br><span class="line">            <span class="comment">// 计算CPU使用率的逻辑</span></span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0.0</span>; <span class="comment">// 简化示例</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取内存使用情况</span></span><br><span class="line">    <span class="function">MEMORYSTATUSEX <span class="title">getMemoryStatus</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        MEMORYSTATUSEX memoryStatus;</span><br><span class="line">        memoryStatus.dwLength = <span class="built_in">sizeof</span>(MEMORYSTATUSEX);</span><br><span class="line">        <span class="built_in">GlobalMemoryStatusEx</span>(&amp;memoryStatus);</span><br><span class="line">        <span class="keyword">return</span> memoryStatus;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 列出当前运行的进程</span></span><br><span class="line">    <span class="function">std::vector&lt;std::string&gt; <span class="title">listProcesses</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::vector&lt;std::string&gt; processes;</span><br><span class="line">        DWORD processes[<span class="number">1024</span>], cbNeeded, cProcesses;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">EnumProcesses</span>(processes, <span class="built_in">sizeof</span>(processes), &amp;cbNeeded)) &#123;</span><br><span class="line">            <span class="keyword">return</span> processes;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        cProcesses = cbNeeded / <span class="built_in">sizeof</span>(DWORD);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0</span>; i &lt; cProcesses; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (processes[i] != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="type">char</span> processName[MAX_PATH] = <span class="string">&quot;[未知]&quot;</span>;</span><br><span class="line">                </span><br><span class="line">                HANDLE hProcess = <span class="built_in">OpenProcess</span>(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, FALSE, processes[i]);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (hProcess != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                    HMODULE hMod;</span><br><span class="line">                    DWORD cbNeeded;</span><br><span class="line">                    </span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">EnumProcessModules</span>(hProcess, &amp;hMod, <span class="built_in">sizeof</span>(hMod), &amp;cbNeeded)) &#123;</span><br><span class="line">                        <span class="built_in">GetModuleBaseNameA</span>(hProcess, hMod, processName, <span class="built_in">sizeof</span>(processName) / <span class="built_in">sizeof</span>(<span class="type">char</span>));</span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                    <span class="built_in">CloseHandle</span>(hProcess);</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                processes.<span class="built_in">push_back</span>(processName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> processes;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="6-2-4-框架设计练习">6.2.4 框架设计练习</h4>
<p><strong>项目描述</strong>：设计并实现一个简单的应用框架，如事件驱动框架、插件系统或Web服务器框架。</p>
<p><strong>示例</strong>：简单的事件驱动框架</p>
<p><strong>核心功能</strong>：</p>
<ul>
<li>事件定义和注册</li>
<li>观察者模式实现</li>
<li>事件分发机制</li>
<li>异步事件处理（可选）</li>
</ul>
<p><strong>实现思路</strong>：</p>
<ol>
<li>定义事件基类和事件处理器接口</li>
<li>实现事件管理器作为核心组件</li>
<li>设计观察者模式的订阅-发布机制</li>
</ol>
<p><strong>代码示例</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 前向声明</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Event</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 事件处理器类型定义</span></span><br><span class="line"><span class="keyword">typedef</span> std::function&lt;<span class="type">void</span>(<span class="type">const</span> Event&amp;)&gt; EventHandler;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 事件基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Event</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Event</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::string <span class="title">getType</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体事件示例</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ButtonClickEvent</span> : <span class="keyword">public</span> Event &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ButtonClickEvent</span>(<span class="type">int</span> x, <span class="type">int</span> y) : <span class="built_in">x_</span>(x), <span class="built_in">y_</span>(y) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">std::string <span class="title">getType</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;ButtonClick&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getX</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> x_; &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getY</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> y_; &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> x_, y_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 事件管理器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EventManager</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 注册事件处理器</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">subscribe</span><span class="params">(<span class="type">const</span> std::string&amp; eventType, EventHandler handler)</span> </span>&#123;</span><br><span class="line">        handlers_[eventType].<span class="built_in">push_back</span>(handler);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 取消注册</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">unsubscribe</span><span class="params">(<span class="type">const</span> std::string&amp; eventType)</span> </span>&#123;</span><br><span class="line">        handlers_.<span class="built_in">erase</span>(eventType);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 触发事件</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">trigger</span><span class="params">(<span class="type">const</span> Event&amp; event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> it = handlers_.<span class="built_in">find</span>(event.<span class="built_in">getType</span>());</span><br><span class="line">        <span class="keyword">if</span> (it != handlers_.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; handler : it-&gt;second) &#123;</span><br><span class="line">                <span class="built_in">handler</span>(event);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::map&lt;std::string, std::vector&lt;EventHandler&gt;&gt; handlers_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 应用示例</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    EventManager eventManager;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 订阅按钮点击事件</span></span><br><span class="line">    eventManager.<span class="built_in">subscribe</span>(<span class="string">&quot;ButtonClick&quot;</span>, [](<span class="type">const</span> Event&amp; event) &#123;</span><br><span class="line">        <span class="type">const</span> <span class="keyword">auto</span>&amp; clickEvent = <span class="built_in">static_cast</span>&lt;<span class="type">const</span> ButtonClickEvent&amp;&gt;(event);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;按钮在位置 (&quot;</span> &lt;&lt; clickEvent.<span class="built_in">getX</span>() &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; clickEvent.<span class="built_in">getY</span>() &lt;&lt; <span class="string">&quot;) 被点击&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 触发事件</span></span><br><span class="line">    <span class="function">ButtonClickEvent <span class="title">clickEvent</span><span class="params">(<span class="number">100</span>, <span class="number">200</span>)</span></span>;</span><br><span class="line">    eventManager.<span class="built_in">trigger</span>(clickEvent);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-3-算法与数据结构实践">6.3 算法与数据结构实践</h3>
<h4 id="6-3-1-排序算法实现">6.3.1 排序算法实现</h4>
<p><strong>项目描述</strong>：实现各种经典排序算法并比较其性能。</p>
<p><strong>算法列表</strong>：</p>
<ul>
<li>冒泡排序</li>
<li>选择排序</li>
<li>插入排序</li>
<li>快速排序</li>
<li>归并排序</li>
<li>堆排序</li>
</ul>
<p><strong>实现思路</strong>：</p>
<ol>
<li>实现各排序算法的核心逻辑</li>
<li>添加性能测试和比较功能</li>
<li>分析不同数据规模和分布下的性能表现</li>
</ol>
<p><strong>代码示例</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 冒泡排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubbleSort</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                std::<span class="built_in">swap</span>(arr[j], arr[j + <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 快速排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSortHelper</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> low, <span class="type">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line">        <span class="type">int</span> pivot = arr[high];</span><br><span class="line">        <span class="type">int</span> i = low - <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = low; j &lt; high; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt;= pivot) &#123;</span><br><span class="line">                i++;</span><br><span class="line">                std::<span class="built_in">swap</span>(arr[i], arr[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        std::<span class="built_in">swap</span>(arr[i + <span class="number">1</span>], arr[high]);</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> pi = i + <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">quickSortHelper</span>(arr, low, pi - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">quickSortHelper</span>(arr, pi + <span class="number">1</span>, high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">quickSortHelper</span>(arr, <span class="number">0</span>, arr.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 归并排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> left, <span class="type">int</span> mid, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n1 = mid - left + <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> n2 = right - mid;</span><br><span class="line">    </span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">L</span><span class="params">(n1)</span>, <span class="title">R</span><span class="params">(n2)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n1; i++) &#123;</span><br><span class="line">        L[i] = arr[left + i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n2; j++) &#123;</span><br><span class="line">        R[j] = arr[mid + <span class="number">1</span> + j];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, k = left;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; n1 &amp;&amp; j &lt; n2) &#123;</span><br><span class="line">        <span class="keyword">if</span> (L[i] &lt;= R[j]) &#123;</span><br><span class="line">            arr[k++] = L[i++];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            arr[k++] = R[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (i &lt; n1) &#123;</span><br><span class="line">        arr[k++] = L[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (j &lt; n2) &#123;</span><br><span class="line">        arr[k++] = R[j++];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mergeSortHelper</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">mergeSortHelper</span>(arr, left, mid);</span><br><span class="line">        <span class="built_in">mergeSortHelper</span>(arr, mid + <span class="number">1</span>, right);</span><br><span class="line">        <span class="built_in">merge</span>(arr, left, mid, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mergeSort</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">mergeSortHelper</span>(arr, <span class="number">0</span>, arr.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 性能测试函数</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> SortFunc&gt;</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">measureSortPerformance</span><span class="params">(SortFunc sortFunc, std::vector&lt;<span class="type">int</span>&gt; arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> start = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line">    <span class="built_in">sortFunc</span>(arr);</span><br><span class="line">    <span class="keyword">auto</span> end = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> std::chrono::<span class="built_in">duration</span>&lt;<span class="type">double</span>, std::milli&gt;(end - start).<span class="built_in">count</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主函数，包含测试代码</span></span><br></pre></td></tr></table></figure>
<h4 id="6-3-2-树与图的操作">6.3.2 树与图的操作</h4>
<p><strong>项目描述</strong>：实现各种树和图数据结构及其基本操作。</p>
<p><strong>数据结构列表</strong>：</p>
<ul>
<li>二叉搜索树</li>
<li>AVL树（平衡二叉树）</li>
<li>红黑树（可选）</li>
<li>图（邻接矩阵和邻接表表示）</li>
<li>最小生成树</li>
<li>最短路径算法</li>
</ul>
<p><strong>实现思路</strong>：</p>
<ol>
<li>设计数据结构的类层次和接口</li>
<li>实现基本操作：插入、删除、查找等</li>
<li>实现遍历算法</li>
<li>实现高级操作（如平衡操作、最短路径等）</li>
</ol>
<p><strong>二叉搜索树示例</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 二叉搜索树节点</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    std::shared_ptr&lt;TreeNode&gt; left;</span><br><span class="line">    std::shared_ptr&lt;TreeNode&gt; right;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二叉搜索树类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BinarySearchTree</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">BinarySearchTree</span>() : <span class="built_in">root</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 插入节点</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        root = <span class="built_in">insertRecursive</span>(root, val);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 查找节点</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">search</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">searchRecursive</span>(root, val);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 删除节点</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        root = <span class="built_in">removeRecursive</span>(root, val);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 中序遍历</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">inorderTraversal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">inorderRecursive</span>(root);</span><br><span class="line">        std::cout &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 层次遍历</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">levelOrderTraversal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        std::queue&lt;std::shared_ptr&lt;TreeNode&gt;&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(root);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> node = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            </span><br><span class="line">            std::cout &lt;&lt; node-&gt;val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (node-&gt;left) q.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;right) q.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        std::cout &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::shared_ptr&lt;TreeNode&gt; root;</span><br><span class="line">    </span><br><span class="line">    <span class="function">std::shared_ptr&lt;TreeNode&gt; <span class="title">insertRecursive</span><span class="params">(std::shared_ptr&lt;TreeNode&gt; node, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!node) &#123;</span><br><span class="line">            <span class="keyword">return</span> std::<span class="built_in">make_shared</span>&lt;TreeNode&gt;(val);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (val &lt; node-&gt;val) &#123;</span><br><span class="line">            node-&gt;left = <span class="built_in">insertRecursive</span>(node-&gt;left, val);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (val &gt; node-&gt;val) &#123;</span><br><span class="line">            node-&gt;right = <span class="built_in">insertRecursive</span>(node-&gt;right, val);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">searchRecursive</span><span class="params">(std::shared_ptr&lt;TreeNode&gt; node, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!node) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;val == val) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (val &lt; node-&gt;val) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">searchRecursive</span>(node-&gt;left, val);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">searchRecursive</span>(node-&gt;right, val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">std::shared_ptr&lt;TreeNode&gt; <span class="title">findMin</span><span class="params">(std::shared_ptr&lt;TreeNode&gt; node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> current = node;</span><br><span class="line">        <span class="keyword">while</span> (current &amp;&amp; current-&gt;left) &#123;</span><br><span class="line">            current = current-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> current;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">std::shared_ptr&lt;TreeNode&gt; <span class="title">removeRecursive</span><span class="params">(std::shared_ptr&lt;TreeNode&gt; node, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!node) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (val &lt; node-&gt;val) &#123;</span><br><span class="line">            node-&gt;left = <span class="built_in">removeRecursive</span>(node-&gt;left, val);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (val &gt; node-&gt;val) &#123;</span><br><span class="line">            node-&gt;right = <span class="built_in">removeRecursive</span>(node-&gt;right, val);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 节点有0或1个子节点</span></span><br><span class="line">            <span class="keyword">if</span> (!node-&gt;left) <span class="keyword">return</span> node-&gt;right;</span><br><span class="line">            <span class="keyword">if</span> (!node-&gt;right) <span class="keyword">return</span> node-&gt;left;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 节点有2个子节点</span></span><br><span class="line">            <span class="keyword">auto</span> minNode = <span class="built_in">findMin</span>(node-&gt;right);</span><br><span class="line">            node-&gt;val = minNode-&gt;val;</span><br><span class="line">            node-&gt;right = <span class="built_in">removeRecursive</span>(node-&gt;right, minNode-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">inorderRecursive</span><span class="params">(std::shared_ptr&lt;TreeNode&gt; node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!node) <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">inorderRecursive</span>(node-&gt;left);</span><br><span class="line">        std::cout &lt;&lt; node-&gt;val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="built_in">inorderRecursive</span>(node-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="6-3-3-哈希表实现">6.3.3 哈希表实现</h4>
<p><strong>项目描述</strong>：实现一个完整的哈希表数据结构，支持常见操作。</p>
<p><strong>核心功能</strong>：</p>
<ul>
<li>基本的哈希函数设计</li>
<li>冲突处理（链地址法或开放地址法）</li>
<li>动态扩容</li>
<li>基本操作：插入、查找、删除</li>
</ul>
<p><strong>实现思路</strong>：</p>
<ol>
<li>设计哈希表的基本结构</li>
<li>实现哈希函数</li>
<li>实现冲突处理机制</li>
<li>添加动态扩容功能</li>
</ol>
<p><strong>代码示例</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 哈希表实现</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HashTable</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">HashTable</span>(<span class="type">size_t</span> size = <span class="number">16</span>) : <span class="built_in">capacity_</span>(size), <span class="built_in">size_</span>(<span class="number">0</span>) &#123;</span><br><span class="line">        table_.<span class="built_in">resize</span>(capacity_);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 插入键值对</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">const</span> std::string&amp; key, <span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 检查是否需要扩容</span></span><br><span class="line">        <span class="keyword">if</span> (size_ &gt;= capacity_ * <span class="number">0.75</span>) &#123;</span><br><span class="line">            <span class="built_in">resize</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">size_t</span> index = <span class="built_in">hash</span>(key);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 检查键是否已存在</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; pair : table_[index]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pair.first == key) &#123;</span><br><span class="line">                pair.second = value; <span class="comment">// 更新值</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 插入新键值对</span></span><br><span class="line">        table_[index].<span class="built_in">emplace_back</span>(key, value);</span><br><span class="line">        size_++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 查找值</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">find</span><span class="params">(<span class="type">const</span> std::string&amp; key, <span class="type">int</span>&amp; value)</span> </span>&#123;</span><br><span class="line">        <span class="type">size_t</span> index = <span class="built_in">hash</span>(key);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; pair : table_[index]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pair.first == key) &#123;</span><br><span class="line">                value = pair.second;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 删除键值对</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">remove</span><span class="params">(<span class="type">const</span> std::string&amp; key)</span> </span>&#123;</span><br><span class="line">        <span class="type">size_t</span> index = <span class="built_in">hash</span>(key);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = table_[index].<span class="built_in">begin</span>(); it != table_[index].<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">            <span class="keyword">if</span> (it-&gt;first == key) &#123;</span><br><span class="line">                table_[index].<span class="built_in">erase</span>(it);</span><br><span class="line">                size_--;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取大小</span></span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">getSize</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size_;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">size_t</span> capacity_; <span class="comment">// 桶的数量</span></span><br><span class="line">    <span class="type">size_t</span> size_;     <span class="comment">// 存储的元素数量</span></span><br><span class="line">    std::vector&lt;std::list&lt;std::pair&lt;std::string, <span class="type">int</span>&gt;&gt;&gt; table_; <span class="comment">// 哈希表数组</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 哈希函数</span></span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">hash</span><span class="params">(<span class="type">const</span> std::string&amp; key)</span> </span>&#123;</span><br><span class="line">        <span class="type">size_t</span> hashValue = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : key) &#123;</span><br><span class="line">            hashValue = <span class="number">37</span> * hashValue + c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hashValue % capacity_;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 扩容</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">resize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::vector&lt;std::list&lt;std::pair&lt;std::string, <span class="type">int</span>&gt;&gt;&gt; oldTable = std::<span class="built_in">move</span>(table_);</span><br><span class="line">        </span><br><span class="line">        capacity_ *= <span class="number">2</span>;</span><br><span class="line">        table_.<span class="built_in">clear</span>();</span><br><span class="line">        table_.<span class="built_in">resize</span>(capacity_);</span><br><span class="line">        size_ = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 重新插入所有元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; bucket : oldTable) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; pair : bucket) &#123;</span><br><span class="line">                <span class="built_in">insert</span>(pair.first, pair.second);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="6-3-4-缓存系统设计">6.3.4 缓存系统设计</h4>
<p><strong>项目描述</strong>：实现一个简单的缓存系统，支持常见的缓存替换策略。</p>
<p><strong>缓存策略</strong>：</p>
<ul>
<li>LRU (Least Recently Used)</li>
<li>LFU (Least Frequently Used)</li>
<li>FIFO (First In First Out)</li>
</ul>
<p><strong>核心功能</strong>：</p>
<ul>
<li>缓存项的存储和检索</li>
<li>缓存替换策略</li>
<li>缓存统计（命中率、容量等）</li>
</ul>
<p><strong>LRU缓存示例</strong>：</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;unordered_map&gt;
#include &lt;list&gt;
#include &lt;string&gt;

// LRU缓存实现
class LRUCache {
public:
    LRUCache(size_t capacity) : capacity_(capacity), size_(0) {}
    
    // 获取缓存项
    bool get(const std::string&amp; key, std::string&amp; value) {
        auto it = cacheMap_.find(key);
        if (it == cacheMap_.end()) {
            return false; // 缓存未命中
        }
        
        // 将访问的元素移到链表头部（最近使用）
        cacheList_.splice(cacheList_.begin(), cacheList_, it-&gt;second);
        value = it-&gt;second-&gt;second;
        return true;
    }
    
    // 插入缓存项
    void put(const std::string&amp; key, const std::string&amp; value) {
        auto it = cacheMap_.find(key);
        
        // 如果键已存在，更新值并移到链表头部
        if (it != cacheMap_.end()) {
            it-&gt;second-&gt;second = value;
            cacheList_.splice(cacheList_.begin(), cacheList_, it-&gt;second);
            return;
        }
        
        // 如果缓存已满，删除最久未使用的项（链表尾部）
        if (size_ &gt;= capacity_) {
            auto&amp; last = cacheList_.back();
            cacheMap_.erase(last.first);
            cacheList_.pop_back();
            size_--;
        }
        
        // 插入新项到链表头部
        cacheList_.push_front({key, value});
        cacheMap_[key] = cacheList_.begin();
        size_++;
    }
    
    // 获取缓存统计信息
    void getStats(double&amp; hitRate, size_t&amp; currentSize) {
        if (accessCount_ &gt; 0) {
            hitRate = static_cast&lt;double&gt;(hitCount_) / accessCount_;
        } else {
            hitRate = 0.0;
        }
        currentSize = size_;
    }
    
private:
    size_t capacity_;
    size_t size_;
    size_t accessCount_ = 0;
    size_t hitCount_ = 0;
    
    // 双向链表存储键值对，按使用顺序排序
    using CacheItem = std::pair&lt;std::string, std::string&gt;;
    std::list&lt;CacheItem&gt; cacheList_;
    
    // 哈希表用于快速查找
    std::unordered_map&lt;std::string, std::list&lt;CacheItem&gt;::iterator&gt; cacheMap_;
};

// 使用示例
int main() {
    LRUCache cache(3); // 容量为3的LRU缓存
    
    cache.put(&quot;key1&quot;, &quot;value1&quot;);
    cache.put(&quot;key2&quot;, &quot;value2&quot;);
    cache.put(&quot;key3&quot;, &quot;value3&quot;);
    
    std::string value;
    if (cache.get(&quot;key1&quot;, value)) {
        std::cout &lt;&lt; &quot;找到 key1: &quot; &lt;&lt; value &lt;&lt; std::endl;
    }
    
    // 添加第4个元素，会替换最久未使用的key2
    cache.put(&quot;key4&quot;, &quot;value4&quot;);
    
    if (!cache.get(&quot;key2&quot;, value)) {
        std::cout &lt;&lt; &quot;key2 已被淘汰出缓存&quot; &lt;&lt; std::endl;
    }
    
    return 0;
}

## 7. 学习资源与进阶路径

在本节中，我们为大家推荐一些优质的C/C++学习资源，包括经典书籍、在线教程、编程社区和开源项目，帮助你在编程之路上更进一步。

### 7.1 推荐书籍

#### 7.1.1 C语言经典书籍

**《C程序设计语言》（第2版）**
- 作者：Brian W. Kernighan, Dennis M. Ritchie
- 推荐理由：C语言的圣经，由C语言创始人之一编写，简洁明了，示例经典。
- 适合人群：所有C语言学习者，尤其是初学者
- 核心内容：基本语法、指针、数组、函数、结构体、文件操作等

**《C Primer Plus》（第6版）**
- 作者：Stephen Prata
- 推荐理由：全面且易于理解，包含大量示例和练习，对初学者友好。
- 适合人群：C语言初学者
- 核心内容：C语言基础、内存管理、文件IO、标准库等

**《C和指针》**
- 作者：Kenneth A. Reek
- 推荐理由：深入讲解指针这一C语言难点，通过大量实例帮助理解。
- 适合人群：想要深入理解C语言指针的开发者
- 核心内容：指针基础、指针与数组、指针与函数、指针与结构体等

**《C陷阱与缺陷》**
- 作者：Andrew Koenig
- 推荐理由：总结了C语言中常见的陷阱和缺陷，帮助开发者编写更健壮的代码。
- 适合人群：有一定经验的C语言开发者
- 核心内容：语法陷阱、语义陷阱、连接、库函数、预处理器等

#### 7.1.2 C++经典书籍

**《C++ Primer》（第5版）**
- 作者：Stanley B. Lippman, Josée Lajoie, Barbara E. Moo
- 推荐理由：C++的百科全书，内容全面且深入，是学习现代C++的必读之作。
- 适合人群：所有C++学习者
- 核心内容：C++基础、面向对象编程、STL、模板编程等

**《Effective C++》（第3版）**
- 作者：Scott Meyers
- 推荐理由：提供55个改善C++程序与设计的具体做法，是C++程序员的最佳实践指南。
- 适合人群：有一定C++基础的开发者
- 核心内容：资源管理、类型转换、继承与多态、STL使用等

**《C++编程思想》（第2版）**
- 作者：Bruce Eckel
- 推荐理由：从思想层面讲解C++，帮助读者理解面向对象编程的本质。
- 适合人群：想要深入理解面向对象编程的开发者
- 核心内容：C++基础、面向对象编程原理、模板、异常处理等

**《STL源码剖析》**
- 作者：侯捷
- 推荐理由：深入剖析STL的源码实现，帮助理解STL的设计思想和实现细节。
- 适合人群：想要深入学习STL的开发者
- 核心内容：容器、迭代器、算法、函数对象、适配器等

**《深度探索C++对象模型》**
- 作者：Stanley B. Lippman
- 推荐理由：深入解析C++对象模型的底层实现机制，帮助理解内存布局和性能优化。
- 适合人群：高级C++开发者
- 核心内容：虚函数表、内存布局、继承与多态的实现机制等

#### 7.1.3 算法与数据结构书籍

**《算法导论》（第3版）**
- 作者：Thomas H. Cormen, Charles E. Leiserson等
- 推荐理由：全面介绍算法设计与分析，是算法学习的经典教材。
- 适合人群：计算机相关专业学生和开发者
- 核心内容：排序、搜索、图算法、动态规划、贪心算法等

**《编程珠玑》（第2版）**
- 作者：Jon Bentley
- 推荐理由：通过实际问题展示如何运用算法和数据结构解决编程难题。
- 适合人群：想要提升编程技巧的开发者
- 核心内容：算法设计、数据结构应用、性能优化等

**《数据结构与算法分析 - C语言描述》**
- 作者：Mark Allen Weiss
- 推荐理由：使用C语言描述数据结构和算法，注重实现和性能分析。
- 适合人群：学习数据结构的C语言开发者
- 核心内容：基本数据结构、排序算法、图算法、高级数据结构等

**《数据结构与算法分析 - C++描述》**
- 作者：Mark Allen Weiss
- 推荐理由：使用C++描述数据结构和算法，结合STL进行讲解。
- 适合人群：学习数据结构的C++开发者
- 核心内容：基本数据结构、排序算法、图算法、STL应用等

### 7.2 在线资源

#### 7.2.1 学习网站

**C++官方资源**
- C++ Reference：https://en.cppreference.com/ - 最全面的C++标准库参考
- ISO C++：https://isocpp.org/ - C++官方网站，包含标准信息和最新动态

**互动学习平台**
- LeetCode：https://leetcode.com/ - 提供大量算法题目，支持C/C++编程
- Codewars：https://www.codewars.com/ - 通过挑战提升编程技能
- HackerRank：https://www.hackerrank.com/ - 编程挑战和技能评估平台

**在线教程**
- C++教程 | 菜鸟教程：https://www.runoob.com/cplusplus/cpp-tutorial.html
- C++ 教程 | 极客时间：提供系统化的C++学习路径
- Coursera：提供多所大学的C/C++在线课程
- edX：提供MIT等名校的C/C++课程

**技术博客和社区**
- CSDN：https://www.csdn.net/ - 中文开发者社区，有大量C/C++相关文章
- 掘金：https://juejin.cn/ - 高质量的技术分享社区
- InfoQ：https://www.infoq.cn/ - 关注技术前沿，有深入的C++专题
- 知乎：https://www.zhihu.com/topic/19552832 - C++话题下有许多优质内容

#### 7.2.2 开源项目

**学习型开源项目**
- C++ Core Guidelines：https://github.com/isocpp/CppCoreGuidelines - C++核心指南，提供最佳实践
- Google C++ Style Guide：https://google.github.io/styleguide/cppguide.html - Google的C++编码规范
- Awesome C++：https://github.com/fffaraz/awesome-cpp - C++优质资源大全

**优质C++库**
- Boost：https://www.boost.org/ - 高级C++库集合，扩展了标准库功能
- Qt：https://www.qt.io/ - 跨平台GUI和应用开发框架
- spdlog：https://github.com/gabime/spdlog - 快速的C++日志库
- nlohmann/json：https://github.com/nlohmann/json - 现代C++ JSON库
- fmt：https://github.com/fmtlib/fmt - 现代C++格式化库

**学习项目推荐**
- C++小项目集合：https://github.com/TheAlgorithms/C-Plus-Plus - 各种算法和数据结构的C++实现
- Antimony：https://github.com/antimony-lang/antimony - 简单的编程语言实现，适合学习编译器原理
- ToyDB：https://github.com/erikh/toydb - 简单的SQL数据库实现

#### 7.2.3 视频教程

**入门课程**
- B站上的&quot;黑马程序员C++教程&quot; - 适合零基础学习者
- B站上的&quot;尚学堂C++教程&quot; - 系统讲解C++基础

**进阶课程**
- B站上的&quot;侯捷C++视频教程&quot; - 深入讲解C++高级特性
- B站上的&quot;李超C++提高班&quot; - 注重实战和工程经验

### 7.3 进阶学习路径

#### 7.3.1 C语言进阶路径

**基础阶段（1-2个月）**
- 掌握基本语法、数据类型、运算符
- 学习函数、数组、指针基础
- 完成简单的编程练习

**提高阶段（2-3个月）**
- 深入学习指针和内存管理
- 学习结构体、联合体、枚举
- 掌握文件操作
- 开始编写小型项目

**高级阶段（3-4个月）**
- 学习编译预处理、宏定义
- 掌握多文件编程和模块化设计
- 学习系统编程（Linux/Windows API）
- 完成中型项目，如简单的文本编辑器、小游戏等

#### 7.3.2 C++进阶路径

**基础阶段（2-3个月）**
- 学习C++基础语法（类、对象、继承、多态）
- 掌握STL容器和算法的基本使用
- 完成简单的面向对象编程练习

**提高阶段（3-4个月）**
- 深入学习C++核心特性（模板、异常处理、命名空间）
- 掌握智能指针和现代C++内存管理
- 学习设计模式和面向对象设计原则
- 开始编写中型项目

**高级阶段（4-6个月）**
- 学习高级模板编程和元编程
- 掌握并发编程和多线程技术
- 学习性能优化和内存布局
- 完成大型项目或参与开源项目

#### 7.3.3 专业方向发展

**系统编程方向**
- 深入学习操作系统原理
- 掌握系统调用和内核编程
- 学习驱动开发
- 推荐书籍：《深入理解计算机系统》、《Linux内核设计与实现》

**游戏开发方向**
- 学习图形编程和3D数学
- 掌握游戏引擎（Unity/C++或Unreal Engine）
- 学习游戏物理和AI
- 推荐书籍：《游戏编程模式》、《3D数学基础：图形与游戏开发》

**嵌入式开发方向**
- 学习嵌入式系统原理
- 掌握特定平台的编程（如Arduino、STM32）
- 学习实时操作系统
- 推荐书籍：《嵌入式系统设计与实践》、《嵌入式C编程与工程实践》

**高性能计算方向**
- 学习并行计算和GPU编程
- 掌握SIMD指令和向量化
- 学习分布式计算
- 推荐书籍：《CUDA C编程指南》、《并行程序设计导论》

### 7.4 学习建议与技巧

#### 7.4.1 高效学习方法

**实践出真知**
- 边学边练：每学习一个新概念，立即编写代码实践
- 从小项目开始：先完成小功能，再逐步扩展
- 代码重构：不断改进已有代码，应用新学的知识

**系统学习**
- 建立知识体系：不要零散学习，要构建完整的知识结构
- 理解原理：不仅要知道如何用，还要知道为什么
- 总结归纳：定期总结所学内容，形成自己的笔记和思维导图

**交流与分享**
- 参与讨论：在论坛和社区中提问和回答问题
- 分享知识：写技术博客，讲解自己学到的知识
- 结对编程：与他人一起编程，互相学习

#### 7.4.2 常见学习误区

**避免的错误做法**
- 只看书不编程：编程是实践性很强的技能，必须多写代码
- 追求大而全：不要一开始就想编写复杂的程序，要循序渐进
- 忽视基础：不要急于学习高级特性，打好基础是关键
- 依赖IDE：要理解编译、链接等基本概念，不要完全依赖IDE

**正确的学习态度**
- 持之以恒：编程学习是一个长期过程，需要坚持
- 勇于尝试：不要害怕犯错，错误是最好的老师
- 学会调试：掌握调试技巧，提高解决问题的能力
- 关注代码质量：不仅要实现功能，还要注重代码的可读性和可维护性

#### 7.4.3 职业发展建议

**技术能力提升**
- 持续学习：关注新技术和新标准
- 深入某一领域：成为特定领域的专家
- 拓宽知识面：了解相关技术，如数据库、网络、安全等

**工程实践能力**
- 参与实际项目：积累实战经验
- 学习软件工程：了解需求分析、设计、测试等流程
- 掌握版本控制：熟练使用Git等工具

**软技能培养**
- 沟通能力：学会清晰表达自己的想法
- 团队协作：适应团队开发环境
- 问题解决：培养分析和解决问题的能力
- 时间管理：合理安排学习和工作时间

## 8. 附录

### 8.1 C标准库速查
- **标准输入输出库（stdio.h）**：提供基本的输入输出功能
- **字符串处理库（string.h）**：提供字符串操作函数
- **数学库（math.h）**：提供数学计算函数
- **标准库（stdlib.h）**：提供通用工具函数和内存管理
- **时间库（time.h）**：提供时间和日期处理函数

### 8.2 C++标准库速查
- **STL容器**：vector, list, map, set, deque等
- **STL算法**：sort, find, transform等
- **STL迭代器**：提供容器遍历机制
- **输入输出流**：iostream, fstream等
- **智能指针**：unique_ptr, shared_ptr, weak_ptr

### 8.3 常用编译选项
- **-O0/-O1/-O2/-O3**：优化级别控制
- **-g**：生成调试信息
- **-Wall**：启用所有警告
- **-Werror**：将警告视为错误
- **-std=c++11/c++14/c++17/c++20**：指定C++标准版本

### 8.4 常见面试题解析
- 指针与引用的区别
- 内存管理和内存泄漏
- 虚函数和多态实现机制
- STL容器实现原理
- 并发编程和线程安全

### 8.5 术语表
- **OOP**：面向对象编程(Object-Oriented Programming)
- **STL**：标准模板库(Standard Template Library)
- **RAII**：资源获取即初始化(Resource Acquisition Is Initialization)
- **SFINAE**：替换失败不是错误(Substitution Failure Is Not An Error)
- **CRTP**：奇异递归模板模式(Curiously Recurring Template Pattern)

---

本文档提供了C/C++语言学习的全面指南，从基础语法到高级特性，从编程实践到项目开发，帮助学习者系统掌握C/C++语言知识和技能。通过循序渐进的学习路径和丰富的代码示例，读者可以逐步构建坚实的编程基础，并应用于实际开发中。

祝您在编程学习的道路上取得成功！
</code></pre>
<!-- flag of hidden posts -->
    </div>

    
    
    
        

  <div class="followme">
    <p>欢迎关注我的其它发布渠道</p>

    <div class="social-list">

        <div class="social-item">
          <a target="_blank" class="social-link" href="/atom.xml">
            <span class="icon">
              <i class="fa fa-rss"></i>
            </span>

            <span class="label">RSS</span>
          </a>
        </div>
    </div>
  </div>


      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/C/" rel="tag"><i class="fa fa-tag"></i> C++</a>
          </div>

        


        
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-number">1.</span> <span class="nav-text">基本编译流程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AE%80%E5%8D%95%E7%A8%8B%E5%BA%8F%E7%BC%96%E8%AF%91%E4%B8%8E%E8%BF%90%E8%A1%8C%E7%A4%BA%E4%BE%8B"><span class="nav-number">1.1.</span> <span class="nav-text">简单程序编译与运行示例</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80"><span class="nav-number">1.2.</span> <span class="nav-text">2. C语言基础</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.2.1.</span> <span class="nav-text">2.1 基本语法与数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84%EF%BC%9Amain%E5%87%BD%E6%95%B0%E3%80%81%E8%AF%AD%E5%8F%A5%E3%80%81%E6%B3%A8%E9%87%8A"><span class="nav-number">1.2.1.1.</span> <span class="nav-text">程序结构：main函数、语句、注释</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#C%E7%A8%8B%E5%BA%8F%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84"><span class="nav-number">1.2.1.1.1.</span> <span class="nav-text">C程序基本结构</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%AD%E5%8F%A5"><span class="nav-number">1.2.1.1.2.</span> <span class="nav-text">语句</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%B3%A8%E9%87%8A"><span class="nav-number">1.2.1.1.3.</span> <span class="nav-text">注释</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%87%E8%AF%86%E7%AC%A6%E4%B8%8E%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">1.2.1.2.</span> <span class="nav-text">标识符与关键字</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A0%87%E8%AF%86%E7%AC%A6"><span class="nav-number">1.2.1.2.1.</span> <span class="nav-text">标识符</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">1.2.1.2.2.</span> <span class="nav-text">关键字</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.2.1.3.</span> <span class="nav-text">基本数据类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="nav-number">1.2.1.4.</span> <span class="nav-text">类型修饰符</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#signed"><span class="nav-number">1.2.1.4.1.</span> <span class="nav-text">signed</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#unsigned"><span class="nav-number">1.2.1.4.2.</span> <span class="nav-text">unsigned</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#short"><span class="nav-number">1.2.1.4.3.</span> <span class="nav-text">short</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#long"><span class="nav-number">1.2.1.4.4.</span> <span class="nav-text">long</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%B8%E9%87%8F%E4%B8%8E%E5%8F%98%E9%87%8F%E5%AE%9A%E4%B9%89"><span class="nav-number">1.2.1.5.</span> <span class="nav-text">常量与变量定义</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B8%B8%E9%87%8F"><span class="nav-number">1.2.1.5.1.</span> <span class="nav-text">常量</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8F%98%E9%87%8F%E5%AE%9A%E4%B9%89"><span class="nav-number">1.2.1.5.2.</span> <span class="nav-text">变量定义</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="nav-number">1.2.1.6.</span> <span class="nav-text">类型转换</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%9A%90%E5%BC%8F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%EF%BC%88%E8%87%AA%E5%8A%A8%E8%BD%AC%E6%8D%A2%EF%BC%89"><span class="nav-number">1.2.1.6.1.</span> <span class="nav-text">隐式类型转换（自动转换）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%98%BE%E5%BC%8F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%EF%BC%88%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2%EF%BC%89"><span class="nav-number">1.2.1.6.2.</span> <span class="nav-text">显式类型转换（强制转换）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-%E8%BF%90%E7%AE%97%E7%AC%A6%E4%B8%8E%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">1.2.2.</span> <span class="nav-text">2.2 运算符与表达式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">1.2.2.1.</span> <span class="nav-text">算术运算符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">1.2.2.2.</span> <span class="nav-text">关系运算符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">1.2.2.3.</span> <span class="nav-text">逻辑运算符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">1.2.2.4.</span> <span class="nav-text">赋值运算符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">1.2.2.5.</span> <span class="nav-text">位运算符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9D%A1%E4%BB%B6%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">1.2.2.6.</span> <span class="nav-text">条件运算符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7%E4%B8%8E%E7%BB%93%E5%90%88%E6%80%A7"><span class="nav-number">1.2.2.7.</span> <span class="nav-text">运算符优先级与结合性</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-%E6%8E%A7%E5%88%B6%E6%B5%81%E8%AF%AD%E5%8F%A5"><span class="nav-number">1.2.3.</span> <span class="nav-text">2.3 控制流语句</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5"><span class="nav-number">1.2.3.1.</span> <span class="nav-text">条件语句</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#if-else%E8%AF%AD%E5%8F%A5"><span class="nav-number">1.2.3.1.1.</span> <span class="nav-text">if-else语句</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#switch-case%E8%AF%AD%E5%8F%A5"><span class="nav-number">1.2.3.1.2.</span> <span class="nav-text">switch-case语句</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5"><span class="nav-number">1.2.3.2.</span> <span class="nav-text">循环语句</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#while%E5%BE%AA%E7%8E%AF"><span class="nav-number">1.2.3.2.1.</span> <span class="nav-text">while循环</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#do-while%E5%BE%AA%E7%8E%AF"><span class="nav-number">1.2.3.2.2.</span> <span class="nav-text">do-while循环</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#for%E5%BE%AA%E7%8E%AF"><span class="nav-number">1.2.3.2.3.</span> <span class="nav-text">for循环</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B7%B3%E8%BD%AC%E8%AF%AD%E5%8F%A5"><span class="nav-number">1.2.3.3.</span> <span class="nav-text">跳转语句</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#break%E8%AF%AD%E5%8F%A5"><span class="nav-number">1.2.3.3.1.</span> <span class="nav-text">break语句</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#continue%E8%AF%AD%E5%8F%A5"><span class="nav-number">1.2.3.3.2.</span> <span class="nav-text">continue语句</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#goto%E8%AF%AD%E5%8F%A5"><span class="nav-number">1.2.3.3.3.</span> <span class="nav-text">goto语句</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%8D%E5%90%88%E8%AF%AD%E5%8F%A5%E4%B8%8E%E5%9D%97%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="nav-number">1.2.3.4.</span> <span class="nav-text">复合语句与块作用域</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-%E5%87%BD%E6%95%B0"><span class="nav-number">1.2.4.</span> <span class="nav-text">2.4 函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89%E4%B8%8E%E5%A3%B0%E6%98%8E"><span class="nav-number">1.2.4.1.</span> <span class="nav-text">函数定义与声明</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89"><span class="nav-number">1.2.4.1.1.</span> <span class="nav-text">函数定义</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E"><span class="nav-number">1.2.4.1.2.</span> <span class="nav-text">函数声明</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%EF%BC%9A%E5%80%BC%E4%BC%A0%E9%80%92"><span class="nav-number">1.2.4.2.</span> <span class="nav-text">参数传递：值传递</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%94%E5%9B%9E%E5%80%BC%E4%B8%8Ereturn%E8%AF%AD%E5%8F%A5"><span class="nav-number">1.2.4.3.</span> <span class="nav-text">返回值与return语句</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E4%B8%8E%E9%80%92%E5%BD%92"><span class="nav-number">1.2.4.4.</span> <span class="nav-text">函数调用与递归</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8"><span class="nav-number">1.2.4.4.1.</span> <span class="nav-text">函数调用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%80%92%E5%BD%92%E5%87%BD%E6%95%B0"><span class="nav-number">1.2.4.4.2.</span> <span class="nav-text">递归函数</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B"><span class="nav-number">1.2.4.5.</span> <span class="nav-text">函数原型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E5%AD%98%E5%82%A8%E7%B1%BB%E5%88%AB"><span class="nav-number">1.2.4.6.</span> <span class="nav-text">作用域与存储类别</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="nav-number">1.2.4.6.1.</span> <span class="nav-text">作用域</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E7%B1%BB%E5%88%AB"><span class="nav-number">1.2.4.6.2.</span> <span class="nav-text">存储类别</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-%E6%95%B0%E7%BB%84%E4%B8%8E%E6%8C%87%E9%92%88"><span class="nav-number">1.2.5.</span> <span class="nav-text">2.5 数组与指针</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%8E%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="nav-number">1.2.5.1.</span> <span class="nav-text">一维数组与多维数组</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="nav-number">1.2.5.1.1.</span> <span class="nav-text">一维数组</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="nav-number">1.2.5.1.2.</span> <span class="nav-text">多维数组</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E8%AE%BF%E9%97%AE"><span class="nav-number">1.2.5.2.</span> <span class="nav-text">数组初始化与访问</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E8%AE%BF%E9%97%AE"><span class="nav-number">1.2.5.2.1.</span> <span class="nav-text">数组访问</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E9%81%8D%E5%8E%86"><span class="nav-number">1.2.5.2.2.</span> <span class="nav-text">数组遍历</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8C%87%E9%92%88%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="nav-number">1.2.5.3.</span> <span class="nav-text">指针概念与基本操作</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8C%87%E9%92%88%E5%AE%9A%E4%B9%89"><span class="nav-number">1.2.5.3.1.</span> <span class="nav-text">指针定义</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8F%96%E5%9C%B0%E5%9D%80%E4%B8%8E%E8%A7%A3%E5%BC%95%E7%94%A8"><span class="nav-number">1.2.5.3.2.</span> <span class="nav-text">取地址与解引用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BF%AE%E6%94%B9%E6%8C%87%E9%92%88%E6%8C%87%E5%90%91%E7%9A%84%E5%80%BC"><span class="nav-number">1.2.5.3.3.</span> <span class="nav-text">修改指针指向的值</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%A9%BA%E6%8C%87%E9%92%88"><span class="nav-number">1.2.5.3.4.</span> <span class="nav-text">空指针</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8C%87%E9%92%88%E4%B8%8E%E6%95%B0%E7%BB%84%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-number">1.2.5.4.</span> <span class="nav-text">指针与数组的关系</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8C%87%E9%92%88%E4%B8%8E%E5%87%BD%E6%95%B0"><span class="nav-number">1.2.5.5.</span> <span class="nav-text">指针与函数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8C%87%E9%92%88%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0"><span class="nav-number">1.2.5.5.1.</span> <span class="nav-text">指针作为函数参数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E6%8C%87%E9%92%88"><span class="nav-number">1.2.5.5.2.</span> <span class="nav-text">函数返回指针</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="nav-number">1.2.5.6.</span> <span class="nav-text">动态内存分配</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#malloc%E5%87%BD%E6%95%B0"><span class="nav-number">1.2.5.6.1.</span> <span class="nav-text">malloc函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#calloc%E5%87%BD%E6%95%B0"><span class="nav-number">1.2.5.6.2.</span> <span class="nav-text">calloc函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#realloc%E5%87%BD%E6%95%B0"><span class="nav-number">1.2.5.6.3.</span> <span class="nav-text">realloc函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#free%E5%87%BD%E6%95%B0"><span class="nav-number">1.2.5.6.4.</span> <span class="nav-text">free函数</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8C%87%E9%92%88%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97"><span class="nav-number">1.2.5.7.</span> <span class="nav-text">指针算术运算</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-6-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86"><span class="nav-number">1.2.6.</span> <span class="nav-text">2.6 字符串处理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%AD%98%E5%82%A8"><span class="nav-number">1.2.6.1.</span> <span class="nav-text">字符串表示与存储</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%87%E5%87%86%E5%BA%93%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0"><span class="nav-number">1.2.6.2.</span> <span class="nav-text">标准库字符串函数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#strlen%E5%87%BD%E6%95%B0"><span class="nav-number">1.2.6.2.1.</span> <span class="nav-text">strlen函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#strcpy%E5%87%BD%E6%95%B0"><span class="nav-number">1.2.6.2.2.</span> <span class="nav-text">strcpy函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#strcat%E5%87%BD%E6%95%B0"><span class="nav-number">1.2.6.2.3.</span> <span class="nav-text">strcat函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#strcmp%E5%87%BD%E6%95%B0"><span class="nav-number">1.2.6.2.4.</span> <span class="nav-text">strcmp函数</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8C%87%E9%92%88"><span class="nav-number">1.2.6.3.</span> <span class="nav-text">字符数组与字符串指针</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA"><span class="nav-number">1.2.6.4.</span> <span class="nav-text">字符串输入输出</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BE%93%E5%87%BA%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">1.2.6.4.1.</span> <span class="nav-text">输出字符串</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BE%93%E5%85%A5%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">1.2.6.4.2.</span> <span class="nav-text">输入字符串</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-7-%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E8%81%94%E5%90%88%E4%BD%93"><span class="nav-number">1.2.7.</span> <span class="nav-text">2.7 结构体与联合体</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E5%AE%9A%E4%B9%89%E4%B8%8E%E4%BD%BF%E7%94%A8"><span class="nav-number">1.2.7.1.</span> <span class="nav-text">结构体定义与使用</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E5%AE%9A%E4%B9%89"><span class="nav-number">1.2.7.1.1.</span> <span class="nav-text">结构体定义</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E%E4%B8%8E%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">1.2.7.1.2.</span> <span class="nav-text">结构体变量声明与初始化</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AE%BF%E9%97%AE%E7%BB%93%E6%9E%84%E4%BD%93%E6%88%90%E5%91%98"><span class="nav-number">1.2.7.1.3.</span> <span class="nav-text">访问结构体成员</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E6%95%B0%E7%BB%84%E4%B8%8E%E6%8C%87%E9%92%88"><span class="nav-number">1.2.7.2.</span> <span class="nav-text">结构体数组与指针</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E6%95%B0%E7%BB%84"><span class="nav-number">1.2.7.2.1.</span> <span class="nav-text">结构体数组</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E6%8C%87%E9%92%88"><span class="nav-number">1.2.7.2.2.</span> <span class="nav-text">结构体指针</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%81%94%E5%90%88%E4%BD%93%EF%BC%88Union%EF%BC%89"><span class="nav-number">1.2.7.3.</span> <span class="nav-text">联合体（Union）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%81%94%E5%90%88%E4%BD%93%E5%AE%9A%E4%B9%89"><span class="nav-number">1.2.7.3.1.</span> <span class="nav-text">联合体定义</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%81%94%E5%90%88%E4%BD%93%E4%BD%BF%E7%94%A8"><span class="nav-number">1.2.7.3.2.</span> <span class="nav-text">联合体使用</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B%EF%BC%88Enum%EF%BC%89"><span class="nav-number">1.2.7.4.</span> <span class="nav-text">枚举类型（Enum）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9E%9A%E4%B8%BE%E5%AE%9A%E4%B9%89"><span class="nav-number">1.2.7.4.1.</span> <span class="nav-text">枚举定义</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9E%9A%E4%B8%BE%E4%BD%BF%E7%94%A8"><span class="nav-number">1.2.7.4.2.</span> <span class="nav-text">枚举使用</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%8D%E5%9F%9F"><span class="nav-number">1.2.7.5.</span> <span class="nav-text">位域</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-C-%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B8%8E%E6%89%A9%E5%B1%95"><span class="nav-number">1.3.</span> <span class="nav-text">3. C++语言基础与扩展</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-C-%E5%AF%B9C%E7%9A%84%E6%89%A9%E5%B1%95"><span class="nav-number">1.3.1.</span> <span class="nav-text">3.1 C++对C的扩展</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%EF%BC%88namespace%EF%BC%89"><span class="nav-number">1.3.1.1.</span> <span class="nav-text">命名空间（namespace）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81%EF%BC%9Acin%E3%80%81cout"><span class="nav-number">1.3.1.2.</span> <span class="nav-text">输入输出流：cin、cout</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%95%E7%94%A8%EF%BC%88Reference%EF%BC%89"><span class="nav-number">1.3.1.3.</span> <span class="nav-text">引用（Reference）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%EF%BC%88Function-Overloading%EF%BC%89"><span class="nav-number">1.3.1.4.</span> <span class="nav-text">函数重载（Function Overloading）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0%EF%BC%88Inline-Function%EF%BC%89"><span class="nav-number">1.3.1.5.</span> <span class="nav-text">内联函数（Inline Function）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0%E4%B8%8E%E5%8D%A0%E4%BD%8D%E5%8F%82%E6%95%B0"><span class="nav-number">1.3.1.6.</span> <span class="nav-text">函数默认参数与占位参数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#const%E4%BF%AE%E9%A5%B0%E7%AC%A6%E5%A2%9E%E5%BC%BA"><span class="nav-number">1.3.1.7.</span> <span class="nav-text">const修饰符增强</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F%E8%A7%A3%E6%9E%90%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">1.3.1.8.</span> <span class="nav-text">作用域解析运算符::</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80"><span class="nav-number">1.3.2.</span> <span class="nav-text">3.2 面向对象编程基础</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1%E6%A6%82%E5%BF%B5"><span class="nav-number">1.3.2.1.</span> <span class="nav-text">类与对象概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B0%81%E8%A3%85"><span class="nav-number">1.3.2.2.</span> <span class="nav-text">封装</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%8E%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="nav-number">1.3.2.3.</span> <span class="nav-text">构造函数与析构函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%8E%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">1.3.2.4.</span> <span class="nav-text">拷贝构造函数与赋值运算符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E6%88%90%E5%91%98"><span class="nav-number">1.3.2.5.</span> <span class="nav-text">静态成员</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#this%E6%8C%87%E9%92%88"><span class="nav-number">1.3.2.6.</span> <span class="nav-text">this指针</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81"><span class="nav-number">1.3.3.</span> <span class="nav-text">3.3 继承与多态</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF%E7%9A%84%E6%A6%82%E5%BF%B5%E4%B8%8E%E8%AF%AD%E6%B3%95"><span class="nav-number">1.3.3.1.</span> <span class="nav-text">继承的概念与语法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E7%B1%BB%E4%B8%8E%E6%B4%BE%E7%94%9F%E7%B1%BB"><span class="nav-number">1.3.3.2.</span> <span class="nav-text">基类与派生类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E4%B8%8E%E7%BB%A7%E6%89%BF%E6%96%B9%E5%BC%8F"><span class="nav-number">1.3.3.3.</span> <span class="nav-text">访问控制与继承方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%9A%E6%80%81%E6%80%A7%EF%BC%9A%E9%9D%99%E6%80%81%E5%A4%9A%E6%80%81%E4%B8%8E%E5%8A%A8%E6%80%81%E5%A4%9A%E6%80%81"><span class="nav-number">1.3.3.4.</span> <span class="nav-text">多态性：静态多态与动态多态</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0%EF%BC%88Virtual-Function%EF%BC%89"><span class="nav-number">1.3.3.5.</span> <span class="nav-text">虚函数（Virtual Function）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0%E4%B8%8E%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="nav-number">1.3.3.6.</span> <span class="nav-text">纯虚函数与抽象类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%99%9A%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="nav-number">1.3.3.7.</span> <span class="nav-text">虚析构函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A6%86%E7%9B%96%EF%BC%88Override%EF%BC%89%E4%B8%8E%E9%9A%90%E8%97%8F%EF%BC%88Hide%EF%BC%89"><span class="nav-number">1.3.3.8.</span> <span class="nav-text">覆盖（Override）与隐藏（Hide）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E4%B8%8E%E7%B1%BB%E6%A8%A1%E6%9D%BF"><span class="nav-number">1.3.4.</span> <span class="nav-text">3.4 函数模板与类模板</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B%E6%A6%82%E5%BF%B5"><span class="nav-number">1.3.4.1.</span> <span class="nav-text">泛型编程概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E5%AE%9A%E4%B9%89%E4%B8%8E%E4%BD%BF%E7%94%A8"><span class="nav-number">1.3.4.2.</span> <span class="nav-text">函数模板定义与使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E6%A8%A1%E6%9D%BF%E5%AE%9A%E4%B9%89%E4%B8%8E%E4%BD%BF%E7%94%A8"><span class="nav-number">1.3.4.3.</span> <span class="nav-text">类模板定义与使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF%E7%89%B9%E5%8C%96"><span class="nav-number">1.3.4.4.</span> <span class="nav-text">模板特化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF%E5%88%86%E7%A6%BB%E7%BC%96%E8%AF%91%E9%97%AE%E9%A2%98"><span class="nav-number">1.3.4.5.</span> <span class="nav-text">模板分离编译问题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-STL%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93"><span class="nav-number">1.3.5.</span> <span class="nav-text">3.5 STL标准模板库</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#STL%E7%BB%84%E4%BB%B6%E6%A6%82%E8%BF%B0%EF%BC%9A%E5%AE%B9%E5%99%A8%E3%80%81%E7%AE%97%E6%B3%95%E3%80%81%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="nav-number">1.3.5.1.</span> <span class="nav-text">STL组件概述：容器、算法、迭代器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E5%AE%B9%E5%99%A8%EF%BC%9Avector%E3%80%81list%E3%80%81deque%E3%80%81map%E3%80%81set"><span class="nav-number">1.3.5.2.</span> <span class="nav-text">常用容器：vector、list、deque、map、set</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-vector%EF%BC%88%E5%90%91%E9%87%8F%EF%BC%89"><span class="nav-number">1.3.5.2.1.</span> <span class="nav-text">1. vector（向量）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-list%EF%BC%88%E9%93%BE%E8%A1%A8%EF%BC%89"><span class="nav-number">1.3.5.2.2.</span> <span class="nav-text">2. list（链表）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-deque%EF%BC%88%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97%EF%BC%89"><span class="nav-number">1.3.5.2.3.</span> <span class="nav-text">3. deque（双端队列）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-map%EF%BC%88%E6%98%A0%E5%B0%84%EF%BC%89"><span class="nav-number">1.3.5.2.4.</span> <span class="nav-text">4. map（映射）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-set%EF%BC%88%E9%9B%86%E5%90%88%EF%BC%89"><span class="nav-number">1.3.5.2.5.</span> <span class="nav-text">5. set（集合）</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%BD%BF%E7%94%A8"><span class="nav-number">1.3.5.3.</span> <span class="nav-text">迭代器使用</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.3.5.3.1.</span> <span class="nav-text">迭代器类型</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%93%8D%E4%BD%9C"><span class="nav-number">1.3.5.3.2.</span> <span class="nav-text">迭代器操作</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%AE%97%E6%B3%95%E7%9A%84%E7%BB%93%E5%90%88%E4%BD%BF%E7%94%A8"><span class="nav-number">1.3.5.3.3.</span> <span class="nav-text">迭代器与算法的结合使用</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95%EF%BC%9Asort%E3%80%81find%E3%80%81for-each"><span class="nav-number">1.3.5.4.</span> <span class="nav-text">常用算法：sort、find、for_each</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-sort%E7%AE%97%E6%B3%95"><span class="nav-number">1.3.5.4.1.</span> <span class="nav-text">1. sort算法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-find%E7%AE%97%E6%B3%95"><span class="nav-number">1.3.5.4.2.</span> <span class="nav-text">2. find算法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-for-each%E7%AE%97%E6%B3%95"><span class="nav-number">1.3.5.4.3.</span> <span class="nav-text">3. for_each算法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1%EF%BC%88Functor%EF%BC%89"><span class="nav-number">1.3.5.5.</span> <span class="nav-text">函数对象（Functor）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">1.3.5.6.</span> <span class="nav-text">Lambda表达式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-6-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="nav-number">1.3.6.</span> <span class="nav-text">3.6 异常处理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-7-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="nav-number">1.3.7.</span> <span class="nav-text">3.7 智能指针</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E5%AE%9E%E7%94%A8%E6%8A%80%E8%83%BD"><span class="nav-number">1.4.</span> <span class="nav-text">4. 高级特性与实用技能</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="nav-number">1.4.1.</span> <span class="nav-text">4.1 内存管理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA"><span class="nav-number">1.4.1.1.</span> <span class="nav-text">内存分区</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A0%88%E5%8C%BA%EF%BC%88Stack%EF%BC%89"><span class="nav-number">1.4.1.1.1.</span> <span class="nav-text">栈区（Stack）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A0%86%E5%8C%BA%EF%BC%88Heap%EF%BC%89"><span class="nav-number">1.4.1.1.2.</span> <span class="nav-text">堆区（Heap）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%A8%E5%B1%80-%E9%9D%99%E6%80%81%E5%AD%98%E5%82%A8%E5%8C%BA"><span class="nav-number">1.4.1.1.3.</span> <span class="nav-text">全局&#x2F;静态存储区</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B8%B8%E9%87%8F%E5%AD%98%E5%82%A8%E5%8C%BA"><span class="nav-number">1.4.1.1.4.</span> <span class="nav-text">常量存储区</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%A3%80%E6%B5%8B"><span class="nav-number">1.4.1.2.</span> <span class="nav-text">内存泄漏检测</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E5%9C%BA%E6%99%AF"><span class="nav-number">1.4.1.2.1.</span> <span class="nav-text">常见的内存泄漏场景</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%A3%80%E6%B5%8B%E5%B7%A5%E5%85%B7"><span class="nav-number">1.4.1.2.2.</span> <span class="nav-text">内存泄漏检测工具</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#RAII%E5%8E%9F%E5%88%99"><span class="nav-number">1.4.1.3.</span> <span class="nav-text">RAII原则</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#RAII%E7%9A%84%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3"><span class="nav-number">1.4.1.3.1.</span> <span class="nav-text">RAII的核心思想</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#RAII%E7%9A%84%E4%BC%98%E5%8A%BF"><span class="nav-number">1.4.1.3.2.</span> <span class="nav-text">RAII的优势</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#RAII%E7%9A%84%E5%85%B8%E5%9E%8B%E5%BA%94%E7%94%A8"><span class="nav-number">1.4.1.3.3.</span> <span class="nav-text">RAII的典型应用</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7"><span class="nav-number">1.4.1.4.</span> <span class="nav-text">析构函数的重要性</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">1.4.1.4.1.</span> <span class="nav-text">析构函数的作用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.4.1.4.2.</span> <span class="nav-text">常见的析构函数实现</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-number">1.4.1.4.3.</span> <span class="nav-text">注意事项</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99"><span class="nav-number">1.4.2.</span> <span class="nav-text">4.2 面向对象设计原则</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B0%81%E8%A3%85%E3%80%81%E7%BB%A7%E6%89%BF%E3%80%81%E5%A4%9A%E6%80%81%E5%8E%9F%E5%88%99"><span class="nav-number">1.4.2.1.</span> <span class="nav-text">封装、继承、多态原则</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B0%81%E8%A3%85%EF%BC%88Encapsulation%EF%BC%89"><span class="nav-number">1.4.2.1.1.</span> <span class="nav-text">封装（Encapsulation）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF%EF%BC%88Inheritance%EF%BC%89"><span class="nav-number">1.4.2.1.2.</span> <span class="nav-text">继承（Inheritance）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A4%9A%E6%80%81%EF%BC%88Polymorphism%EF%BC%89"><span class="nav-number">1.4.2.1.3.</span> <span class="nav-text">多态（Polymorphism）</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SOLID%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99"><span class="nav-number">1.4.2.2.</span> <span class="nav-text">SOLID设计原则</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%8E%9F%E5%88%99%EF%BC%88Single-Responsibility-Principle-SRP%EF%BC%89"><span class="nav-number">1.4.2.2.1.</span> <span class="nav-text">单一职责原则（Single Responsibility Principle, SRP）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BC%80%E6%94%BE%E5%B0%81%E9%97%AD%E5%8E%9F%E5%88%99%EF%BC%88Open-Closed-Principle-OCP%EF%BC%89"><span class="nav-number">1.4.2.2.2.</span> <span class="nav-text">开放封闭原则（Open-Closed Principle, OCP）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%87%8C%E6%B0%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99%EF%BC%88Liskov-Substitution-Principle-LSP%EF%BC%89"><span class="nav-number">1.4.2.2.3.</span> <span class="nav-text">里氏替换原则（Liskov Substitution Principle, LSP）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99%EF%BC%88Interface-Segregation-Principle-ISP%EF%BC%89"><span class="nav-number">1.4.2.2.4.</span> <span class="nav-text">接口隔离原则（Interface Segregation Principle, ISP）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BE%9D%E8%B5%96%E5%80%92%E7%BD%AE%E5%8E%9F%E5%88%99%EF%BC%88Dependency-Inversion-Principle-DIP%EF%BC%89"><span class="nav-number">1.4.2.2.5.</span> <span class="nav-text">依赖倒置原则（Dependency Inversion Principle, DIP）</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%84%E5%90%88%E4%BC%98%E4%BA%8E%E7%BB%A7%E6%89%BF"><span class="nav-number">1.4.2.3.</span> <span class="nav-text">组合优于继承</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BB%84%E5%90%88%E7%9A%84%E4%BC%98%E5%8A%BF"><span class="nav-number">1.4.2.3.1.</span> <span class="nav-text">组合的优势</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BB%84%E5%90%88%E7%A4%BA%E4%BE%8B"><span class="nav-number">1.4.2.3.2.</span> <span class="nav-text">组合示例</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%9F%BA%E7%A1%80"><span class="nav-number">1.4.2.4.</span> <span class="nav-text">设计模式基础</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.4.2.4.1.</span> <span class="nav-text">创建型模式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.4.2.4.2.</span> <span class="nav-text">结构型模式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.4.2.4.3.</span> <span class="nav-text">行为型模式</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C"><span class="nav-number">1.4.3.</span> <span class="nav-text">4.3 文件操作</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#C%E9%A3%8E%E6%A0%BC%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C"><span class="nav-number">1.4.3.1.</span> <span class="nav-text">C风格文件操作</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E6%89%93%E5%BC%80%E4%B8%8E%E5%85%B3%E9%97%AD"><span class="nav-number">1.4.3.1.1.</span> <span class="nav-text">文件打开与关闭</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E5%86%99%E5%85%A5%E6%93%8D%E4%BD%9C"><span class="nav-number">1.4.3.1.2.</span> <span class="nav-text">文件写入操作</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E6%93%8D%E4%BD%9C"><span class="nav-number">1.4.3.1.3.</span> <span class="nav-text">文件读取操作</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E4%BD%8D%E7%BD%AE%E6%93%8D%E4%BD%9C"><span class="nav-number">1.4.3.1.4.</span> <span class="nav-text">文件位置操作</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#C-%E9%A3%8E%E6%A0%BC%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C"><span class="nav-number">1.4.3.2.</span> <span class="nav-text">C++风格文件操作</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%BB%E8%A6%81%E7%9A%84%E6%96%87%E4%BB%B6%E6%B5%81%E7%B1%BB"><span class="nav-number">1.4.3.2.1.</span> <span class="nav-text">主要的文件流类</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E6%89%93%E5%BC%80%E4%B8%8E%E5%85%B3%E9%97%AD-2"><span class="nav-number">1.4.3.2.2.</span> <span class="nav-text">文件打开与关闭</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E6%89%93%E5%BC%80%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.4.3.2.3.</span> <span class="nav-text">文件打开模式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E5%86%99%E5%85%A5%E6%93%8D%E4%BD%9C-2"><span class="nav-number">1.4.3.2.4.</span> <span class="nav-text">文件写入操作</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E6%93%8D%E4%BD%9C-2"><span class="nav-number">1.4.3.2.5.</span> <span class="nav-text">文件读取操作</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E4%BD%8D%E7%BD%AE%E6%93%8D%E4%BD%9C-2"><span class="nav-number">1.4.3.2.6.</span> <span class="nav-text">文件位置操作</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6%E4%B8%8E%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6"><span class="nav-number">1.4.3.3.</span> <span class="nav-text">二进制文件与文本文件</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6"><span class="nav-number">1.4.3.3.1.</span> <span class="nav-text">文本文件</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6"><span class="nav-number">1.4.3.3.2.</span> <span class="nav-text">二进制文件</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99%E6%93%8D%E4%BD%9C%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="nav-number">1.4.3.4.</span> <span class="nav-text">文件读写操作的最佳实践</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B"><span class="nav-number">1.4.4.</span> <span class="nav-text">4.4 多线程编程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#C-11%E7%BA%BF%E7%A8%8B%E5%BA%93"><span class="nav-number">1.4.4.1.</span> <span class="nav-text">C++11线程库</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%BB%E8%A6%81%E7%BB%84%E4%BB%B6"><span class="nav-number">1.4.4.1.1.</span> <span class="nav-text">主要组件</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%88%9B%E5%BB%BA%E4%B8%8E%E7%AE%A1%E7%90%86"><span class="nav-number">1.4.4.2.</span> <span class="nav-text">线程创建与管理</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E7%BA%BF%E7%A8%8B%E5%88%9B%E5%BB%BA"><span class="nav-number">1.4.4.2.1.</span> <span class="nav-text">基本线程创建</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B"><span class="nav-number">1.4.4.2.2.</span> <span class="nav-text">使用函数对象创建线程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B"><span class="nav-number">1.4.4.2.3.</span> <span class="nav-text">使用lambda表达式创建线程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BC%A0%E9%80%92%E5%8F%82%E6%95%B0%E7%BB%99%E7%BA%BF%E7%A8%8B%E5%87%BD%E6%95%B0"><span class="nav-number">1.4.4.2.4.</span> <span class="nav-text">传递参数给线程函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%88%86%E7%A6%BB"><span class="nav-number">1.4.4.2.5.</span> <span class="nav-text">线程分离</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%A7%BB%E5%8A%A8"><span class="nav-number">1.4.4.2.6.</span> <span class="nav-text">线程移动</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%92%E6%96%A5%E9%94%81%E4%B8%8E%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F"><span class="nav-number">1.4.4.3.</span> <span class="nav-text">互斥锁与条件变量</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E4%BA%92%E6%96%A5%E9%94%81%E4%BD%BF%E7%94%A8"><span class="nav-number">1.4.4.3.1.</span> <span class="nav-text">基本互斥锁使用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8std-lock-guard%EF%BC%88RAII%E9%A3%8E%E6%A0%BC%E9%94%81%EF%BC%89"><span class="nav-number">1.4.4.3.2.</span> <span class="nav-text">使用std::lock_guard（RAII风格锁）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8std-unique-lock%EF%BC%88%E6%9B%B4%E7%81%B5%E6%B4%BB%E7%9A%84%E9%94%81%EF%BC%89"><span class="nav-number">1.4.4.3.3.</span> <span class="nav-text">使用std::unique_lock（更灵活的锁）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%AD%BB%E9%94%81%E9%97%AE%E9%A2%98%E4%B8%8E%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="nav-number">1.4.4.3.4.</span> <span class="nav-text">死锁问题与解决方案</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F"><span class="nav-number">1.4.4.3.5.</span> <span class="nav-text">条件变量</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C"><span class="nav-number">1.4.4.4.</span> <span class="nav-text">原子操作</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%AD%90%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.4.4.4.1.</span> <span class="nav-text">基本原子类型</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8E%9F%E5%AD%90%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%85%B6%E4%BB%96%E6%93%8D%E4%BD%9C"><span class="nav-number">1.4.4.4.2.</span> <span class="nav-text">原子类型的其他操作</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E5%BA%8F"><span class="nav-number">1.4.4.4.3.</span> <span class="nav-text">内存序</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="nav-number">1.4.4.5.</span> <span class="nav-text">线程池</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%AE%80%E5%8D%95%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.4.4.5.1.</span> <span class="nav-text">简单线程池实现</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="nav-number">1.4.4.6.</span> <span class="nav-text">多线程编程最佳实践</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-5-%E6%A8%A1%E6%9D%BF%E5%85%83%E7%BC%96%E7%A8%8B"><span class="nav-number">1.4.5.</span> <span class="nav-text">4.5 模板元编程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%96%E8%AF%91%E6%9C%9F%E8%AE%A1%E7%AE%97"><span class="nav-number">1.4.5.1.</span> <span class="nav-text">编译期计算</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BC%96%E8%AF%91%E6%9C%9F%E5%B8%B8%E9%87%8F%E8%AE%A1%E7%AE%97"><span class="nav-number">1.4.5.1.1.</span> <span class="nav-text">编译期常量计算</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8constexpr%E5%87%BD%E6%95%B0%EF%BC%88C-11%E5%8F%8A%E6%9B%B4%E9%AB%98%E7%89%88%E6%9C%AC%EF%BC%89"><span class="nav-number">1.4.5.1.2.</span> <span class="nav-text">使用constexpr函数（C++11及更高版本）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BC%96%E8%AF%91%E6%9C%9F%E7%B1%BB%E5%9E%8B%E9%80%89%E6%8B%A9"><span class="nav-number">1.4.5.1.3.</span> <span class="nav-text">编译期类型选择</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E7%89%B9%E5%BE%81%EF%BC%88Type-Traits%EF%BC%89"><span class="nav-number">1.4.5.2.</span> <span class="nav-text">类型特征（Type Traits）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E7%89%B9%E5%BE%81"><span class="nav-number">1.4.5.2.1.</span> <span class="nav-text">基本类型特征</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B%E7%89%B9%E5%BE%81"><span class="nav-number">1.4.5.2.2.</span> <span class="nav-text">自定义类型特征</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E7%B1%BB%E5%9E%8B%E7%89%B9%E5%BE%81%E8%BF%9B%E8%A1%8C%E7%BC%96%E8%AF%91%E6%9C%9F%E5%86%B3%E7%AD%96"><span class="nav-number">1.4.5.2.3.</span> <span class="nav-text">使用类型特征进行编译期决策</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E6%A8%A1%E6%9D%BF"><span class="nav-number">1.4.5.3.</span> <span class="nav-text">可变参数模板</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E6%A8%A1%E6%9D%BF"><span class="nav-number">1.4.5.3.1.</span> <span class="nav-text">基本可变参数模板</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E6%A8%A1%E6%9D%BF%E7%B1%BB"><span class="nav-number">1.4.5.3.2.</span> <span class="nav-text">可变参数模板类</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E6%A8%A1%E6%9D%BF%E5%AE%9E%E7%8E%B0%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.4.5.3.3.</span> <span class="nav-text">使用可变参数模板实现工厂模式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91"><span class="nav-number">1.4.5.3.4.</span> <span class="nav-text">完美转发</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SFINAE%E6%8A%80%E6%9C%AF"><span class="nav-number">1.4.5.4.</span> <span class="nav-text">SFINAE技术</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9F%BA%E6%9C%ACSFINAE%E7%A4%BA%E4%BE%8B"><span class="nav-number">1.4.5.4.1.</span> <span class="nav-text">基本SFINAE示例</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8std-void-t%EF%BC%88C-17%EF%BC%89"><span class="nav-number">1.4.5.4.2.</span> <span class="nav-text">使用std::void_t（C++17）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#SFINAE%E5%9C%A8%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8"><span class="nav-number">1.4.5.4.3.</span> <span class="nav-text">SFINAE在函数重载中的应用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A3%80%E6%B5%8B%E6%A8%A1%E6%9D%BF%E5%AE%9E%E4%BE%8B%E5%8C%96%E7%9A%84%E6%9C%89%E6%95%88%E6%80%A7"><span class="nav-number">1.4.5.4.4.</span> <span class="nav-text">检测模板实例化的有效性</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF%E5%85%83%E7%BC%96%E7%A8%8B%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="nav-number">1.4.5.5.</span> <span class="nav-text">模板元编程最佳实践</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-6-C-%E6%96%B0%E6%A0%87%E5%87%86%E7%89%B9%E6%80%A7"><span class="nav-number">1.4.6.</span> <span class="nav-text">4.6 C++新标准特性</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#C-11%E6%96%B0%E7%89%B9%E6%80%A7"><span class="nav-number">1.4.6.1.</span> <span class="nav-text">C++11新特性</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%87%AA%E5%8A%A8%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC%EF%BC%88auto%E5%92%8Cdecltype%EF%BC%89"><span class="nav-number">1.4.6.1.1.</span> <span class="nav-text">自动类型推导（auto和decltype）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%8C%83%E5%9B%B4for%E5%BE%AA%E7%8E%AF"><span class="nav-number">1.4.6.1.2.</span> <span class="nav-text">范围for循环</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F-2"><span class="nav-number">1.4.6.1.3.</span> <span class="nav-text">Lambda表达式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="nav-number">1.4.6.1.4.</span> <span class="nav-text">智能指针</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E5%92%8C%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89"><span class="nav-number">1.4.6.1.5.</span> <span class="nav-text">右值引用和移动语义</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#nullptr"><span class="nav-number">1.4.6.1.6.</span> <span class="nav-text">nullptr</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#C-14%E6%96%B0%E7%89%B9%E6%80%A7"><span class="nav-number">1.4.6.2.</span> <span class="nav-text">C++14新特性</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8BLambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">1.4.6.2.1.</span> <span class="nav-text">泛型Lambda表达式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC"><span class="nav-number">1.4.6.2.2.</span> <span class="nav-text">返回类型推导</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AD%97%E9%9D%A2%E9%87%8F%E5%92%8C%E6%95%B0%E5%AD%97%E5%88%86%E9%9A%94%E7%AC%A6"><span class="nav-number">1.4.6.2.3.</span> <span class="nav-text">二进制字面量和数字分隔符</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#std-make-unique"><span class="nav-number">1.4.6.2.4.</span> <span class="nav-text">std::make_unique</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#C-17%E6%96%B0%E7%89%B9%E6%80%A7"><span class="nav-number">1.4.6.3.</span> <span class="nav-text">C++17新特性</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%E5%8C%96%E7%BB%91%E5%AE%9A"><span class="nav-number">1.4.6.3.1.</span> <span class="nav-text">结构化绑定</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#if-switch%E5%88%9D%E5%A7%8B%E5%8C%96%E8%AF%AD%E5%8F%A5"><span class="nav-number">1.4.6.3.2.</span> <span class="nav-text">if&#x2F;switch初始化语句</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8A%98%E5%8F%A0%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">1.4.6.3.3.</span> <span class="nav-text">折叠表达式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#std-optional"><span class="nav-number">1.4.6.3.4.</span> <span class="nav-text">std::optional</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#std-variant"><span class="nav-number">1.4.6.3.5.</span> <span class="nav-text">std::variant</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#std-any"><span class="nav-number">1.4.6.3.6.</span> <span class="nav-text">std::any</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#C-20%E6%96%B0%E7%89%B9%E6%80%A7"><span class="nav-number">1.4.6.4.</span> <span class="nav-text">C++20新特性</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A6%82%E5%BF%B5%EF%BC%88Concepts%EF%BC%89"><span class="nav-number">1.4.6.4.1.</span> <span class="nav-text">概念（Concepts）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%8C%83%E5%9B%B4%E5%BA%93%EF%BC%88Ranges%EF%BC%89"><span class="nav-number">1.4.6.4.2.</span> <span class="nav-text">范围库（Ranges）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8D%8F%E7%A8%8B%EF%BC%88Coroutines%EF%BC%89"><span class="nav-number">1.4.6.4.3.</span> <span class="nav-text">协程（Coroutines）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A8%A1%E5%9D%97%EF%BC%88Modules%EF%BC%89"><span class="nav-number">1.4.6.4.4.</span> <span class="nav-text">模块（Modules）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%89%E8%B7%AF%E6%AF%94%E8%BE%83%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%88Spaceship-Operator%EF%BC%89"><span class="nav-number">1.4.6.4.5.</span> <span class="nav-text">三路比较运算符（Spaceship Operator）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BA%A6%E6%9D%9F%E4%B8%8E%E6%A6%82%E5%BF%B5%E7%9A%84%E7%BB%93%E5%90%88"><span class="nav-number">1.4.6.4.6.</span> <span class="nav-text">约束与概念的结合</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%89%E6%8B%A9%E5%90%88%E9%80%82%E7%9A%84C-%E6%A0%87%E5%87%86%E7%89%88%E6%9C%AC"><span class="nav-number">1.4.6.5.</span> <span class="nav-text">选择合适的C++标准版本</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%90%E6%AD%A5%E9%87%87%E7%94%A8%E6%96%B0%E7%89%B9%E6%80%A7%E7%9A%84%E7%AD%96%E7%95%A5"><span class="nav-number">1.4.6.6.</span> <span class="nav-text">逐步采用新特性的策略</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5%E4%B8%8E%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98"><span class="nav-number">1.5.</span> <span class="nav-text">5. 编程实践与常见问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83"><span class="nav-number">1.5.1.</span> <span class="nav-text">5.1 编码规范</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%91%BD%E5%90%8D%E7%BA%A6%E5%AE%9A"><span class="nav-number">1.5.1.1.</span> <span class="nav-text">命名约定</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E6%A0%BC%E5%BC%8F"><span class="nav-number">1.5.1.2.</span> <span class="nav-text">代码格式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B3%A8%E9%87%8A%E8%A7%84%E8%8C%83"><span class="nav-number">1.5.1.3.</span> <span class="nav-text">注释规范</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="nav-number">1.5.1.4.</span> <span class="nav-text">最佳实践</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7"><span class="nav-number">1.5.2.</span> <span class="nav-text">5.2 调试技巧</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B0%83%E8%AF%95%E5%99%A8%E4%BD%BF%E7%94%A8"><span class="nav-number">1.5.2.1.</span> <span class="nav-text">调试器使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95"><span class="nav-number">1.5.2.2.</span> <span class="nav-text">日志记录</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%AD%E8%A8%80%E4%BD%BF%E7%94%A8"><span class="nav-number">1.5.2.3.</span> <span class="nav-text">断言使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF%E6%8E%92%E6%9F%A5"><span class="nav-number">1.5.2.4.</span> <span class="nav-text">常见错误排查</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="nav-number">1.5.3.</span> <span class="nav-text">5.3 性能优化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E4%BC%98%E5%8C%96"><span class="nav-number">1.5.3.1.</span> <span class="nav-text">算法优化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%80%89%E6%8B%A9"><span class="nav-number">1.5.3.2.</span> <span class="nav-text">数据结构选择</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96"><span class="nav-number">1.5.3.3.</span> <span class="nav-text">内存优化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%96%E8%AF%91%E5%99%A8%E4%BC%98%E5%8C%96"><span class="nav-number">1.5.3.4.</span> <span class="nav-text">编译器优化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7"><span class="nav-number">1.5.3.5.</span> <span class="nav-text">性能分析工具</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%9A%84%E5%8E%9F%E5%88%99"><span class="nav-number">1.5.3.6.</span> <span class="nav-text">性能优化的原则</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-4-%E5%B8%B8%E8%A7%81%E9%99%B7%E9%98%B1%E4%B8%8E%E9%81%BF%E5%85%8D"><span class="nav-number">1.5.4.</span> <span class="nav-text">5.4 常见陷阱与避免</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-%E5%AE%9E%E6%88%98%E9%A1%B9%E7%9B%AE%E4%B8%8E%E7%BB%83%E4%B9%A0"><span class="nav-number">1.6.</span> <span class="nav-text">6. 实战项目与练习</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-1-C%E8%AF%AD%E8%A8%80%E7%BB%8F%E5%85%B8%E9%A1%B9%E7%9B%AE"><span class="nav-number">1.6.1.</span> <span class="nav-text">6.1 C语言经典项目</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#6-1-1-%E7%AE%80%E6%98%93%E8%AE%A1%E7%AE%97%E5%99%A8"><span class="nav-number">1.6.1.1.</span> <span class="nav-text">6.1.1 简易计算器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-1-2-%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%E5%99%A8"><span class="nav-number">1.6.1.2.</span> <span class="nav-text">6.1.2 文件管理器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-1-3-%E7%AE%80%E5%8D%95%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="nav-number">1.6.1.3.</span> <span class="nav-text">6.1.3 简单数据库</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-1-4-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80"><span class="nav-number">1.6.1.4.</span> <span class="nav-text">6.1.4 网络编程基础</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%A1%B9%E7%9B%AE"><span class="nav-number">1.6.2.</span> <span class="nav-text">6.2 C++面向对象项目</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#6-2-1-%E5%9B%BE%E5%BD%A2%E7%95%8C%E9%9D%A2%E5%BA%94%E7%94%A8"><span class="nav-number">1.6.2.1.</span> <span class="nav-text">6.2.1 图形界面应用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-2-2-%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80"><span class="nav-number">1.6.2.2.</span> <span class="nav-text">6.2.2 游戏开发基础</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-2-3-%E7%B3%BB%E7%BB%9F%E5%B7%A5%E5%85%B7%E5%BC%80%E5%8F%91"><span class="nav-number">1.6.2.3.</span> <span class="nav-text">6.2.3 系统工具开发</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-2-4-%E6%A1%86%E6%9E%B6%E8%AE%BE%E8%AE%A1%E7%BB%83%E4%B9%A0"><span class="nav-number">1.6.2.4.</span> <span class="nav-text">6.2.4 框架设计练习</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-3-%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E8%B7%B5"><span class="nav-number">1.6.3.</span> <span class="nav-text">6.3 算法与数据结构实践</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#6-3-1-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.6.3.1.</span> <span class="nav-text">6.3.1 排序算法实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-3-2-%E6%A0%91%E4%B8%8E%E5%9B%BE%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="nav-number">1.6.3.2.</span> <span class="nav-text">6.3.2 树与图的操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-3-3-%E5%93%88%E5%B8%8C%E8%A1%A8%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.6.3.3.</span> <span class="nav-text">6.3.3 哈希表实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-3-4-%E7%BC%93%E5%AD%98%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1"><span class="nav-number">1.6.3.4.</span> <span class="nav-text">6.3.4 缓存系统设计</span></a></li></ol></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="jiejiejiang"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">jiejiejiang</p>
  <div class="site-description" itemprop="description">现在开始，还来得及</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">7</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>


<!-- CloudCalendar -->
<div class="widget-wrap" style="width: 90%;margin-left: auto;margin-right: auto; opacity: 0.97;">
	<div class="widget" id="CloudCalendar"></div>
</div>
      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">jiejiejiang</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">50k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">3:01</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
          load: ['[tex]/mhchem'],
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        displayMath: {'[+]': [['$$', '$$']]},
          packages: {'[+]': ['mhchem']},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  
<!-- calendar widget -->

<script src="https://cdn.jsdelivr.net/npm/darkmode-js@1.5.7/lib/darkmode-js.min.js"></script>

<script>
var options = {
  bottom: '64px',
  right: 'unset',
  left: '32px',
  time: '0.5s',
  mixColor: 'transparent',
  backgroundColor: 'transparent',
  buttonColorDark: '#100f2c',
  buttonColorLight: '#fff',
  saveInCookies: true,
  label: '🌓',
  autoMatchOsTheme: true
}
const darkmode = new Darkmode(options);
window.darkmode = darkmode;
darkmode.showWidget();
</script>


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'nS57E3JRn6eYspCCr9pXSVn5-gzGzoHsz',
      appKey     : 'L8rQJuf9mDfJkhZvlLa9UhPq',
      placeholder: "Just go go",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : true,
      lang       : 'zh-cn' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>


  <!-- calendar widget -->


</body>
</html>
