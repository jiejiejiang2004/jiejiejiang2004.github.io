<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 8.1.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=-apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif:300,300italic,400,400italic,700,700italic|Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">



<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"jiejiejiang2004.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":true,"preload":true},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="学习须知（Warning）  学习建议：先理解基础理论→再练实操→最后深化进阶内容 环境说明：MySQL版本选择、环境搭建基础要求  数据库基础理论 数据库设计核心 E-R模型（实体-关系模型） 基本概念  实体：能独立存在、有自己属性的对象，比如 “员工”“部门”“客户”“商品”。 每个实体都有 “唯一标识”（比如员工的 “工号”、商品的 “商品 ID”），后续会变成表的 “">
<meta property="og:type" content="article">
<meta property="og:title" content="数据库（MySQL）知识整理（更新ing）">
<meta property="og:url" content="https://jiejiejiang2004.github.io/2025/11/23/%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%88MySQL%EF%BC%89%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="学习须知（Warning）  学习建议：先理解基础理论→再练实操→最后深化进阶内容 环境说明：MySQL版本选择、环境搭建基础要求  数据库基础理论 数据库设计核心 E-R模型（实体-关系模型） 基本概念  实体：能独立存在、有自己属性的对象，比如 “员工”“部门”“客户”“商品”。 每个实体都有 “唯一标识”（比如员工的 “工号”、商品的 “商品 ID”），后续会变成表的 “">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-11-22T16:00:00.000Z">
<meta property="article:modified_time" content="2025-11-26T07:16:13.551Z">
<meta property="article:author" content="jiejiejiang">
<meta property="article:tag" content="DataBase">
<meta property="article:tag" content="MySQL">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://jiejiejiang2004.github.io/2025/11/23/%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%88MySQL%EF%BC%89%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>数据库（MySQL）知识整理（更新ing） | Hexo</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}.beian img{display:inline-block!important}</style></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hexo</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-schedule">

    <a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>日程表</a>

  </li>
        <li class="menu-item menu-item-sitemap">

    <a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>站点地图</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

  
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://jiejiejiang2004.github.io/2025/11/23/%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%88MySQL%EF%BC%89%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="jiejiejiang">
      <meta itemprop="description" content="现在开始，还来得及">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          数据库（MySQL）知识整理（更新ing）
        </h1>

        <div class="post-meta">

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-11-23 00:00:00" itemprop="dateCreated datePublished" datetime="2025-11-23T00:00:00+08:00">2025-11-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-11-26 15:16:13" itemprop="dateModified" datetime="2025-11-26T15:16:13+08:00">2025-11-26</time>
              </span>

          
            <span id="/2025/11/23/%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%88MySQL%EF%BC%89%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/" class="post-meta-item leancloud_visitors" data-flag-title="数据库（MySQL）知识整理（更新ing）" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2025/11/23/%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%88MySQL%EF%BC%89%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2025/11/23/%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%88MySQL%EF%BC%89%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>30k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1:51</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="学习须知warning">学习须知（Warning）</h1>
<ul>
<li>学习建议：先理解基础理论→再练实操→最后深化进阶内容</li>
<li>环境说明：MySQL版本选择、环境搭建基础要求</li>
</ul>
<h1 id="数据库基础理论">数据库基础理论</h1>
<h2 id="数据库设计核心">数据库设计核心</h2>
<h3 id="e-r模型实体-关系模型">E-R模型（实体-关系模型）</h3>
<h4 id="基本概念">基本概念</h4>
<ul>
<li><strong>实体</strong>：能独立存在、有自己属性的对象，比如 “员工”“部门”“客户”“商品”。 每个实体都有 “唯一标识”（比如员工的 “工号”、商品的 “商品 ID”），后续会变成表的 “主键”。</li>
<li><strong>属性</strong>：实体拥有的具体信息，比如 “员工” 的姓名、工号、薪资、入职时间。 属性不能再拆成更小的 “有意义单位”（比如 “地址” 如果拆成 “省 + 市 + 区”，那 “省”“市”“区” 才是属性，原 “地址” 不是）。</li>
<li><strong>关系</strong>：不同实体之间的业务联系，比如 “员工属于部门”“学生选课程”，关系也有自己的 “类型”。| 常见关系类型（用 “一方”“多方” 理解，避免复杂术语）：
<ul>
<li>一对一：两个实体 “一一对应”，比如 “员工” 和 “工牌”（一个员工只有一个工牌，一个工牌只属于一个员工）；</li>
<li>一对多：一个实体对应多个另一个实体，比如 “部门” 和 “员工”（一个部门有多个员工，一个员工只属于一个部门）—— 最常见的关系；</li>
<li>多对多：两个实体 “互相对应多个”，比如 “学生” 和 “课程”（一个学生选多门课，一门课有多个学生）。</li>
</ul></li>
</ul>
<h4 id="e-r图">E-R图</h4>
<span id="more"></span>
<h3 id="关系数据库规范化入门">关系数据库规范化入门</h3>
<h4 id="为什么需要规范化">为什么需要规范化</h4>
<p>规范化是一种数据库设计技术，其主要目标是：</p>
<ul>
<li><strong>减少数据冗余</strong>：避免相同的数据存储在多个地方，节省存储空间</li>
<li><strong>避免数据异常</strong>：防止插入异常、删除异常和更新异常</li>
<li><strong>提高数据完整性</strong>：确保数据一致性和准确性</li>
<li><strong>简化查询维护</strong>：使数据库结构更加清晰，便于维护</li>
</ul>
<p><strong>反规范化示例</strong>（存在问题的设计）：</p>
<table>
<thead>
<tr class="header">
<th>学生ID</th>
<th>学生姓名</th>
<th>课程ID</th>
<th>课程名称</th>
<th>授课教师</th>
<th>成绩</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1001</td>
<td>张三</td>
<td>CS001</td>
<td>数据库原理</td>
<td>王老师</td>
<td>85</td>
</tr>
<tr class="even">
<td>1001</td>
<td>张三</td>
<td>CS002</td>
<td>编程语言</td>
<td>李老师</td>
<td>90</td>
</tr>
<tr class="odd">
<td>1002</td>
<td>李四</td>
<td>CS001</td>
<td>数据库原理</td>
<td>王老师</td>
<td>78</td>
</tr>
</tbody>
</table>
<p>上述表格存在冗余（如学生姓名和课程信息重复），且更新异常（如王老师改名需更新多行）。</p>
<h4 id="函数依赖基础">函数依赖基础</h4>
<p>函数依赖是规范化理论的基础概念，描述了属性之间的依赖关系。</p>
<ul>
<li><strong>定义</strong>：如果通过属性（或属性组）X的值，可以确定属性Y的值，则称Y函数依赖于X，记作 X→Y</li>
<li><strong>分类</strong>：
<ul>
<li>完全函数依赖：Y完全依赖于X的所有属性</li>
<li>部分函数依赖：Y只依赖于X的部分属性</li>
<li>传递函数依赖：如果X→Y且Y→Z，则Z传递依赖于X</li>
</ul></li>
</ul>
<p><strong>示例</strong>： 在学生选课关系(学号, 姓名, 课程号, 课程名, 成绩)中： - 学号→姓名（通过学号可以确定学生姓名） - 课程号→课程名（通过课程号可以确定课程名） - (学号, 课程号)→成绩（通过学号和课程号共同确定成绩）</p>
<h4 id="核心范式">核心范式</h4>
<p>规范化过程通过将低范式的关系模式分解为高范式的关系模式来实现。主要范式包括：</p>
<h5 id="第一范式1nf">第一范式（1NF）</h5>
<p><strong>定义</strong>：确保表中每个字段都是<strong>原子的</strong>（不可再分）。</p>
<p><strong>不符合1NF的例子</strong>：</p>
<table>
<thead>
<tr class="header">
<th>学生ID</th>
<th>学生信息</th>
<th>选课列表</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1001</td>
<td>张三, 20岁</td>
<td>CS001(85分), CS002(90分)</td>
</tr>
</tbody>
</table>
<p><strong>符合1NF的例子</strong>：</p>
<table>
<thead>
<tr class="header">
<th>学生ID</th>
<th>姓名</th>
<th>年龄</th>
<th>课程ID</th>
<th>成绩</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1001</td>
<td>张三</td>
<td>20</td>
<td>CS001</td>
<td>85</td>
</tr>
<tr class="even">
<td>1001</td>
<td>张三</td>
<td>20</td>
<td>CS002</td>
<td>90</td>
</tr>
</tbody>
</table>
<h5 id="第二范式2nf">第二范式（2NF）</h5>
<p><strong>定义</strong>：在满足1NF的基础上，消除了<strong>部分函数依赖</strong>，即所有非主键字段都完全依赖于主键。</p>
<p><strong>示例</strong>：将选课关系分解为两个表</p>
<p><strong>学生表（Student）</strong>：</p>
<table>
<thead>
<tr class="header">
<th>学生ID (PK)</th>
<th>姓名</th>
<th>年龄</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1001</td>
<td>张三</td>
<td>20</td>
</tr>
<tr class="even">
<td>1002</td>
<td>李四</td>
<td>21</td>
</tr>
</tbody>
</table>
<p><strong>选课表（Enrollment）</strong>：</p>
<table>
<thead>
<tr class="header">
<th>学生ID (PK)</th>
<th>课程ID (PK)</th>
<th>成绩</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1001</td>
<td>CS001</td>
<td>85</td>
</tr>
<tr class="even">
<td>1001</td>
<td>CS002</td>
<td>90</td>
</tr>
<tr class="odd">
<td>1002</td>
<td>CS001</td>
<td>78</td>
</tr>
</tbody>
</table>
<h5 id="第三范式3nf">第三范式（3NF）</h5>
<p><strong>定义</strong>：在满足2NF的基础上，消除了<strong>传递函数依赖</strong>，即不存在非主键字段依赖于其他非主键字段。</p>
<p><strong>示例</strong>：添加课程表，进一步分解</p>
<p><strong>课程表（Course）</strong>：</p>
<table>
<thead>
<tr class="header">
<th>课程ID (PK)</th>
<th>课程名称</th>
<th>授课教师</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>CS001</td>
<td>数据库原理</td>
<td>王老师</td>
</tr>
<tr class="even">
<td>CS002</td>
<td>编程语言</td>
<td>李老师</td>
</tr>
</tbody>
</table>
<p>最终，规范化后的表结构： 1. <strong>学生表（Student）</strong>：学生ID (PK), 姓名, 年龄 2. <strong>课程表（Course）</strong>：课程ID (PK), 课程名称, 授课教师 3. <strong>选课表（Enrollment）</strong>：学生ID (PK/FK), 课程ID (PK/FK), 成绩</p>
<h4 id="规范化与反规范化">规范化与反规范化</h4>
<ul>
<li><strong>规范化优点</strong>：减少数据冗余，提高数据一致性</li>
<li><strong>规范化缺点</strong>：可能需要多表连接查询，影响查询性能</li>
<li><strong>反规范化</strong>：在某些情况下，为了性能考虑，会有意降低规范化程度，引入适当冗余</li>
</ul>
<p><strong>实际应用建议</strong>： 1. 通常情况下，设计到3NF就足够满足大多数业务需求 2. 根据具体性能要求，在必要时可以考虑适度反规范化 3. 始终在数据一致性和查询性能之间找到平衡点</p>
<h1 id="核心术语解析">核心术语解析</h1>
<ul>
<li>数据库、表、字段、记录、主键、外键、索引等基础术语</li>
<li>SQL语句分类（DQL查询、DML操作、DDL定义、DCL控制）</li>
</ul>
<h1 id="数据库基础操作">数据库基础操作</h1>
<ul>
<li>查看数据库/表：<code>SHOW DATABASES</code>/<code>SHOW TABLES</code></li>
<li>查看表结构：<code>SHOW COLUMNS FROM 表名</code>/<code>DESCRIBE 表名</code></li>
<li>查看状态/权限：<code>SHOW STATUS</code>/<code>SHOW GRANTS FOR 用户</code></li>
<li>切换数据库：<code>USE 数据库名</code></li>
</ul>
<h1 id="数据查询select语句">数据查询：SELECT语句</h1>
<h2 id="select-基本格式">SELECT 基本格式</h2>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 数据库.列<span class="number">1</span>, 数据库.列<span class="number">2</span></span><br><span class="line"><span class="keyword">FROM</span> 数据库;</span><br></pre></td></tr></table></figure>
<p>特殊的：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> 数据库;</span><br></pre></td></tr></table></figure>
<p>表示查询该数据库的所有列</p>
<h2 id="distinct-关键字结果去重">DISTINCT 关键字（结果去重）</h2>
<p>如果想要每个值只出现一次，可以使用 DISTINCT 关键字，使用方法如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> 数据库.列<span class="number">1</span>, 数据库.列<span class="number">2</span></span><br><span class="line"><span class="keyword">FROM</span> 数据库;</span><br></pre></td></tr></table></figure>
<p><strong>注意！DISTINCT 关键字无法应用于部分列，只能用用于你查询的所有列！</strong></p>
<h2 id="limit关键字分页基础限制结果行数">LIMIT关键字（分页基础）（限制结果行数）</h2>
<p>如果想要限制输出的结果的行数，那么我们可以使用 LIMIT 关键字，使用方法如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 数据库.列<span class="number">1</span>, 数据库.列<span class="number">2</span></span><br><span class="line"><span class="keyword">FROM</span> 数据库</span><br><span class="line">LIMIT <span class="number">5</span>;</span><br></pre></td></tr></table></figure>
<p>以上代码表示输出行数不超过 5 行</p>
<h2 id="order-by子句结果排序升序asc降序desc">ORDER BY子句（结果排序）（升序ASC/降序DESC）</h2>
<blockquote>
<p>其实，检索出的数据并不是以纯粹的随机顺序显示的。如果不排序，数据一般将以它在底层表中出现的顺序显示。 ——《MySQL必知必会》</p>
</blockquote>
<p>因此，为了确保我们想得到的结果按顺序输出，我们可以用 ORDER BY 字句，使用方法如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 数据库.列<span class="number">1</span>, 数据库.列<span class="number">2</span></span><br><span class="line"><span class="keyword">FROM</span> 数据库</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> 数据库.列<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 数据库.列<span class="number">1</span>, 数据库.列<span class="number">2</span></span><br><span class="line"><span class="keyword">FROM</span> 数据库</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> 数据库.列<span class="number">1</span> <span class="keyword">DESC</span>, 数据库.列<span class="number">2</span></span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong></p>
<ol type="1">
<li>ORDER BY 默认升序排序（隐藏关键字：ASC）；</li>
<li>如果想在多个列上进行降序排序，必须对每个列指定 DESC 关键字。</li>
</ol>
<p><strong>注意：</strong></p>
<blockquote>
<p>在给出 ORDER BY 子句时，应该保证它位于 FROM 子句之后。如果使用 LIMIT ，它必须位于 ORDER BY 之后。使用子句的次序不对将产生错误消息。——《MySQL必知必会》</p>
</blockquote>
<h2 id="where子句数据筛选">WHERE子句（数据筛选）</h2>
<p>因为当我们查询数据的时候，我们往往只需要符合我们要求的部分数据，而不是所有数据，因此我们需要对数据进行过滤。</p>
<p>对数据进行过滤，我们一般使用 WHERE 子句，使用方法如下（例）：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 数据库.列<span class="number">1</span>, 数据库.列<span class="number">2</span></span><br><span class="line"><span class="keyword">FROM</span> 数据库</span><br><span class="line"><span class="keyword">WHERE</span> 数据库.列<span class="number">1</span> <span class="operator">=</span> XXX</span><br></pre></td></tr></table></figure>
<p><em>注：这里的 XXX 指代数据内容</em></p>
<p>以上就是筛选出了 数据库.列1 的内容为 XXX 时的 数据库.列1 和 数据库.列2</p>
<h3 id="基础操作符">基础操作符</h3>
<table>
<thead>
<tr class="header">
<th>操作符</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>=</td>
<td>等于</td>
</tr>
<tr class="even">
<td>&lt;&gt;</td>
<td>不等于</td>
</tr>
<tr class="odd">
<td>!=</td>
<td>不等于</td>
</tr>
<tr class="even">
<td>&lt;</td>
<td>小于</td>
</tr>
<tr class="odd">
<td>&lt;=</td>
<td>小于等于</td>
</tr>
<tr class="even">
<td>&gt;</td>
<td>大于</td>
</tr>
<tr class="odd">
<td>&gt;=</td>
<td>大于等于</td>
</tr>
<tr class="even">
<td>BETWEEN</td>
<td>在指定的两个值之间</td>
</tr>
</tbody>
</table>
<h3 id="空值检查is-nullis-not-null">空值检查：<code>IS NULL</code>/<code>IS NOT NULL</code></h3>
<p>如果要检查某一列是否为 NULL，可以这样：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">WHERE</span> col <span class="keyword">IS</span> <span class="keyword">NULL</span></span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">WHERE</span> col <span class="keyword">IS</span> <span class="keyword">NOT NULL</span></span><br></pre></td></tr></table></figure>
<h3 id="逻辑操作符andorinnot">逻辑操作符（AND/OR/IN/NOT）</h3>
<table>
<thead>
<tr class="header">
<th>操作符</th>
<th>核心逻辑</th>
<th>适用场景</th>
<th>注意事项</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>AND</td>
<td>同时满足多个条件</td>
<td>多条件必须同时成立</td>
<td>优先级高于 OR，混用需加括号</td>
</tr>
<tr class="even">
<td>OR</td>
<td>满足任意一个条件</td>
<td>多条件任选其一</td>
<td>优先级低于 AND，避免单独使用复杂逻辑</td>
</tr>
<tr class="odd">
<td>IN</td>
<td>匹配多个指定值中的任意一个</td>
<td>替代多个 OR，简化条件</td>
<td>列表值需类型一致，字符串加单引号</td>
</tr>
<tr class="even">
<td>NOT</td>
<td>否定其后的条件</td>
<td>筛选“不满足某条件”的记录</td>
<td>仅否定紧跟的条件，可与多种操作符结合</td>
</tr>
</tbody>
</table>
<h4 id="and-操作符">AND 操作符</h4>
<p>作用：筛选同时满足所有指定条件的记录（逻辑“与”），多个条件需全部成立才会被匹配。</p>
<p>用法示例：假设员工表 <code>employees</code> 新增字段 <code>department</code>（部门）、<code>salary</code>（薪资），数据如下：</p>
<table>
<thead>
<tr class="header">
<th>employee_id</th>
<th>name</th>
<th>department</th>
<th>salary</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>张三</td>
<td>技术部</td>
<td>6000</td>
</tr>
<tr class="even">
<td>2</td>
<td>李四</td>
<td>市场部</td>
<td>4500</td>
</tr>
<tr class="odd">
<td>3</td>
<td>王五</td>
<td>技术部</td>
<td>5500</td>
</tr>
<tr class="even">
<td>4</td>
<td>赵六</td>
<td>人事部</td>
<td>5000</td>
</tr>
</tbody>
</table>
<p>需求：查询“技术部且薪资大于 5000 元”的员工（同时满足两个条件）：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> department <span class="operator">=</span> <span class="string">&#x27;技术部&#x27;</span> <span class="keyword">AND</span> salary <span class="operator">&gt;</span> <span class="number">5000</span>;</span><br></pre></td></tr></table></figure>
<p>结果返回 张三（6000 元）、王五（5500 元），只有同时符合“技术部”和“薪资&gt;5000”才会被筛选。</p>
<p>注意：AND 可连接任意多个条件，所有条件必须同时成立。</p>
<h4 id="or-操作符">OR 操作符</h4>
<p>作用：筛选满足任意一个指定条件的记录（逻辑“或”），只要有一个条件成立就会被匹配。</p>
<p>用法示例：查询“市场部 或 薪资大于 5500 元”的员工（满足一个条件即可）：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> department <span class="operator">=</span> <span class="string">&#x27;市场部&#x27;</span> <span class="keyword">OR</span> salary <span class="operator">&gt;</span> <span class="number">5500</span>;</span><br></pre></td></tr></table></figure>
<p>结果返回 张三（薪资 6000&gt;5500）、李四（市场部），两者满足其一即匹配。</p>
<p>注意：OR 连接的条件是“任选其一”，无需全部满足；但需注意与 AND 混用的优先级问题（下文详解）。</p>
<h4 id="and-与-or-的运行顺序">AND 与 OR 的运行顺序</h4>
<p>核心规则：AND 的优先级高于 OR，数据库会先解析 AND 连接的条件，再解析 OR 连接的条件。</p>
<p>易错示例（未加括号）： 需求：查询“技术部且薪资&gt;5000” 或 “市场部且薪资&gt;4000”的员工，若直接写：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 错误写法：逻辑被优先级打乱</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> department <span class="operator">=</span> <span class="string">&#x27;技术部&#x27;</span> <span class="keyword">AND</span> salary <span class="operator">&gt;</span> <span class="number">5000</span> <span class="keyword">OR</span> department <span class="operator">=</span> <span class="string">&#x27;市场部&#x27;</span> <span class="keyword">AND</span> salary <span class="operator">&gt;</span> <span class="number">4000</span>;</span><br></pre></td></tr></table></figure>
<p>数据库解析顺序：先执行两个 AND 条件（<code>技术部+薪资&gt;5000</code>、<code>市场部+薪资&gt;4000</code>），再用 OR 连接结果，这个例子恰好结果正确，但下面的情况会出错：</p>
<p>反例（未加括号导致逻辑错误）： 需求：查询“（技术部 或 市场部）且薪资&gt;5000”的员工，若漏写括号：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 错误写法：优先级导致逻辑偏离</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> department <span class="operator">=</span> <span class="string">&#x27;技术部&#x27;</span> <span class="keyword">OR</span> department <span class="operator">=</span> <span class="string">&#x27;市场部&#x27;</span> <span class="keyword">AND</span> salary <span class="operator">&gt;</span> <span class="number">5000</span>;</span><br></pre></td></tr></table></figure>
<p>数据库解析为：<code>技术部</code> 或 <code>（市场部 且 薪资&gt;5000）</code>，结果会返回 张三（技术部）、王五（技术部）、无市场部员工（李四薪资 4500&lt;5000），但实际需求是“技术部/市场部中薪资&gt;5000的”，正确结果应只有张三、王五（市场部无符合薪资的），虽结果巧合一致，但逻辑是错的，换个数据就会出问题。</p>
<p>正确写法（加括号明确优先级）： 用括号 <code>()</code> 强制改变执行顺序，先解析括号内的 OR 条件，再解析 AND 条件：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> (department <span class="operator">=</span> <span class="string">&#x27;技术部&#x27;</span> <span class="keyword">OR</span> department <span class="operator">=</span> <span class="string">&#x27;市场部&#x27;</span>) <span class="keyword">AND</span> salary <span class="operator">&gt;</span> <span class="number">5000</span>;</span><br></pre></td></tr></table></figure>
<p>解析顺序：先确定“技术部或市场部”的员工（张三、李四、王五），再筛选其中“薪资&gt;5000”的（张三、王五），完全符合需求。</p>
<p>注意：当 AND 和 OR 同时出现时，务必用括号明确逻辑分组，避免因优先级导致结果错误。</p>
<h4 id="in-操作符">IN 操作符</h4>
<p>作用：筛选“字段值匹配多个指定值中的任意一个”的记录，等价于多个 OR 条件的组合，但更简洁、可读性更高。</p>
<p>用法示例：查询“部门为技术部、市场部、人事部”的员工（匹配多个部门中的任意一个）：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 用 IN 实现（简洁）</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> department <span class="keyword">IN</span> (<span class="string">&#x27;技术部&#x27;</span>, <span class="string">&#x27;市场部&#x27;</span>, <span class="string">&#x27;人事部&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 等价于 OR 写法（繁琐，多个值时易出错）</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> department <span class="operator">=</span> <span class="string">&#x27;技术部&#x27;</span> <span class="keyword">OR</span> department <span class="operator">=</span> <span class="string">&#x27;市场部&#x27;</span> <span class="keyword">OR</span> department <span class="operator">=</span> <span class="string">&#x27;人事部&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>两种写法结果一致，均返回所有员工（因示例中只有这三个部门）。</p>
<p>IN 操作符的优势在于：</p>
<ul>
<li>比多个 OR 更高效（数据库优化器对 IN 的处理更优）。</li>
<li>实际在项目场景下， 我们要筛选的字段值往往从另一个查询中得到，而 IN 操作符支持子查询；</li>
</ul>
<p><strong>注意</strong>：IN 列表中的值需用逗号分隔，字符串需加单引号（<code>' '</code>）。</p>
<h4 id="not-操作符">NOT 操作符</h4>
<p>作用：否定其后的条件（逻辑“非”），筛选不满足指定条件的记录，可与 IN、BETWEEN、IS NULL 等结合使用。</p>
<p>用法示例：</p>
<ol type="1">
<li>与 IN 结合：查询“部门不在技术部、市场部”的员工：</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> department <span class="keyword">NOT</span> <span class="keyword">IN</span> (<span class="string">&#x27;技术部&#x27;</span>, <span class="string">&#x27;市场部&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>结果返回 赵六（人事部）。</p>
<ol start="2" type="1">
<li>与 BETWEEN 结合：查询“薪资不在 4000-5500 元之间”的员工：</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> salary <span class="keyword">NOT</span> <span class="keyword">BETWEEN</span> <span class="number">4000</span> <span class="keyword">AND</span> <span class="number">5500</span>;</span><br></pre></td></tr></table></figure>
<p>结果返回 张三（6000 元，高于 5500）。</p>
<ol start="3" type="1">
<li>与 IS NULL 结合：查询“邮箱不为空（IS NOT NULL）”的员工（补充之前的空值检查）：</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> email <span class="keyword">NOT</span> <span class="keyword">IS</span> <span class="keyword">NULL</span>; <span class="comment">-- 等价于 WHERE email IS NOT NULL，两种写法均可</span></span><br></pre></td></tr></table></figure>
<p>结果返回邮箱字段有明确值的员工。</p>
<p>注意：</p>
<ul>
<li>NOT 仅否定紧跟其后的一个条件（若需否定多个条件，需结合括号）；</li>
<li>与 IN 结合时，<code>NOT IN</code> 会排除所有匹配 IN 列表的值，包括 NULL（若 IN 列表中有 NULL，<code>NOT IN</code> 可能返回空结果，需避免）。</li>
</ul>
<h3 id="like与通配符_模糊查询">LIKE与通配符（%\\_）(模糊查询)</h3>
<h4 id="like-操作符">LIKE 操作符</h4>
<p>作用：结合通配符实现<strong>模糊查询</strong>，筛选“部分符合字符串格式”的记录（无需精准匹配完整字符串），适用于字符串类型字段（如姓名、邮箱、部门名等），支持 <code>%</code> 和 <code>_</code> 两种核心通配符，且可通过转义符匹配实际存在的通配符字符。 <strong>具体使用方法如下 ↓</strong></p>
<table>
<thead>
<tr class="header">
<th>通配符</th>
<th>核心作用</th>
<th>适用场景</th>
<th>注意事项</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>%</code></td>
<td>匹配任意数量的任意字符（含 0 个）</td>
<td>开头/结尾/包含匹配、长度不固定场景</td>
<td>开头使用可能影响索引效率</td>
</tr>
<tr class="even">
<td><code>_</code></td>
<td>匹配单个任意字符</td>
<td>固定长度、特定位置字符匹配</td>
<td>严格匹配 1 个字符，不能多也不能少</td>
</tr>
<tr class="odd">
<td>转义符</td>
<td>匹配实际的 <code>%</code> 或 <code>_</code></td>
<td>字符串中包含通配符字符的场景</td>
<td>默认用 <code>\</code>，可通过 <code>ESCAPE</code> 自定义</td>
</tr>
</tbody>
</table>
<h4 id="百分号通配符">百分号（%）通配符</h4>
<p>作用：匹配<strong>任意数量的任意字符</strong>（包括 <span class="math inline">0</span> 个字符，即空字符串），是 <code>LIKE</code> 中最常用的通配符，可放在字符串开头、中间或结尾。</p>
<p>用法示例（基于 <code>employees</code> 表的 <code>name</code>（姓名）、<code>email</code>（邮箱）字段）：</p>
<ol type="1">
<li>开头匹配：查询“名字以‘张’开头”的员工</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> name <span class="keyword">LIKE</span> <span class="string">&#x27;张%&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>结果返回 张三（姓名为“张三”），若存在“张伟明”“张丽”等名字以“张”开头的员工，也会被匹配。</p>
<ol start="2" type="1">
<li>结尾匹配：查询“邮箱以‘<span class="citation" data-cites="qq.com">@qq.com</span>’结尾”的员工</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> email <span class="keyword">LIKE</span> <span class="string">&#x27;%@qq.com&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>结果返回所有邮箱后缀为“<span class="citation" data-cites="qq.com">@qq.com</span>”的员工，无论邮箱前缀长度如何。</p>
<ol start="3" type="1">
<li>包含匹配：查询“姓名中包含‘三’字”的员工</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> name <span class="keyword">LIKE</span> <span class="string">&#x27;%三%&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>结果返回 张三（姓名含“三”），若存在“李三丰”“王三”等员工，也会被匹配。</p>
<ol start="4" type="1">
<li>匹配空字符串：查询“部门字段为空字符串”的员工（<strong>注意</strong>：空字符串 <code>''</code> 不同于 NULL）</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> department <span class="keyword">LIKE</span> <span class="string">&#x27;&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>结果返回部门字段填写为空字符串的员工，NULL 不会被匹配（NULL 需用 <code>IS NULL</code> 判断）。</p>
<p>注意事项：</p>
<ul>
<li><code>%</code> 放在字符串<strong>开头</strong>时（如 <code>'%三%'</code>），MySQL 无法使用字段索引，大表查询时效率较低，尽量将 <code>%</code> 放在结尾（如 <code>'张%'</code>）以利用索引；</li>
<li><code>%</code> 可匹配任意字符，包括数字、字母、符号、空格等，无字符类型限制；</li>
<li><strong>!!!!!</strong> 若需匹配“字段值为空”，需区分“空字符串”（<code>LIKE ''</code>）和“NULL”（<code>IS NULL</code>），<code>%</code> 无法匹配 NULL。</li>
</ul>
<h4 id="下划线_通配符">下划线（_）通配符</h4>
<p>作用：匹配<strong>单个任意字符</strong>（严格占 1 个字符位置，不能多也不能少），适用于明确字符串长度或特定位置字符的匹配场景。</p>
<p>用法示例：</p>
<ol type="1">
<li>固定长度匹配：查询“姓名为 2 个字符且以‘张’开头”的员工</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> name <span class="keyword">LIKE</span> <span class="string">&#x27;张_&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>结果返回 张三（姓名为 2 字符，以“张”开头），若存在“张丽”“张涛”等 2 字符姓名员工也会被匹配，但“张伟明”（3 字符）不会被匹配。</p>
<ol start="2" type="1">
<li>特定位置匹配：查询“手机号为 11 位数字且第 4-5 位为‘86’”的员工（假设 <code>phone</code> 为字符串类型）</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> phone <span class="keyword">LIKE</span> <span class="string">&#x27;___86______&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>解析：<code>___</code> 匹配前 3 位任意数字，<code>86</code> 是固定字符，<code>______</code> 匹配后 6 位任意数字，整体严格匹配 11 位手机号，且第 4-5 位为“86”。</p>
<ol start="3" type="1">
<li>组合匹配：查询“邮箱前缀为 3 个字符，且后缀为‘<span class="citation" data-cites="qq.com">@qq.com</span>’”的员工</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> email <span class="keyword">LIKE</span> <span class="string">&#x27;___@qq.com&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>结果返回邮箱格式为“aaa@qq.com”“abc@qq.com”等前缀为 3 字符的员工。</p>
<p>注意事项：</p>
<ul>
<li><code>_</code> 仅匹配<strong>1 个字符</strong>，若需匹配 n 个字符，需写 n 个 <code>_</code>（如匹配 3 个字符需 <code>___</code>）；</li>
<li>无法匹配 0 个字符（空字符串），也无法匹配超过 1 个字符的内容，匹配长度严格限制；</li>
<li>与 <code>%</code> 不同，<code>_</code> 即使放在字符串开头，也可能利用索引（若字段有前缀索引），但效率仍低于精准匹配。</li>
</ul>
<h4 id="转义通配符">转义通配符</h4>
<p>默认情况下，<code>%</code> 和 <code>_</code> 是通配符，若需匹配字符串中<strong>实际存在的 <code>%</code> 或 <code>_</code> 字符</strong>（而非作为通配符使用），需用「转义符」处理，避免 MySQL 将其解析为通配符。</p>
<p>核心用法：</p>
<ol type="1">
<li>默认转义符（<code>\</code>）：在需匹配的 <code>%</code> 或 <code>_</code> 前加 <code>\</code>，表示该字符是普通字符而非通配符。</li>
<li>自定义转义符（<code>ESCAPE</code>）：若默认转义符 <code>\</code> 与业务字符冲突，可通过 <code>ESCAPE</code> 指定自定义转义符（如 <code>#</code>、<code>$</code> 等）。</li>
</ol>
<p>用法示例：</p>
<ol type="1">
<li>匹配含 <code>%</code> 的字符串：查询“备注字段包含‘5%’（如‘折扣 5%’）”的员工</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 默认转义符 \</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> remark <span class="keyword">LIKE</span> <span class="string">&#x27;%5\%&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>结果返回备注中包含“5%”的员工，<code>\%</code> 表示匹配实际的 <code>%</code> 字符，而非通配符。</p>
<ol start="2" type="1">
<li>匹配含 <code>_</code> 的字符串：查询“用户名包含‘a_b’（如‘user_a_b’）”的员工</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 默认转义符 \</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> username <span class="keyword">LIKE</span> <span class="string">&#x27;%a\_b%&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>结果返回用户名中包含“a_b”的员工，<code>\_</code> 表示匹配实际的 <code>_</code> 字符，而非通配符。</p>
<ol start="3" type="1">
<li>自定义转义符：查询“备注包含‘8%’”的员工，用 <code>#</code> 作为转义符</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> remark <span class="keyword">LIKE</span> <span class="string">&#x27;%8#%&#x27;</span> <span class="keyword">ESCAPE</span> <span class="string">&#x27;#&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>解析：<code>ESCAPE '#'</code> 声明 <code>#</code> 为转义符，<code>#%</code> 表示匹配实际的 <code>%</code> 字符，效果与 <code>\%</code> 一致。</p>
<p>注意事项：</p>
<ul>
<li>转义符仅对紧跟其后的 1 个字符生效，若需匹配多个 <code>%</code> 或 <code>_</code>，需逐个转义（如匹配“5%_”需写 <code>5\%\_</code>）；</li>
<li>自定义转义符需选择业务中不常用的字符（如 <code>#</code>、<code>&amp;</code>），避免与字符串中的普通字符冲突；</li>
<li>若未转义直接写 <code>LIKE '%5%%'</code>，MySQL 会将第二个 <code>%</code> 解析为通配符，导致匹配“包含‘5’且后面任意字符”的结果，而非“包含‘5%’”。</li>
</ul>
<h3 id="regexp正则表达式复杂匹配">REGEXP（正则表达式）(复杂匹配)</h3>
<p>REGEXP（或 RLIKE，两者完全等价）用于<strong>复杂模糊匹配</strong>，功能比 LIKE 更灵活，支持按“模式”筛选字符串，其作用是匹配文本，将一个模式（正则表达式）与一个文本串进行比较。需配合 WHERE 子句使用，只要该字段里包含这一段内容，就会被匹配到。</p>
<p><strong>注意！！！</strong></p>
<ul>
<li>MySQL中的正则表达式匹配不区分大小写（即，大写和小写都匹配）。为区分大小写，可使用BINARY关键字，如<code>WHERE prod_name REGEXP BINARY 'JetPack .000'</code>。</li>
</ul>
<h4 id="使用-.-匹配单个任意字符">使用 . 匹配单个任意字符</h4>
<p>作用：匹配<strong>1个任意字符</strong>（包括字母、数字、符号、空格），等价于 LIKE 操作符的 <code>_</code>，但可与其他正则规则组合使用。</p>
<p>用法示例（基于 <code>employees</code> 表 <code>name</code> 字段）： 需求：查询“姓名为2个字符且以‘张’开头”的员工：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> name REGEXP <span class="string">&#x27;^张.$&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>结果返回 张三（姓名为“张三”，<code>张</code> 后紧跟1个字符）；若存在“张丽”“张涛”等2字姓名员工，也会被匹配（`.’ 匹配第2个任意字符）。</p>
<p>补充示例：查询“邮箱前缀为任意字符，中间包含‘xxx’”的员工：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> email REGEXP <span class="string">&#x27;.xxx.&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>解析：<code>.' 匹配前缀任意1个字符，</code>xxx<code>是固定字符，最后一个</code>.’ 匹配后缀任意1个字符，整体匹配“包含‘xxx’且前后至少各有1个字符”的邮箱。</p>
<h4 id="使用-匹配多个模式逻辑或">使用 | 匹配多个模式（逻辑“或”）</h4>
<p>作用：匹配<strong>多个指定模式中的任意一个</strong>，等价于 OR 条件，适合同时筛选多种符合规则的结果，比多个 OR 更简洁。</p>
<p>用法示例（基于 <code>employees</code> 表 <code>department</code> 字段）： 需求：查询“部门为技术部或市场部”的员工：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> department REGEXP <span class="string">&#x27;技术部|市场部&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>结果返回 张三（技术部）、李四（市场部），匹配两个模式中的任意一个即可。</p>
<p>补充示例：查询“姓名包含‘张’或‘李’”的员工：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> name REGEXP <span class="string">&#x27;张|李&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>结果返回 张三（含“张”）、若存在“李四”“李白”等含“李”的员工，也会被匹配。</p>
<p>注意：<code>|</code> 匹配的是“整个模式”，若需匹配“某字段开头为A或B”，需结合括号（如 <code>^(张|李)</code>），避免匹配错误。</p>
<h4 id="使用-匹配指定字符集中的任意一个">使用 [] 匹配指定字符集中的任意一个</h4>
<p>作用：匹配<strong>方括号内的任意一个字符</strong>（仅匹配 <span class="math inline">1</span> 个），可替代多个 <code>|</code>，简化字符匹配规则。</p>
<p>用法示例（基于 <code>employees</code> 表 <code>name</code> 字段）： 需求：查询“姓名首字为‘张’或‘李’”的员工：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> name REGEXP <span class="string">&#x27;^[张李]&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>解析：<code>^</code> 是定位符（后文详解），表示“字符串开头”，<code>[张李]</code> 匹配开头为“张”或“李”的任意一个字符，结果返回 张三（首字“张”）、若存在“李四”（首字“李”）也会被匹配。</p>
<p>补充示例：查询“手机号第2位为3或5”的员工（假设 <code>phone</code> 为字符串类型）：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> phone REGEXP <span class="string">&#x27;^1[35]&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>解析：<code>^1</code> 表示手机号以1开头，<code>[35]</code> 匹配第2位为3或5，比如“138xxxx”“159xxxx”都会被匹配。</p>
<h4 id="使用---在-内定义字符范围">使用 - 在 [] 内定义字符范围</h4>
<p>作用：在 <code>[]</code> 内用 <code>-</code> 定义<strong>连续的字符范围</strong>，简化多个连续字符的匹配（如字母、数字范围），无需逐个列出字符。</p>
<p>用法示例：</p>
<ol type="1">
<li>匹配数字范围（基于 <code>employees</code> 表 <code>salary</code> 字段）： 需求：查询“薪资开头为5或6”的员工（薪资为数字类型，REGEXP 会自动转为字符串匹配）：</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> salary REGEXP <span class="string">&#x27;^[5-6]&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>结果返回 张三（6000）、王五（5500）、赵六（5000），<code>[5-6]</code> 匹配开头为5或6的数字。</p>
<ol start="2" type="1">
<li>匹配字母范围（基于 <code>employees</code> 表 <code>email</code> 字段）： 需求：查询“邮箱前缀包含小写字母a-f”的员工：</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> email REGEXP <span class="string">&#x27;[a-f]&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>结果返回邮箱中包含a、b、c、d、e、f任意一个小写字母的员工，<code>[a-f]</code> 表示a到f的连续小写字母。</p>
<ol start="3" type="1">
<li>组合范围：查询“姓名包含大写字母A-F或数字0-5”的员工：</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> name REGEXP <span class="string">&#x27;[A-F0-5]&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>解析：<code>[A-F0-5]</code> 同时匹配A-F的大写字母和0-5的数字，无需分开写 <code>[A-F]|[0-5]</code>。</p>
<h4 id="使用-匹配特殊字符转义">使用 <code>\\</code> 匹配特殊字符（转义）</h4>
<p>作用：正则表达式中部分字符（如 <code>.</code>、<code>*</code>、<code>+</code>、<code>?</code> 等）是“特殊元字符”，若需匹配这些字符本身（如邮箱中的 <code>.</code>、网址中的 <code>?</code>），需用 <code>\\</code> 转义（MySQL 中需双重反斜杠，第一层转义 MySQL 本身，第二层转义正则表达式）。</p>
<p>用法示例（基于 <code>employees</code> 表 <code>email</code> 字段）： 需求：查询“邮箱后缀为‘.com’”的员工（匹配实际的 <code>.</code> 字符）：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> email REGEXP <span class="string">&#x27;\\.com$&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>解析：<code>\\.</code> 转义后匹配实际的 <code>.</code> 字符（若直接写 <code>.</code>，会被解析为“匹配任意字符”），<code>$</code> 是定位符，表示“字符串结尾”，结果返回所有邮箱以 <code>.com</code> 结尾的员工。</p>
<p>补充示例：匹配包含 <code>*</code> 字符的备注（基于 <code>remark</code> 字段）：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> remark REGEXP <span class="string">&#x27;\\*&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>结果返回备注中包含 <code>*</code> 字符的员工（如“折扣*8折”），<code>\\*</code> 转义后匹配实际的 <code>*</code> 字符。</p>
<h4 id="匹配字符类预设常用字符集">匹配字符类（预设常用字符集）</h4>
<p>作用：正则提供预设的“字符类”（以 <code>[:xxx:]</code> 形式），简化常用字符集的书写（如数字、字母、空白字符等），需放在 <code>[]</code> 内使用。</p>
<p>用法示例（基于 <code>employees</code> 表相关字段）：</p>
<table>
<colgroup>
<col style="width: 9%" />
<col style="width: 45%" />
<col style="width: 45%" />
</colgroup>
<thead>
<tr class="header">
<th>字符类</th>
<th>示例SQL</th>
<th>结果说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>[:digit:]</code></td>
<td><code>SELECT * FROM employees WHERE phone REGEXP '^[:digit:]{11}$';</code></td>
<td><code>[:digit:]</code> 匹配任意数字，<code>{11}</code> 限制11位，仅返回11位纯数字手机号</td>
</tr>
<tr class="even">
<td><code>[:lower:]</code></td>
<td><code>SELECT * FROM employees WHERE name REGEXP '[:lower:]';</code></td>
<td>返回姓名中包含a-z任意小写字母的员工（如“Zhang三”）</td>
</tr>
<tr class="odd">
<td><code>[:upper:]</code></td>
<td><code>SELECT * FROM employees WHERE email REGEXP '[:upper:]';</code></td>
<td>返回邮箱中包含A-Z任意大写字母的员工（如“ZHANG@xxx.com”）</td>
</tr>
<tr class="even">
<td><code>[:space:]</code></td>
<td><code>SELECT * FROM employees WHERE remark REGEXP '[:space:]';</code></td>
<td>返回备注中包含空格、制表符等空白字符的员工（如“技术部 核心员工”）</td>
</tr>
<tr class="odd">
<td><code>[:alnum:]</code></td>
<td><code>SELECT * FROM employees WHERE username REGEXP '^[:alnum:]+$';</code></td>
<td><code>[:alnum:]</code> 匹配字母+数字，<code>+</code> 表示至少1个，仅返回纯字母数字的用户名</td>
</tr>
<tr class="even">
<td><code>[:alpha:]</code></td>
<td><code>SELECT * FROM employees WHERE username REGEXP '^[:alpha:]+$';</code></td>
<td><code>[:alpha:]</code> 匹配任意大小写字母（同<code>[a-zA-Z]</code>），仅返回纯字母用户名（如“Zhang”“Li”“WANG”），不匹配含数字/符号的用户名</td>
</tr>
<tr class="odd">
<td><code>[:blank:]</code></td>
<td><code>SELECT * FROM employees WHERE remark REGEXP '[:blank:]';</code></td>
<td><code>[:blank:]</code> 仅匹配空格（<code></code>）和制表符（<code>\t</code>），返回备注中含这两种字符的员工</td>
</tr>
<tr class="even">
<td><code>[:cntrl:]</code></td>
<td><code>SELECT * FROM employees WHERE remark REGEXP '[:cntrl:]';</code></td>
<td><code>[:cntrl:]</code> 匹配ASCII 0-31（如<code>\n</code>、<code>\r</code>）和127的控制字符（不可见），返回备注中含这类字符的员工</td>
</tr>
<tr class="odd">
<td><code>[:graph:]</code></td>
<td><code>SELECT * FROM employees WHERE username REGEXP '^[:graph:]+$';</code></td>
<td><code>[:graph:]</code> 匹配字母、数字、符号（无空格），仅返回无空格的可见字符用户名（如“Zhang123!”“Li_456”）</td>
</tr>
<tr class="even">
<td><code>[:print:]</code></td>
<td><code>SELECT * FROM employees WHERE remark REGEXP '^[:print:]*$';</code></td>
<td><code>[:print:]</code> 匹配所有可打印字符（字母、数字、符号、空格），不含控制字符，返回备注中无隐藏控制字符的员工</td>
</tr>
<tr class="odd">
<td><code>[:punct:]</code></td>
<td><code>SELECT * FROM employees WHERE username REGEXP '[:punct:]';</code></td>
<td><code>[:punct:]</code> 匹配标点符号（如<code>_</code>、<code>-</code>、<code>!</code>、<code>@</code>），返回用户名含这类符号的员工（如“Zhang_123”“Li-Min”）</td>
</tr>
<tr class="even">
<td><code>[:xdigit:]</code></td>
<td><code>SELECT * FROM employees WHERE device_no REGEXP '^[:xdigit:]{8}$';</code></td>
<td><code>[:xdigit:]</code> 匹配十六进制数字（0-9、a-f、A-F），<code>{8}</code> 限制8位，仅返回8位纯十六进制设备编号</td>
</tr>
</tbody>
</table>
<p>注意：字符类必须放在 <code>[]</code> 内（如 <code>[:digit:]</code> 等价于 <code>[0-9]</code>），单独使用无效。</p>
<h4 id="使用重复元字符匹配多个字符">使用重复元字符匹配多个字符</h4>
<p>作用：控制前一个字符/模式的匹配次数（如0次、1次、多次），无需重复书写相同规则，简化复杂匹配。</p>
<p>用法示例（基于 <code>employees</code> 表相关字段）：</p>
<table>
<colgroup>
<col style="width: 7%" />
<col style="width: 46%" />
<col style="width: 46%" />
</colgroup>
<thead>
<tr class="header">
<th>重复元字符</th>
<th>示例SQL（需求）</th>
<th>结果说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>*</code></td>
<td>查询姓名以“张”开头，后面可跟0个或多个字符的员工：<br><code>SELECT * FROM employees WHERE name REGEXP '^张.*';</code></td>
<td>返回“张”“张三”“张伟明”等（包括仅“张”的姓名）</td>
</tr>
<tr class="even">
<td><code>+</code></td>
<td>查询姓名以“张”开头，后面至少跟1个字符的员工：<br><code>SELECT * FROM employees WHERE name REGEXP '^张+';</code></td>
<td>返回“张三”“张伟明”（排除仅“张”的姓名），<code>+</code> 表示至少1次匹配</td>
</tr>
<tr class="odd">
<td><code>?</code></td>
<td>查询姓名为“张”或“张三”的员工：<br><code>SELECT * FROM employees WHERE name REGEXP '^张三?';</code></td>
<td><code>?</code> 匹配前一个字符“三”0次或1次，即匹配“张”或“张三”</td>
</tr>
<tr class="even">
<td><code>{n}</code></td>
<td>查询手机号为11位数字的员工：<br><code>SELECT * FROM employees WHERE phone REGEXP '^[0-9]{11}$';</code></td>
<td><code>{11}</code> 表示匹配前一个模式（数字）恰好11次，仅返回11位手机号</td>
</tr>
<tr class="odd">
<td><code>{n,}</code></td>
<td>查询姓名至少3个字符的员工：<br><code>SELECT * FROM employees WHERE name REGEXP '^.{3,}$';</code></td>
<td><code>{3,}</code> 表示匹配任意字符至少3次，返回3字及以上姓名（如“张伟明”）</td>
</tr>
<tr class="even">
<td><code>{n,m}</code></td>
<td>查询姓名为2-4个字符的员工：<br><code>SELECT * FROM employees WHERE name REGEXP '^.{2,4}$';</code></td>
<td><code>{2,4}</code> 表示匹配任意字符2-4次，返回2-4字姓名（如“张三”“张伟明”）</td>
</tr>
</tbody>
</table>
<h4 id="使用定位符匹配位置">使用定位符匹配位置</h4>
<p>作用：匹配“字符串的位置”（而非具体字符），如开头、结尾、单词边界，用于精准控制匹配的位置范围。</p>
<p>用法示例（基于 <code>employees</code> 表相关字段）：</p>
<table>
<colgroup>
<col style="width: 13%" />
<col style="width: 43%" />
<col style="width: 43%" />
</colgroup>
<thead>
<tr class="header">
<th>定位符</th>
<th>示例SQL（需求）</th>
<th>结果说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>^</code>（文本开头）</td>
<td>查询部门以“技术”开头的员工：<br><code>SELECT * FROM employees WHERE department REGEXP '^技术';</code></td>
<td>返回“技术部”（以“技术”开头），若存在“技术支持部”也会被匹配</td>
</tr>
<tr class="even">
<td><code>$</code>（文本结尾）</td>
<td>查询邮箱以“<span class="citation" data-cites="163.com">@163.com</span>”结尾的员工：<br><code>SELECT * FROM employees WHERE email REGEXP '@163.com$';</code></td>
<td>仅返回邮箱后缀为“<span class="citation" data-cites="163.com">@163.com</span>”的员工，避免匹配“xxx@163.com.cn”</td>
</tr>
<tr class="odd">
<td><code>[[:&lt;:]]</code>（词开头）</td>
<td>查询备注中包含“核心”单词（独立单词）的员工：<br><code>SELECT * FROM employees WHERE remark REGEXP '[[:&lt;:]]核心[[:&gt;:]]';</code></td>
<td>仅匹配“核心”作为独立单词（如“核心员工”），不匹配“非核心员工”“核心技术”（“核心”非独立单词）</td>
</tr>
<tr class="even">
<td><code>[[:&gt;:]]</code>（词结尾）</td>
<td>同上，配合 <code>[[:&lt;:]]</code> 实现独立单词匹配</td>
<td>-</td>
</tr>
</tbody>
</table>
<p>注意：<code>^</code> 和 <code>$</code> 匹配整个字符串的开头/结尾，<code>[[:&lt;:]]</code> 和 <code>[[:&gt;:]]</code> 匹配单词的开头/结尾（单词以空白字符或特殊符号分隔）。</p>
<h4 id="的双重用途">^ 的双重用途</h4>
<p>说明：<code>^</code> 是正则中唯一具有“双重含义”的元字符，含义由其位置决定：</p>
<ol type="1">
<li>当 <code>^</code> 在 <strong><code>[]</code> 外部</strong>时：作为定位符，匹配“整个字符串的开头”（如 3.5.5.8 中的示例）；</li>
<li>当 <code>^</code> 在 <strong><code>[]</code> 内部</strong>时：表示“否定字符集”，匹配“不在括号内的任意一个字符”。</li>
</ol>
<p>用法示例：</p>
<ol type="1">
<li><code>^</code> 在 <code>[]</code> 外部（定位符）： 需求：查询姓名以“王”开头的员工：</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> name REGEXP <span class="string">&#x27;^王&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>结果返回姓名以“王”开头的员工（如“王五”）。</p>
<ol start="2" type="1">
<li><code>^</code> 在 <code>[]</code> 内部（否定字符集）： 需求：查询姓名首字<strong>不是</strong>“张”“李”“王”的员工：</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> name REGEXP <span class="string">&#x27;^[^张李王]&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>解析：<code>^</code> 表示字符串开头，<code>[^张李王]</code> 表示“首字不在张、李、王中的任意一个字符”，结果返回 赵六（首字“赵”）。</p>
<p>补充示例：查询手机号<strong>不含</strong>数字3的员工：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> phone REGEXP <span class="string">&#x27;[^3]&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>结果返回手机号中没有数字3的员工，<code>[^3]</code> 匹配任意不是3的字符。</p>
<p>注意：<code>[^...]</code> 仅否定括号内的字符集，仍匹配1个任意字符，并非“不包含该字符集”（若需“不包含某字符”，需结合重复元字符，如 <code>^[^3]*$</code> 表示整个字符串不含3）。</p>
<h2 id="创建计算字段">创建计算字段</h2>
<ul>
<li>概念： 计算字段：是<strong>查询时通过函数运算、字符串拼接等方式动态生成的字段</strong>。 这些字段不存在于原表中，仅在查询结果中临时显示，不会修改数据库的原始数据。核心作用是 “按需加工数据”，让查询结果更贴合实际需求（比如拼接名称、计算数值、清理无效空格）。</li>
</ul>
<h3 id="concat函数拼接字段"><code>CONCAT()</code>函数（拼接字段）</h3>
<p>将<strong>多个字符串、字段值拼接成一个完整字符串</strong>，支持同时拼接 “字段 + 固定文本”“字段 + 字段”，灵活组合数据。</p>
<p><strong>注意</strong>：若拼接的字段 / 值中包含 <code>NULL</code>，整个拼接结果会返回 <code>NULL</code>（可改用 <code>CONCAT_WS()</code> 函数避免，下文补充）。</p>
<h4 id="语法格式">语法格式</h4>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CONCAT(字段<span class="number">1</span><span class="operator">/</span>字符串<span class="number">1</span>, 字段<span class="number">2</span><span class="operator">/</span>字符串<span class="number">2</span>, ...)</span><br></pre></td></tr></table></figure>
<h4 id="实操示例基于-employees-表">实操示例（基于 <code>employees</code> 表）</h4>
<h5 id="示例-1拼接-姓名-部门字段-固定文本-字段">示例 1：拼接 “姓名 + 部门”（字段 + 固定文本 + 字段）</h5>
<p>需求：查询员工的 “姓名 - 所属部门” 组合信息，比如 “张三 - 技术部”：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">  name,</span><br><span class="line">  department,</span><br><span class="line">  CONCAT(name, <span class="string">&#x27;-&#x27;</span>, department) <span class="keyword">AS</span> 员工部门信息  <span class="comment">-- 拼接姓名、固定字符“-”、部门</span></span><br><span class="line"><span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure>
<p>结果说明：返回 3 列 —— 原有的<code>name</code>（姓名）、<code>department</code>（部门），以及动态生成的<code>员工部门信息</code>（拼接结果）。</p>
<h5 id="示例-2拼接-姓名-邮箱后缀字段-固定文本">示例 2：拼接 “姓名 + 邮箱后缀”（字段 + 固定文本）</h5>
<p>需求：给没有邮箱的员工生成默认邮箱（姓名小写 +@<a target="_blank" rel="noopener" href="https://company.com/">company.com</a>）：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">  name,</span><br><span class="line">  CONCAT(<span class="built_in">LOWER</span>(name), <span class="string">&#x27;@company.com&#x27;</span>) <span class="keyword">AS</span> default_email  <span class="comment">-- 结合LOWER()函数转小写</span></span><br><span class="line"><span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure>
<p>结果说明：若姓名为 “张三”，则生成默认邮箱 “zhangsan@company.com”（需配合文本函数使用，更灵活）。</p>
<h4 id="补充concat_ws-避免-null-问题">补充：<code>CONCAT_WS()</code> 避免 <code>NULL</code> 问题</h4>
<p>若拼接字段可能为 <code>NULL</code>（比如部分员工没有备注），用 <code>CONCAT_WS(分隔符, 字段1, 字段2...)</code> 会自动忽略 <code>NULL</code>，仅拼接非空内容：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 拼接“姓名-部门-备注”，备注为NULL时仅显示“姓名-部门”</span></span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">  CONCAT_WS(<span class="string">&#x27;-&#x27;</span>, name, department, remark) <span class="keyword">AS</span> 员工完整信息</span><br><span class="line"><span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure>
<h3 id="ltrim-rtrim-trim函数去除空格"><code>LTRIM()</code>/ <code>RTRIM()</code>/ <code>TRIM()</code>函数（去除空格）</h3>
<p>实际业务中，字段可能因用户输入错误、数据导入问题包含<strong>多余空格</strong>（比如姓名前的空格、备注后的空格），这些函数用于清理空格，让数据更规范：</p>
<ul>
<li><code>LTRIM(字段)</code>：去除字段值<strong>左侧（开头）</strong> 的空格；</li>
<li><code>RTRIM(字段)</code>：去除字段值<strong>右侧（结尾）</strong> 的空格；</li>
<li><code>TRIM(字段)</code>：去除字段值<strong>左右两侧</strong>的空格（最常用）。</li>
</ul>
<h4 id="语法格式-1">语法格式</h4>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LTRIM(需要清理的字段)</span><br><span class="line">RTRIM(需要清理的字段)</span><br><span class="line"><span class="built_in">TRIM</span>(需要清理的字段)</span><br></pre></td></tr></table></figure>
<h4 id="实操示例基于-employees-表-1">实操示例（基于 <code>employees</code> 表）</h4>
<p>需求：清理 <code>remark</code>（备注）字段的前后空格，避免查询时因空格导致匹配失败：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">  remark <span class="keyword">AS</span> 清理前备注,</span><br><span class="line">  <span class="built_in">TRIM</span>(remark) <span class="keyword">AS</span> 清理后备注,</span><br><span class="line">  LTRIM(remark) <span class="keyword">AS</span> 仅清左空格,</span><br><span class="line">  RTRIM(remark) <span class="keyword">AS</span> 仅清右空格</span><br><span class="line"><span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure>
<p>结果说明：若原备注为 “ 核心员工 ”（前后各 1 个空格），则：</p>
<ul>
<li>清理后备注：“核心员工”（无空格）；</li>
<li>仅清左空格：“核心员工”（右侧仍有空格）；</li>
<li>仅清右空格：“ 核心员工”（左侧仍有空格）。</li>
</ul>
<h4 id="实际应用场景">实际应用场景</h4>
<p>比如模糊查询时，若用户输入 “核心员工”，而字段存 “ 核心员工 ”，直接查询会匹配失败，用 <code>TRIM()</code> 预处理即可：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 清理空格后再匹配，避免漏查</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> <span class="built_in">TRIM</span>(remark) <span class="keyword">LIKE</span> <span class="string">&#x27;%核心员工%&#x27;</span>;</span><br></pre></td></tr></table></figure>
<h3 id="as-关键字字段别名">AS 关键字（字段别名）</h3>
<p>计算字段的结果列名默认是 “函数 / 运算表达式”（比如 <code>CONCAT(name, '-', department)</code>），可读性差。<code>AS</code> 关键字用于给字段、计算结果起<strong>简洁易懂的别名</strong>，有助于：</p>
<ul>
<li>简化列名：避免查询结果中出现冗长的表达式；</li>
<li>提升可读性：让他人（或自己后续查看）快速理解列含义；</li>
<li>支持后续操作：比如对计算结果排序、筛选（用别名更简洁）。</li>
</ul>
<h4 id="语法格式-2">语法格式</h4>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">字段名<span class="operator">/</span>计算表达式 <span class="keyword">AS</span> 别名  <span class="comment">-- AS可省略，推荐保留（更规范）</span></span><br></pre></td></tr></table></figure>
<h4 id="实操示例基于-employees-表-2">实操示例（基于 <code>employees</code> 表）</h4>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">  name <span class="keyword">AS</span> 员工姓名,  <span class="comment">-- 给原有字段起别名（简化列名）</span></span><br><span class="line">  salary <span class="keyword">AS</span> 月薪,</span><br><span class="line">  salary <span class="operator">*</span> <span class="number">12</span> <span class="keyword">AS</span> 年薪,  <span class="comment">-- 给算术计算结果起别名</span></span><br><span class="line">  CONCAT(name, <span class="string">&#x27;-&#x27;</span>, department) <span class="keyword">AS</span> 员工部门信息  <span class="comment">-- 给拼接结果起别名</span></span><br><span class="line"><span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure>
<p>结果说明：查询结果的列名会显示为 “员工姓名”“月薪”“年薪”“员工部门信息”，而非原始字段名或复杂表达式。</p>
<h4 id="实操示例别名含特殊字符用引号包裹">实操示例：别名含特殊字符（用引号包裹）</h4>
<p>若别名需要包含空格、中文符号，用单引号 / 双引号包裹：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">  salary <span class="operator">*</span> <span class="number">1.1</span> <span class="keyword">AS</span> <span class="string">&#x27;涨薪10%后薪资&#x27;</span>,  <span class="comment">-- 别名含空格和百分号，用引号包裹</span></span><br><span class="line">  CONCAT(name, <span class="string">&#x27;（&#x27;</span>, department, <span class="string">&#x27;）&#x27;</span>) <span class="keyword">AS</span> <span class="string">&#x27;员工（部门）&#x27;</span></span><br><span class="line"><span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure>
<h3 id="算术计算加减乘除取模">算术计算（加减乘除、取模%）</h3>
<p>对表中的<strong>数值类型字段</strong>（如薪资、年龄、数量等）执行算术运算，动态生成计算结果（如年薪、折扣价、总和等）。</p>
<h4 id="支持的运算类型">支持的运算类型</h4>
<table>
<thead>
<tr class="header">
<th>运算符号</th>
<th>功能</th>
<th>适用场景</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>+</code></td>
<td>加法</td>
<td>计算总和（薪资 + 奖金）</td>
</tr>
<tr class="even">
<td><code>-</code></td>
<td>减法</td>
<td>计算差值（原价 - 优惠价）</td>
</tr>
<tr class="odd">
<td><code>*</code></td>
<td>乘法</td>
<td>计算年薪（月薪 ×12）</td>
</tr>
<tr class="even">
<td><code>/</code></td>
<td>除法</td>
<td>计算平均值、折扣</td>
</tr>
<tr class="odd">
<td><code>%</code></td>
<td>取模（余数）</td>
<td>判断奇偶、循环编号</td>
</tr>
</tbody>
</table>
<h4 id="实操示例基于-employees-表-3">实操示例（基于 <code>employees</code> 表）</h4>
<h5 id="示例-1计算年薪乘法">示例 1：计算年薪（乘法）</h5>
<p>需求：查询员工月薪、年终奖（月薪 ×2）、年薪（月薪 ×12 + 年终奖）：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">  name <span class="keyword">AS</span> 员工姓名,</span><br><span class="line">  salary <span class="keyword">AS</span> 月薪,</span><br><span class="line">  salary <span class="operator">*</span> <span class="number">2</span> <span class="keyword">AS</span> 年终奖,</span><br><span class="line">  salary <span class="operator">*</span> <span class="number">12</span> <span class="operator">+</span> (salary <span class="operator">*</span> <span class="number">2</span>) <span class="keyword">AS</span> 税前年薪</span><br><span class="line"><span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure>
<h5 id="示例-2计算薪资差值减法">示例 2：计算薪资差值（减法）</h5>
<p>需求：查询员工薪资与公司平均薪资的差值（假设平均薪资为 6000）：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">  name <span class="keyword">AS</span> 员工姓名,</span><br><span class="line">  salary <span class="keyword">AS</span> 月薪,</span><br><span class="line">  salary <span class="operator">-</span> <span class="number">6000</span> <span class="keyword">AS</span> 与平均薪资差值  <span class="comment">-- 差值可为正（高于平均）或负（低于平均）</span></span><br><span class="line"><span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure>
<h5 id="示例-3取模判断奇偶">示例 3：取模判断奇偶（%）</h5>
<p>需求：查询员工工号（假设为数值类型），并判断奇偶（奇数为 1，偶数为 0）：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">  emp_id <span class="keyword">AS</span> 工号,</span><br><span class="line">  name <span class="keyword">AS</span> 员工姓名,</span><br><span class="line">  emp_id <span class="operator">%</span> <span class="number">2</span> <span class="keyword">AS</span> 工号奇偶  <span class="comment">-- 结果为0→偶数，1→奇数</span></span><br><span class="line"><span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure>
<h4 id="注意事项">注意事项</h4>
<ol type="1">
<li>仅支持数值类型：若对字符串字段做算术运算，会返回 <code>0</code> 或错误（需确保字段是 <code>INT</code>/<code>DECIMAL</code> 等数值类型）；</li>
<li>除法精度：MySQL 中整数除法会自动取整（比如 <code>7/2=3</code>），若需保留小数，可加 <code>1.0</code> 转为浮点运算（<code>7/2.0=3.5</code>）；</li>
<li>避免除以 0：若除法的分母是字段，需用 <code>WHERE</code> 筛选排除 <code>0</code>（比如 <code>WHERE bonus != 0</code>），否则会返回 <code>NULL</code>。</li>
</ol>
<h2 id="数据处理函数">数据处理函数</h2>
<p>MySQL提供了丰富的数据处理函数，用于对查询结果进行各种转换、计算和格式化操作。这些函数可以在SELECT、WHERE等子句中使用，大大增强了数据查询和处理的灵活性。</p>
<h3 id="文本函数upperlowerlength等">文本函数（<code>UPPER()</code>/<code>LOWER()</code>/<code>LENGTH()</code>等）</h3>
<p>文本函数主要用于处理字符串类型的数据，如大小写转换、长度计算、截取等。</p>
<h4 id="常用文本函数表">常用文本函数表</h4>
<table>
<colgroup>
<col style="width: 25%" />
<col style="width: 32%" />
<col style="width: 21%" />
<col style="width: 21%" />
</colgroup>
<thead>
<tr class="header">
<th>函数名</th>
<th>功能说明</th>
<th>示例</th>
<th>结果</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>UPPER(str)</code></td>
<td>将字符串转换为大写</td>
<td><code>UPPER('hello')</code></td>
<td><code>'HELLO'</code></td>
</tr>
<tr class="even">
<td><code>LOWER(str)</code></td>
<td>将字符串转换为小写</td>
<td><code>LOWER('HELLO')</code></td>
<td><code>'hello'</code></td>
</tr>
<tr class="odd">
<td><code>LENGTH(str)</code></td>
<td>返回字符串的字节长度</td>
<td><code>LENGTH('你好')</code></td>
<td><code>6</code> (UTF-8编码下一个中文占3字节)</td>
</tr>
<tr class="even">
<td><code>CHAR_LENGTH(str)</code></td>
<td>返回字符串的字符个数</td>
<td><code>CHAR_LENGTH('你好')</code></td>
<td><code>2</code></td>
</tr>
<tr class="odd">
<td><code>SUBSTRING(str, pos, len)</code></td>
<td>截取字符串（从pos位置开始，截取len个字符）</td>
<td><code>SUBSTRING('HelloWorld', 1, 5)</code></td>
<td><code>'Hello'</code></td>
</tr>
<tr class="even">
<td><code>LEFT(str, len)</code></td>
<td>截取字符串左侧的len个字符</td>
<td><code>LEFT('HelloWorld', 5)</code></td>
<td><code>'Hello'</code></td>
</tr>
<tr class="odd">
<td><code>RIGHT(str, len)</code></td>
<td>截取字符串右侧的len个字符</td>
<td><code>RIGHT('HelloWorld', 5)</code></td>
<td><code>'World'</code></td>
</tr>
<tr class="even">
<td><code>INSTR(str, substr)</code></td>
<td>返回子串在字符串中第一次出现的位置</td>
<td><code>INSTR('HelloWorld', 'o')</code></td>
<td><code>5</code></td>
</tr>
<tr class="odd">
<td><code>REPLACE(str, from_s, to_s)</code></td>
<td>替换字符串中的子串</td>
<td><code>REPLACE('HelloWorld', 'o', '*')</code></td>
<td><code>'Hell*W*rld'</code></td>
</tr>
<tr class="even">
<td><code>CONCAT(str1, str2, ...)</code></td>
<td>拼接多个字符串</td>
<td><code>CONCAT('Hello', ' ', 'World')</code></td>
<td><code>'Hello World'</code></td>
</tr>
<tr class="odd">
<td><code>CONCAT_WS(sep, str1, str2, ...)</code></td>
<td>使用分隔符拼接字符串，忽略NULL值</td>
<td><code>CONCAT_WS('-', '2023', '10', '25')</code></td>
<td><code>'2023-10-25'</code></td>
</tr>
<tr class="even">
<td><code>TRIM([BOTH/LEADING/TRAILING] str FROM str1)</code></td>
<td>去除字符串前后空格或指定字符</td>
<td><code>TRIM('  Hello  ')</code></td>
<td><code>'Hello'</code></td>
</tr>
<tr class="odd">
<td><code>LPAD(str, len, padstr)</code></td>
<td>用指定字符左填充字符串到指定长度</td>
<td><code>LPAD('123', 5, '0')</code></td>
<td><code>'00123'</code></td>
</tr>
<tr class="even">
<td><code>RPAD(str, len, padstr)</code></td>
<td>用指定字符右填充字符串到指定长度</td>
<td><code>RPAD('123', 5, '0')</code></td>
<td><code>'12300'</code></td>
</tr>
</tbody>
</table>
<h4 id="语法格式与示例">语法格式与示例</h4>
<h5 id="upperlower---大小写转换">1. <code>UPPER()</code>/<code>LOWER()</code> - 大小写转换</h5>
<p><strong>语法</strong>： <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UPPER</span>(字符串<span class="operator">/</span>字段名)</span><br><span class="line"><span class="built_in">LOWER</span>(字符串<span class="operator">/</span>字段名)</span><br></pre></td></tr></table></figure></p>
<p><strong>示例</strong>： <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 转换员工姓名为大写和小写</span></span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">  name <span class="keyword">AS</span> 原始姓名,</span><br><span class="line">  <span class="built_in">UPPER</span>(name) <span class="keyword">AS</span> 大写姓名,</span><br><span class="line">  <span class="built_in">LOWER</span>(name) <span class="keyword">AS</span> 小写姓名</span><br><span class="line"><span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure></p>
<h5 id="lengthchar_length---长度计算">2. <code>LENGTH()</code>/<code>CHAR_LENGTH()</code> - 长度计算</h5>
<p><strong>语法</strong>： <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LENGTH(字符串<span class="operator">/</span>字段名)</span><br><span class="line"><span class="keyword">CHAR_LENGTH</span>(字符串<span class="operator">/</span>字段名)</span><br></pre></td></tr></table></figure></p>
<p><strong>示例</strong>： <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 计算员工姓名的字节长度和字符个数</span></span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">  name <span class="keyword">AS</span> 姓名,</span><br><span class="line">  LENGTH(name) <span class="keyword">AS</span> 字节长度,</span><br><span class="line">  <span class="keyword">CHAR_LENGTH</span>(name) <span class="keyword">AS</span> 字符个数</span><br><span class="line"><span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure></p>
<p><strong>注意</strong>： - 在UTF-8编码下，一个中文字符通常占用3个字节 - 对于多字节字符集，<code>LENGTH()</code>和<code>CHAR_LENGTH()</code>结果可能不同</p>
<h5 id="substring---字符串截取">3. <code>SUBSTRING()</code> - 字符串截取</h5>
<p><strong>语法</strong>： <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">SUBSTRING</span>(字符串<span class="operator">/</span>字段名, 起始位置, 截取长度)</span><br><span class="line"><span class="comment">-- 或使用别名</span></span><br><span class="line">SUBSTR(字符串<span class="operator">/</span>字段名, 起始位置, 截取长度)</span><br></pre></td></tr></table></figure></p>
<p><strong>示例</strong>： <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 截取邮箱的前5个字符</span></span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">  email <span class="keyword">AS</span> 完整邮箱,</span><br><span class="line">  <span class="built_in">SUBSTRING</span>(email, <span class="number">1</span>, <span class="number">5</span>) <span class="keyword">AS</span> 邮箱前缀</span><br><span class="line"><span class="keyword">FROM</span> employees;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 截取从第6个字符开始到结尾的部分（省略长度参数）</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">SUBSTRING</span>(email, <span class="number">6</span>) <span class="keyword">AS</span> 邮箱后缀</span><br><span class="line"><span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure></p>
<h5 id="replace---字符串替换">4. <code>REPLACE()</code> - 字符串替换</h5>
<p><strong>语法</strong>： <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">REPLACE(原始字符串<span class="operator">/</span>字段名, 被替换子串, 替换为的子串)</span><br></pre></td></tr></table></figure></p>
<p><strong>示例</strong>： <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 将邮箱中的&#x27;@company.com&#x27;替换为&#x27;@newcompany.com&#x27;</span></span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">  email <span class="keyword">AS</span> 原邮箱,</span><br><span class="line">  REPLACE(email, <span class="string">&#x27;@company.com&#x27;</span>, <span class="string">&#x27;@newcompany.com&#x27;</span>) <span class="keyword">AS</span> 新邮箱</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> email <span class="keyword">LIKE</span> <span class="string">&#x27;%@company.com&#x27;</span>;</span><br></pre></td></tr></table></figure></p>
<h5 id="instr---查找子串位置">5. <code>INSTR()</code> - 查找子串位置</h5>
<p><strong>语法</strong>： <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSTR(原始字符串<span class="operator">/</span>字段名, 要查找的子串)</span><br></pre></td></tr></table></figure></p>
<p><strong>示例</strong>： <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查找邮箱中&#x27;@&#x27;符号的位置</span></span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">  email,</span><br><span class="line">  INSTR(email, <span class="string">&#x27;@&#x27;</span>) <span class="keyword">AS</span> at_position</span><br><span class="line"><span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure></p>
<h3 id="数值函数roundabsfloor等">数值函数（<code>ROUND()</code>/<code>ABS()</code>/<code>FLOOR()</code>等）</h3>
<p>数值函数用于对数值类型的数据进行各种数学运算和处理，如四舍五入、取整、绝对值等。</p>
<h4 id="常用数值函数表">常用数值函数表</h4>
<table>
<thead>
<tr class="header">
<th>函数名</th>
<th>功能说明</th>
<th>示例</th>
<th>结果</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>ROUND(x, d)</code></td>
<td>四舍五入到指定小数位</td>
<td><code>ROUND(123.456, 2)</code></td>
<td><code>123.46</code></td>
</tr>
<tr class="even">
<td><code>FLOOR(x)</code></td>
<td>向下取整（返回不大于x的最大整数）</td>
<td><code>FLOOR(123.99)</code></td>
<td><code>123</code></td>
</tr>
<tr class="odd">
<td><code>CEIL(x)</code>/<code>CEILING(x)</code></td>
<td>向上取整（返回不小于x的最小整数）</td>
<td><code>CEIL(123.01)</code></td>
<td><code>124</code></td>
</tr>
<tr class="even">
<td><code>ABS(x)</code></td>
<td>返回x的绝对值</td>
<td><code>ABS(-123)</code></td>
<td><code>123</code></td>
</tr>
<tr class="odd">
<td><code>MOD(x, y)</code></td>
<td>返回x除以y的余数</td>
<td><code>MOD(10, 3)</code></td>
<td><code>1</code></td>
</tr>
<tr class="even">
<td><code>POW(x, y)</code>/<code>POWER(x, y)</code></td>
<td>返回x的y次方</td>
<td><code>POW(2, 3)</code></td>
<td><code>8</code></td>
</tr>
<tr class="odd">
<td><code>SQRT(x)</code></td>
<td>返回x的平方根</td>
<td><code>SQRT(16)</code></td>
<td><code>4</code></td>
</tr>
<tr class="even">
<td><code>RAND()</code></td>
<td>返回0到1之间的随机数</td>
<td><code>RAND()</code></td>
<td>如<code>0.732456...</code></td>
</tr>
<tr class="odd">
<td><code>SIGN(x)</code></td>
<td>返回x的符号（-1、0或1）</td>
<td><code>SIGN(-5)</code></td>
<td><code>-1</code></td>
</tr>
<tr class="even">
<td><code>EXP(x)</code></td>
<td>返回e的x次方</td>
<td><code>EXP(1)</code></td>
<td><code>2.71828...</code></td>
</tr>
<tr class="odd">
<td><code>LOG(x)</code></td>
<td>返回x的自然对数</td>
<td><code>LOG(2.71828)</code></td>
<td><code>1</code></td>
</tr>
<tr class="even">
<td><code>LOG10(x)</code></td>
<td>返回x的以10为底的对数</td>
<td><code>LOG10(100)</code></td>
<td><code>2</code></td>
</tr>
</tbody>
</table>
<h4 id="语法格式与示例-1">语法格式与示例</h4>
<h5 id="round---四舍五入">1. <code>ROUND()</code> - 四舍五入</h5>
<p><strong>语法</strong>： <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ROUND(数值<span class="operator">/</span>字段名 [, 小数位数])</span><br></pre></td></tr></table></figure></p>
<p><strong>示例</strong>： <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 对员工薪资进行四舍五入</span></span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">  name <span class="keyword">AS</span> 员工姓名,</span><br><span class="line">  salary <span class="keyword">AS</span> 原始薪资,</span><br><span class="line">  ROUND(salary) <span class="keyword">AS</span> 整数薪资,</span><br><span class="line">  ROUND(salary, <span class="number">1</span>) <span class="keyword">AS</span> 一位小数薪资</span><br><span class="line"><span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure></p>
<p><strong>注意</strong>： - 小数位数参数可选，默认为0（即四舍五入到整数） - 小数位数为负数时，表示四舍五入到十位、百位等位置</p>
<h5 id="floorceil---取整">2. <code>FLOOR()</code>/<code>CEIL()</code> - 取整</h5>
<p><strong>语法</strong>： <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">FLOOR</span>(数值<span class="operator">/</span>字段名)</span><br><span class="line"><span class="built_in">CEIL</span>(数值<span class="operator">/</span>字段名) 或 <span class="built_in">CEILING</span>(数值<span class="operator">/</span>字段名)</span><br></pre></td></tr></table></figure></p>
<p><strong>示例</strong>： <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 计算员工薪资的向下取整和向上取整值</span></span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">  name <span class="keyword">AS</span> 员工姓名,</span><br><span class="line">  salary <span class="keyword">AS</span> 原始薪资,</span><br><span class="line">  <span class="built_in">FLOOR</span>(salary) <span class="keyword">AS</span> 向下取整,</span><br><span class="line">  <span class="built_in">CEIL</span>(salary) <span class="keyword">AS</span> 向上取整</span><br><span class="line"><span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure></p>
<h5 id="abs---绝对值">3. <code>ABS()</code> - 绝对值</h5>
<p><strong>语法</strong>： <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ABS</span>(数值<span class="operator">/</span>字段名)</span><br></pre></td></tr></table></figure></p>
<p><strong>示例</strong>： <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 计算员工薪资与平均薪资的差值绝对值</span></span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">  name <span class="keyword">AS</span> 员工姓名,</span><br><span class="line">  salary <span class="keyword">AS</span> 原始薪资,</span><br><span class="line">  salary <span class="operator">-</span> <span class="number">6000</span> <span class="keyword">AS</span> 薪资差值,</span><br><span class="line">  <span class="built_in">ABS</span>(salary <span class="operator">-</span> <span class="number">6000</span>) <span class="keyword">AS</span> 绝对差值</span><br><span class="line"><span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure></p>
<h5 id="rand---随机数生成">4. <code>RAND()</code> - 随机数生成</h5>
<p><strong>语法</strong>： <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RAND([种子值])</span><br></pre></td></tr></table></figure></p>
<p><strong>示例</strong>： <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 生成随机数（无种子值，每次调用结果不同）</span></span><br><span class="line"><span class="keyword">SELECT</span> RAND() <span class="keyword">AS</span> 随机数;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 生成随机排序的员工列表</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees <span class="keyword">ORDER</span> <span class="keyword">BY</span> RAND();</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 随机选择5名员工</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees <span class="keyword">ORDER</span> <span class="keyword">BY</span> RAND() LIMIT <span class="number">5</span>;</span><br></pre></td></tr></table></figure></p>
<h3 id="日期时间函数nowdate_formatdatediff等">日期时间函数（<code>NOW()</code>/<code>DATE_FORMAT()</code>/<code>DATEDIFF()</code>等）</h3>
<p>日期时间函数用于处理日期和时间类型的数据，如获取当前时间、格式化日期、计算日期差值等。</p>
<h4 id="常用日期时间函数表">常用日期时间函数表</h4>
<table>
<colgroup>
<col style="width: 25%" />
<col style="width: 32%" />
<col style="width: 21%" />
<col style="width: 21%" />
</colgroup>
<thead>
<tr class="header">
<th>函数名</th>
<th>功能说明</th>
<th>示例</th>
<th>结果</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>NOW()</code></td>
<td>返回当前日期和时间</td>
<td><code>NOW()</code></td>
<td><code>2023-10-25 15:30:45</code></td>
</tr>
<tr class="even">
<td><code>CURDATE()</code></td>
<td>返回当前日期（不含时间）</td>
<td><code>CURDATE()</code></td>
<td><code>2023-10-25</code></td>
</tr>
<tr class="odd">
<td><code>CURTIME()</code></td>
<td>返回当前时间（不含日期）</td>
<td><code>CURTIME()</code></td>
<td><code>15:30:45</code></td>
</tr>
<tr class="even">
<td><code>DATE_FORMAT(date, format)</code></td>
<td>按指定格式格式化日期</td>
<td><code>DATE_FORMAT(NOW(), '%Y-%m-%d')</code></td>
<td><code>'2023-10-25'</code></td>
</tr>
<tr class="odd">
<td><code>DATEDIFF(date1, date2)</code></td>
<td>计算两个日期的差值（天数）</td>
<td><code>DATEDIFF('2023-10-25', '2023-10-01')</code></td>
<td><code>24</code></td>
</tr>
<tr class="even">
<td><code>TIMESTAMPDIFF(unit, start, end)</code></td>
<td>计算时间差值（指定单位）</td>
<td><code>TIMESTAMPDIFF(MONTH, '2023-01-01', '2023-10-25')</code></td>
<td><code>9</code></td>
</tr>
<tr class="odd">
<td><code>DATE_ADD(date, INTERVAL expr unit)</code></td>
<td>日期增加指定时间间隔</td>
<td><code>DATE_ADD(CURDATE(), INTERVAL 1 DAY)</code></td>
<td>明天的日期</td>
</tr>
<tr class="even">
<td><code>DATE_SUB(date, INTERVAL expr unit)</code></td>
<td>日期减少指定时间间隔</td>
<td><code>DATE_SUB(CURDATE(), INTERVAL 1 MONTH)</code></td>
<td>上个月的今天</td>
</tr>
<tr class="odd">
<td><code>YEAR(date)</code></td>
<td>提取日期的年份</td>
<td><code>YEAR('2023-10-25')</code></td>
<td><code>2023</code></td>
</tr>
<tr class="even">
<td><code>MONTH(date)</code></td>
<td>提取日期的月份</td>
<td><code>MONTH('2023-10-25')</code></td>
<td><code>10</code></td>
</tr>
<tr class="odd">
<td><code>DAY(date)</code></td>
<td>提取日期的日</td>
<td><code>DAY('2023-10-25')</code></td>
<td><code>25</code></td>
</tr>
<tr class="even">
<td><code>HOUR(time)</code></td>
<td>提取时间的小时</td>
<td><code>HOUR('15:30:45')</code></td>
<td><code>15</code></td>
</tr>
<tr class="odd">
<td><code>MINUTE(time)</code></td>
<td>提取时间的分钟</td>
<td><code>MINUTE('15:30:45')</code></td>
<td><code>30</code></td>
</tr>
<tr class="even">
<td><code>SECOND(time)</code></td>
<td>提取时间的秒</td>
<td><code>SECOND('15:30:45')</code></td>
<td><code>45</code></td>
</tr>
<tr class="odd">
<td><code>DAYNAME(date)</code></td>
<td>返回星期几的名称</td>
<td><code>DAYNAME('2023-10-25')</code></td>
<td><code>'Wednesday'</code></td>
</tr>
<tr class="even">
<td><code>MONTHNAME(date)</code></td>
<td>返回月份的名称</td>
<td><code>MONTHNAME('2023-10-25')</code></td>
<td><code>'October'</code></td>
</tr>
<tr class="odd">
<td><code>LAST_DAY(date)</code></td>
<td>返回指定日期所在月的最后一天</td>
<td><code>LAST_DAY('2023-10-25')</code></td>
<td><code>'2023-10-31'</code></td>
</tr>
<tr class="even">
<td><code>EXTRACT(unit FROM date)</code></td>
<td>提取日期的指定部分</td>
<td><code>EXTRACT(YEAR FROM '2023-10-25')</code></td>
<td><code>2023</code></td>
</tr>
</tbody>
</table>
<h4 id="常用日期时间格式化符号">常用日期时间格式化符号</h4>
<p>在<code>DATE_FORMAT()</code>函数中，常用的格式化符号如下：</p>
<table>
<thead>
<tr class="header">
<th>符号</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>%Y</code></td>
<td>四位年份（如：2023）</td>
</tr>
<tr class="even">
<td><code>%y</code></td>
<td>两位年份（如：23）</td>
</tr>
<tr class="odd">
<td><code>%m</code></td>
<td>两位月份（01-12）</td>
</tr>
<tr class="even">
<td><code>%c</code></td>
<td>月份（1-12）</td>
</tr>
<tr class="odd">
<td><code>%d</code></td>
<td>两位日期（01-31）</td>
</tr>
<tr class="even">
<td><code>%e</code></td>
<td>日期（1-31）</td>
</tr>
<tr class="odd">
<td><code>%H</code></td>
<td>24小时制（00-23）</td>
</tr>
<tr class="even">
<td><code>%h</code></td>
<td>12小时制（01-12）</td>
</tr>
<tr class="odd">
<td><code>%i</code></td>
<td>分钟（00-59）</td>
</tr>
<tr class="even">
<td><code>%s</code></td>
<td>秒（00-59）</td>
</tr>
<tr class="odd">
<td><code>%p</code></td>
<td>AM或PM</td>
</tr>
<tr class="even">
<td><code>%W</code></td>
<td>星期几全名（Sunday-Saturday）</td>
</tr>
<tr class="odd">
<td><code>%w</code></td>
<td>星期几数字（0=Sunday, 6=Saturday）</td>
</tr>
<tr class="even">
<td><code>%M</code></td>
<td>月份全名（January-December）</td>
</tr>
</tbody>
</table>
<h4 id="语法格式与示例-2">语法格式与示例</h4>
<h5 id="获取当前日期时间">1. 获取当前日期时间</h5>
<p><strong>语法</strong>： <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NOW() <span class="comment">-- 返回当前日期和时间</span></span><br><span class="line">CURDATE() <span class="comment">-- 返回当前日期</span></span><br><span class="line">CURTIME() <span class="comment">-- 返回当前时间</span></span><br></pre></td></tr></table></figure></p>
<p><strong>示例</strong>： <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 获取当前时间信息</span></span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">  NOW() <span class="keyword">AS</span> 当前完整时间,</span><br><span class="line">  CURDATE() <span class="keyword">AS</span> 当前日期,</span><br><span class="line">  CURTIME() <span class="keyword">AS</span> 当前时间;</span><br></pre></td></tr></table></figure></p>
<h5 id="date_format---日期格式化">2. <code>DATE_FORMAT()</code> - 日期格式化</h5>
<p><strong>语法</strong>： <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DATE_FORMAT(日期<span class="operator">/</span>时间<span class="operator">/</span>字段名, 格式字符串)</span><br></pre></td></tr></table></figure></p>
<p><strong>示例</strong>： <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 格式化员工入职日期</span></span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">  name <span class="keyword">AS</span> 员工姓名,</span><br><span class="line">  hire_date <span class="keyword">AS</span> 原始入职日期,</span><br><span class="line">  DATE_FORMAT(hire_date, <span class="string">&#x27;%Y年%m月%d日&#x27;</span>) <span class="keyword">AS</span> 格式化日期,</span><br><span class="line">  DATE_FORMAT(hire_date, <span class="string">&#x27;%Y-%m-%d %H:%i:%s&#x27;</span>) <span class="keyword">AS</span> 带时间的格式化</span><br><span class="line"><span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure></p>
<h5 id="datedifftimestampdiff---日期差值计算">3. <code>DATEDIFF()</code>/<code>TIMESTAMPDIFF()</code> - 日期差值计算</h5>
<p><strong>语法</strong>： <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DATEDIFF(日期<span class="number">1</span>, 日期<span class="number">2</span>) <span class="comment">-- 返回日期1 - 日期2的天数差</span></span><br><span class="line">TIMESTAMPDIFF(单位, 开始时间, 结束时间) <span class="comment">-- 返回两个时间的差值（指定单位）</span></span><br></pre></td></tr></table></figure></p>
<p><strong>示例</strong>： <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 计算员工入职天数</span></span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">  name <span class="keyword">AS</span> 员工姓名,</span><br><span class="line">  hire_date <span class="keyword">AS</span> 入职日期,</span><br><span class="line">  DATEDIFF(CURDATE(), hire_date) <span class="keyword">AS</span> 入职天数,</span><br><span class="line">  TIMESTAMPDIFF(<span class="keyword">MONTH</span>, hire_date, CURDATE()) <span class="keyword">AS</span> 入职月数,</span><br><span class="line">  TIMESTAMPDIFF(<span class="keyword">YEAR</span>, hire_date, CURDATE()) <span class="keyword">AS</span> 入职年数</span><br><span class="line"><span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure></p>
<p><strong>注意</strong>： - <code>DATEDIFF()</code> 只考虑日期部分，忽略时间部分 - <code>TIMESTAMPDIFF()</code> 的时间单位可以是：YEAR, MONTH, DAY, HOUR, MINUTE, SECOND等</p>
<h5 id="date_adddate_sub---日期增减">4. <code>DATE_ADD()</code>/<code>DATE_SUB()</code> - 日期增减</h5>
<p><strong>语法</strong>： <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DATE_ADD(日期<span class="operator">/</span>字段名, <span class="type">INTERVAL</span> 数值 单位) <span class="comment">-- 日期增加</span></span><br><span class="line">DATE_SUB(日期<span class="operator">/</span>字段名, <span class="type">INTERVAL</span> 数值 单位) <span class="comment">-- 日期减少</span></span><br></pre></td></tr></table></figure></p>
<p><strong>示例</strong>： <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 计算员工试用期结束日期（假设试用期为3个月）</span></span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">  name <span class="keyword">AS</span> 员工姓名,</span><br><span class="line">  hire_date <span class="keyword">AS</span> 入职日期,</span><br><span class="line">  DATE_ADD(hire_date, <span class="type">INTERVAL</span> <span class="number">3</span> <span class="keyword">MONTH</span>) <span class="keyword">AS</span> 试用期结束日期,</span><br><span class="line">  DATE_SUB(hire_date, <span class="type">INTERVAL</span> <span class="number">1</span> <span class="keyword">DAY</span>) <span class="keyword">AS</span> 入职前一天</span><br><span class="line"><span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure></p>
<h5 id="提取日期时间部分">5. 提取日期时间部分</h5>
<p><strong>语法</strong>： <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">YEAR</span>(<span class="type">date</span>) <span class="comment">-- 提取年份</span></span><br><span class="line"><span class="keyword">MONTH</span>(<span class="type">date</span>) <span class="comment">-- 提取月份</span></span><br><span class="line"><span class="keyword">DAY</span>(<span class="type">date</span>) <span class="comment">-- 提取日</span></span><br><span class="line"><span class="keyword">HOUR</span>(<span class="type">time</span>) <span class="comment">-- 提取小时</span></span><br><span class="line"><span class="keyword">MINUTE</span>(<span class="type">time</span>) <span class="comment">-- 提取分钟</span></span><br><span class="line"><span class="keyword">SECOND</span>(<span class="type">time</span>) <span class="comment">-- 提取秒</span></span><br></pre></td></tr></table></figure></p>
<p><strong>示例</strong>： <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 分析员工入职时间分布</span></span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">  name <span class="keyword">AS</span> 员工姓名,</span><br><span class="line">  hire_date <span class="keyword">AS</span> 入职日期,</span><br><span class="line">  <span class="keyword">YEAR</span>(hire_date) <span class="keyword">AS</span> 入职年份,</span><br><span class="line">  <span class="keyword">MONTH</span>(hire_date) <span class="keyword">AS</span> 入职月份,</span><br><span class="line">  <span class="keyword">DAY</span>(hire_date) <span class="keyword">AS</span> 入职日,</span><br><span class="line">  MONTHNAME(hire_date) <span class="keyword">AS</span> 入职月份名称,</span><br><span class="line">  DAYNAME(hire_date) <span class="keyword">AS</span> 入职星期几</span><br><span class="line"><span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure></p>
<h2 id="聚集函数统计计算">聚集函数（统计计算）</h2>
<p>聚集函数又称为聚合函数或统计函数，主要用于对一组数据进行统计计算并返回单一结果。这些函数通常与GROUP BY子句结合使用，用于数据分组统计分析。</p>
<h3 id="常用函数countsumavgmaxmin">常用函数：<code>COUNT()</code>/<code>SUM()</code>/<code>AVG()</code>/<code>MAX()</code>/<code>MIN()</code></h3>
<h4 id="常用聚集函数表">常用聚集函数表</h4>
<table>
<colgroup>
<col style="width: 25%" />
<col style="width: 32%" />
<col style="width: 21%" />
<col style="width: 21%" />
</colgroup>
<thead>
<tr class="header">
<th>函数名</th>
<th>功能说明</th>
<th>示例</th>
<th>结果</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>COUNT(*)</code></td>
<td>统计表中所有行数（包括NULL值行）</td>
<td><code>COUNT(*)</code></td>
<td>返回表中总记录数</td>
</tr>
<tr class="even">
<td><code>COUNT(列名)</code></td>
<td>统计表中指定列非NULL值的行数</td>
<td><code>COUNT(email)</code></td>
<td>返回非NULL邮箱数量</td>
</tr>
<tr class="odd">
<td><code>COUNT(DISTINCT 列名)</code></td>
<td>统计表中指定列非NULL且不重复值的数量</td>
<td><code>COUNT(DISTINCT department)</code></td>
<td>返回不重复部门数量</td>
</tr>
<tr class="even">
<td><code>SUM(列名)</code></td>
<td>计算指定列数值的总和</td>
<td><code>SUM(salary)</code></td>
<td>返回薪资总和</td>
</tr>
<tr class="odd">
<td><code>AVG(列名)</code></td>
<td>计算指定列数值的平均值</td>
<td><code>AVG(salary)</code></td>
<td>返回平均薪资</td>
</tr>
<tr class="even">
<td><code>MAX(列名)</code></td>
<td>返回指定列的最大值</td>
<td><code>MAX(salary)</code></td>
<td>返回最高薪资</td>
</tr>
<tr class="odd">
<td><code>MIN(列名)</code></td>
<td>返回指定列的最小值</td>
<td><code>MIN(salary)</code></td>
<td>返回最低薪资</td>
</tr>
<tr class="even">
<td><code>GROUP_CONCAT(列名)</code></td>
<td>将分组后的结果连接成字符串</td>
<td><code>GROUP_CONCAT(name)</code></td>
<td>返回用逗号分隔的员工姓名</td>
</tr>
<tr class="odd">
<td><code>VARIANCE(列名)</code></td>
<td>计算指定列数值的方差</td>
<td><code>VARIANCE(salary)</code></td>
<td>返回薪资方差</td>
</tr>
<tr class="even">
<td><code>STDDEV(列名)</code></td>
<td>计算指定列数值的标准差</td>
<td><code>STDDEV(salary)</code></td>
<td>返回薪资标准差</td>
</tr>
</tbody>
</table>
<h4 id="语法格式与示例-3">语法格式与示例</h4>
<h5 id="count---计数函数">1. <code>COUNT()</code> - 计数函数</h5>
<p><strong>语法</strong>： <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="comment">-- 统计所有行数</span></span><br><span class="line"><span class="built_in">COUNT</span>(列名) <span class="comment">-- 统计指定列非NULL值行数</span></span><br><span class="line"><span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> 列名) <span class="comment">-- 统计指定列非NULL且不重复值行数</span></span><br></pre></td></tr></table></figure></p>
<p><strong>示例</strong>： <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 统计员工总数</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> 员工总数 <span class="keyword">FROM</span> employees;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 统计有邮箱的员工数量（忽略NULL值）</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(email) <span class="keyword">AS</span> 有邮箱员工数 <span class="keyword">FROM</span> employees;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 统计不同部门的数量</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> department) <span class="keyword">AS</span> 部门数量 <span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure></p>
<p><strong>注意</strong>： - <code>COUNT(*)</code>包含NULL值行，而<code>COUNT(列名)</code>忽略NULL值行 - <code>COUNT(DISTINCT)</code>同时去除NULL值和重复值</p>
<h5 id="sum---求和函数">2. <code>SUM()</code> - 求和函数</h5>
<p><strong>语法</strong>： <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">SUM</span>(数值列名)</span><br></pre></td></tr></table></figure></p>
<p><strong>示例</strong>： <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 计算所有员工薪资总和</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">SUM</span>(salary) <span class="keyword">AS</span> 薪资总和 <span class="keyword">FROM</span> employees;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 计算技术部门的薪资总和</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">SUM</span>(salary) <span class="keyword">AS</span> 技术部薪资总和 </span><br><span class="line"><span class="keyword">FROM</span> employees </span><br><span class="line"><span class="keyword">WHERE</span> department <span class="operator">=</span> <span class="string">&#x27;技术部&#x27;</span>;</span><br></pre></td></tr></table></figure></p>
<p><strong>注意</strong>： - <code>SUM()</code>函数只适用于数值类型的列 - 如果所有行都为NULL，结果将为NULL</p>
<h5 id="avg---平均值函数">3. <code>AVG()</code> - 平均值函数</h5>
<p><strong>语法</strong>： <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVG</span>(数值列名)</span><br></pre></td></tr></table></figure></p>
<p><strong>示例</strong>： <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 计算所有员工平均薪资</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">AVG</span>(salary) <span class="keyword">AS</span> 平均薪资 <span class="keyword">FROM</span> employees;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 计算销售部员工平均薪资（保留两位小数）</span></span><br><span class="line"><span class="keyword">SELECT</span> ROUND(<span class="built_in">AVG</span>(salary), <span class="number">2</span>) <span class="keyword">AS</span> 销售部平均薪资 </span><br><span class="line"><span class="keyword">FROM</span> employees </span><br><span class="line"><span class="keyword">WHERE</span> department <span class="operator">=</span> <span class="string">&#x27;销售部&#x27;</span>;</span><br></pre></td></tr></table></figure></p>
<p><strong>注意</strong>： - <code>AVG()</code>函数会自动忽略NULL值 - 可以与<code>ROUND()</code>函数结合使用以控制小数位数</p>
<h5 id="maxmin---最大最小值函数">4. <code>MAX()</code>/<code>MIN()</code> - 最大/最小值函数</h5>
<p><strong>语法</strong>： <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">MAX</span>(列名) <span class="comment">-- 返回最大值</span></span><br><span class="line"><span class="built_in">MIN</span>(列名) <span class="comment">-- 返回最小值</span></span><br></pre></td></tr></table></figure></p>
<p><strong>示例</strong>： <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 找出最高和最低薪资</span></span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">  <span class="built_in">MAX</span>(salary) <span class="keyword">AS</span> 最高薪资,</span><br><span class="line">  <span class="built_in">MIN</span>(salary) <span class="keyword">AS</span> 最低薪资</span><br><span class="line"><span class="keyword">FROM</span> employees;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 找出最早和最晚入职的员工</span></span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">  <span class="built_in">MAX</span>(hire_date) <span class="keyword">AS</span> 最晚入职日期,</span><br><span class="line">  <span class="built_in">MIN</span>(hire_date) <span class="keyword">AS</span> 最早入职日期</span><br><span class="line"><span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure></p>
<p><strong>注意</strong>： - <code>MAX()</code>/<code>MIN()</code>可以用于数值、日期、字符串等多种数据类型 - 对于字符串，按字典顺序比较</p>
<h5 id="group_concat---分组连接函数">5. <code>GROUP_CONCAT()</code> - 分组连接函数</h5>
<p><strong>语法</strong>： <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GROUP_CONCAT([<span class="keyword">DISTINCT</span>] 列名 [<span class="keyword">ORDER</span> <span class="keyword">BY</span> 排序字段] [SEPARATOR <span class="string">&#x27;分隔符&#x27;</span>])</span><br></pre></td></tr></table></figure></p>
<p><strong>示例</strong>： <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 按部门分组，列出每个部门的所有员工姓名</span></span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">  department <span class="keyword">AS</span> 部门,</span><br><span class="line">  GROUP_CONCAT(name) <span class="keyword">AS</span> 员工列表</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 按部门分组，列出每个部门不重复的职位（用分号分隔）</span></span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">  department <span class="keyword">AS</span> 部门,</span><br><span class="line">  GROUP_CONCAT(<span class="keyword">DISTINCT</span> position SEPARATOR <span class="string">&#x27;; &#x27;</span>) <span class="keyword">AS</span> 职位列表</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 按部门分组，列出每个部门的员工姓名（按薪资降序排列）</span></span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">  department <span class="keyword">AS</span> 部门,</span><br><span class="line">  GROUP_CONCAT(name <span class="keyword">ORDER</span> <span class="keyword">BY</span> salary <span class="keyword">DESC</span>) <span class="keyword">AS</span> 员工列表</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department;</span><br></pre></td></tr></table></figure></p>
<h4 id="聚集函数与where子句结合">聚集函数与WHERE子句结合</h4>
<p><strong>注意</strong>：聚集函数不能直接用在WHERE子句中，但可以用在HAVING子句中（与GROUP BY配合使用）或子查询中。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 错误示例（不能在WHERE中直接使用聚集函数）</span></span><br><span class="line"><span class="comment">-- SELECT * FROM employees WHERE COUNT(*) &gt; 10;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 正确示例1：使用HAVING过滤分组结果</span></span><br><span class="line"><span class="keyword">SELECT</span> department <span class="keyword">FROM</span> employees <span class="keyword">GROUP</span> <span class="keyword">BY</span> department <span class="keyword">HAVING</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="operator">&gt;</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 正确示例2：使用子查询</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> salary <span class="operator">&gt;</span> (<span class="keyword">SELECT</span> <span class="built_in">AVG</span>(salary) <span class="keyword">FROM</span> employees);</span><br></pre></td></tr></table></figure>
<h2 id="group-by-子句分组数据">GROUP BY 子句（分组数据）</h2>
<h3 id="基本用法按指定字段分组">基本用法（按指定字段分组）</h3>
<p>GROUP BY 子句用于将查询结果集按照一个或多个字段进行分组，然后对每个组应用聚集函数（如COUNT、SUM、AVG等）。分组操作可以帮助我们对数据进行分类汇总分析。</p>
<h4 id="语法格式-3">语法格式</h4>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段名<span class="number">1</span>, 字段名<span class="number">2</span>, 聚集函数(字段名)</span><br><span class="line"><span class="keyword">FROM</span> 表名</span><br><span class="line"><span class="keyword">WHERE</span> 条件</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> 分组字段<span class="number">1</span>, 分组字段<span class="number">2</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> 排序字段;</span><br></pre></td></tr></table></figure>
<h4 id="基本示例">基本示例</h4>
<p><strong>按单个字段分组</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 按部门分组统计员工数量</span></span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">  department <span class="keyword">AS</span> 部门,</span><br><span class="line">  <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> 员工数量</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department;</span><br></pre></td></tr></table></figure>
<p><strong>按多个字段分组</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 按部门和性别分组统计员工数量和平均薪资</span></span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">  department <span class="keyword">AS</span> 部门,</span><br><span class="line">  gender <span class="keyword">AS</span> 性别,</span><br><span class="line">  <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> 员工数量,</span><br><span class="line">  ROUND(<span class="built_in">AVG</span>(salary), <span class="number">2</span>) <span class="keyword">AS</span> 平均薪资</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department, gender</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> department, 平均薪资 <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure>
<h4 id="group-by-与聚集函数结合">GROUP BY 与聚集函数结合</h4>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 按部门分组统计员工数量、平均薪资、最高薪资、最低薪资</span></span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">  department <span class="keyword">AS</span> 部门,</span><br><span class="line">  <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> 员工数量,</span><br><span class="line">  ROUND(<span class="built_in">AVG</span>(salary), <span class="number">2</span>) <span class="keyword">AS</span> 平均薪资,</span><br><span class="line">  <span class="built_in">MAX</span>(salary) <span class="keyword">AS</span> 最高薪资,</span><br><span class="line">  <span class="built_in">MIN</span>(salary) <span class="keyword">AS</span> 最低薪资,</span><br><span class="line">  <span class="built_in">SUM</span>(salary) <span class="keyword">AS</span> 薪资总额</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> 员工数量 <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure>
<h4 id="使用注意事项">使用注意事项</h4>
<ol type="1">
<li><p><strong>非聚集字段必须出现在GROUP BY子句中</strong> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 错误示例：name字段没有出现在GROUP BY中</span></span><br><span class="line"><span class="keyword">SELECT</span> department, name, <span class="built_in">COUNT</span>(<span class="operator">*</span>) </span><br><span class="line"><span class="keyword">FROM</span> employees </span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 正确示例</span></span><br><span class="line"><span class="keyword">SELECT</span> department, <span class="built_in">COUNT</span>(<span class="operator">*</span>) </span><br><span class="line"><span class="keyword">FROM</span> employees </span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department;</span><br></pre></td></tr></table></figure></p></li>
<li><p><strong>NULL值处理</strong></p>
<ul>
<li>NULL值会被视为一组进行分组 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- NULL值分组示例：GROUP BY会将所有NULL值的行分为一组</span></span><br><span class="line"><span class="comment">-- 下面的查询会返回所有部门（包括NULL部门）及其员工数量</span></span><br><span class="line"><span class="keyword">SELECT</span> department, <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> 员工数量</span><br><span class="line"><span class="keyword">FROM</span> employees </span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department;</span><br><span class="line"><span class="comment">-- 结果中会有一行显示department为NULL，对应的COUNT为NULL部门的员工数量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 如果只想统计NULL部门的员工数量，可以使用WHERE条件</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> <span class="keyword">NULL</span>部门员工数量</span><br><span class="line"><span class="keyword">FROM</span> employees </span><br><span class="line"><span class="keyword">WHERE</span> department <span class="keyword">IS</span> <span class="keyword">NULL</span>;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p><strong>表达式分组</strong></p>
<ul>
<li>可以使用表达式作为分组依据 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 按年份分组统计订单数量</span></span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">  <span class="keyword">YEAR</span>(order_date) <span class="keyword">AS</span> 订单年份,</span><br><span class="line">  <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> 订单数量</span><br><span class="line"><span class="keyword">FROM</span> orders</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">YEAR</span>(order_date);</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p><strong>GROUP BY 与 ORDER BY 结合</strong></p>
<ul>
<li>通常在GROUP BY之后使用ORDER BY对分组结果进行排序 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">  department, <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> count</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> count <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ol>
<h3 id="筛选分组having子句与where的区别筛选分组结果-vs-筛选行">筛选分组：HAVING子句（与WHERE的区别：筛选分组结果 vs 筛选行）</h3>
<p>HAVING子句用于筛选分组后的结果集，类似于WHERE子句，但WHERE筛选的是行，而HAVING筛选的是分组。HAVING子句通常与GROUP BY一起使用。</p>
<h4 id="having-语法格式">HAVING 语法格式</h4>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段名<span class="number">1</span>, 聚集函数(字段名)</span><br><span class="line"><span class="keyword">FROM</span> 表名</span><br><span class="line"><span class="keyword">WHERE</span> 行条件</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> 分组字段</span><br><span class="line"><span class="keyword">HAVING</span> 分组条件</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> 排序字段;</span><br></pre></td></tr></table></figure>
<h4 id="having-与-where-的区别">HAVING 与 WHERE 的区别</h4>
<table>
<thead>
<tr class="header">
<th>特性</th>
<th>WHERE 子句</th>
<th>HAVING 子句</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>作用对象</td>
<td>筛选行数据</td>
<td>筛选分组结果</td>
</tr>
<tr class="even">
<td>使用位置</td>
<td>GROUP BY 之前</td>
<td>GROUP BY 之后</td>
</tr>
<tr class="odd">
<td>能否使用聚集函数</td>
<td>不能</td>
<td>可以</td>
</tr>
<tr class="even">
<td>执行顺序</td>
<td>先执行，再分组</td>
<td>先分组，再执行</td>
</tr>
</tbody>
</table>
<h4 id="having-基本示例">HAVING 基本示例</h4>
<p><strong>筛选员工数量大于10的部门</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查找员工数量超过10人的部门</span></span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">  department <span class="keyword">AS</span> 部门,</span><br><span class="line">  <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> 员工数量</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="operator">&gt;</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<p><strong>筛选平均薪资大于8000的部门</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查找平均薪资超过8000的部门</span></span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">  department <span class="keyword">AS</span> 部门,</span><br><span class="line">  ROUND(<span class="built_in">AVG</span>(salary), <span class="number">2</span>) <span class="keyword">AS</span> 平均薪资</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">AVG</span>(salary) <span class="operator">&gt;</span> <span class="number">8000</span>;</span><br></pre></td></tr></table></figure>
<h4 id="where-与-having-结合使用">WHERE 与 HAVING 结合使用</h4>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 筛选2023年入职且员工数量超过5人的部门</span></span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">  department <span class="keyword">AS</span> 部门,</span><br><span class="line">  <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> 员工数量</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">YEAR</span>(hire_date) <span class="operator">=</span> <span class="number">2023</span>  <span class="comment">-- 先筛选行</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="operator">&gt;</span> <span class="number">5</span>;  <span class="comment">-- 再筛选分组</span></span><br></pre></td></tr></table></figure>
<h4 id="having-使用注意事项">HAVING 使用注意事项</h4>
<ol type="1">
<li><strong>性能考虑</strong>
<ul>
<li>对于行级筛选，优先使用WHERE子句以减少分组前的数据量</li>
<li>避免在HAVING中使用非分组字段的条件</li>
</ul></li>
<li><strong>聚集函数的使用</strong>
<ul>
<li>HAVING子句中可以使用聚集函数 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查找总销售额超过10000的产品类别</span></span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">  category <span class="keyword">AS</span> 产品类别,</span><br><span class="line">  <span class="built_in">SUM</span>(sales_amount) <span class="keyword">AS</span> 总销售额</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> category</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">SUM</span>(sales_amount) <span class="operator">&gt;</span> <span class="number">10000</span>;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><strong>复杂条件组合</strong>
<ul>
<li>可以在HAVING中使用AND、OR等逻辑运算符组合多个条件 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查找员工数量在5到20之间且平均薪资超过6000的部门</span></span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">  department,</span><br><span class="line">  <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> 员工数量,</span><br><span class="line">  ROUND(<span class="built_in">AVG</span>(salary), <span class="number">2</span>) <span class="keyword">AS</span> 平均薪资</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">BETWEEN</span> <span class="number">5</span> <span class="keyword">AND</span> <span class="number">20</span></span><br><span class="line"><span class="keyword">AND</span> <span class="built_in">AVG</span>(salary) <span class="operator">&gt;</span> <span class="number">6000</span>;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><strong>与ORDER BY结合</strong></li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查找销售额最高的前3个产品类别</span></span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">  category <span class="keyword">AS</span> 产品类别,</span><br><span class="line">  <span class="built_in">SUM</span>(sales_amount) <span class="keyword">AS</span> 总销售额</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> category</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">SUM</span>(sales_amount) <span class="operator">&gt;</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> 总销售额 <span class="keyword">DESC</span></span><br><span class="line">LIMIT <span class="number">3</span>;</span><br></pre></td></tr></table></figure>
<h2 id="子查询">子查询</h2>
<p>子查询（Subquery）是指嵌套在其他SQL语句中的SELECT语句，也称为内部查询或嵌套查询。子查询通常用于过滤数据、比较值或创建派生表，是SQL中强大而灵活的特性。</p>
<h4 id="子查询的分类">子查询的分类</h4>
<table>
<thead>
<tr class="header">
<th>分类方式</th>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>按返回结果行数</strong></td>
<td>单行子查询</td>
<td>返回单行单列结果</td>
</tr>
<tr class="even">
<td></td>
<td>多行子查询</td>
<td>返回多行结果</td>
</tr>
<tr class="odd">
<td><strong>按使用位置</strong></td>
<td>WHERE子句中的子查询</td>
<td>用于过滤数据</td>
</tr>
<tr class="even">
<td></td>
<td>FROM子句中的子查询</td>
<td>作为派生表使用</td>
</tr>
<tr class="odd">
<td></td>
<td>SELECT子句中的子查询</td>
<td>作为列值返回</td>
</tr>
<tr class="even">
<td></td>
<td>HAVING子句中的子查询</td>
<td>用于筛选分组</td>
</tr>
</tbody>
</table>
<h3 id="where中的子查询单行子查询多行子查询in">WHERE中的子查询（单行子查询/多行子查询<code>IN</code>）</h3>
<p>WHERE子句中的子查询用于过滤主查询的结果集，根据子查询返回的值来确定主查询中哪些行应该被包含。</p>
<h4 id="单行子查询">单行子查询</h4>
<p>单行子查询返回单个值（单行单列），通常与比较运算符（=, &gt;, &lt;, &gt;=, &lt;=, !=）一起使用。</p>
<p><strong>语法格式</strong>： <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段名</span><br><span class="line"><span class="keyword">FROM</span> 表名</span><br><span class="line"><span class="keyword">WHERE</span> 字段名 比较运算符 (<span class="keyword">SELECT</span> 字段名 <span class="keyword">FROM</span> 表名 <span class="keyword">WHERE</span> 条件);</span><br></pre></td></tr></table></figure></p>
<p><strong>示例1：查找薪资高于平均薪资的员工</strong> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查找薪资高于公司平均薪资的员工信息</span></span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">  employee_id <span class="keyword">AS</span> 员工ID,</span><br><span class="line">  name <span class="keyword">AS</span> 姓名,</span><br><span class="line">  department <span class="keyword">AS</span> 部门,</span><br><span class="line">  salary <span class="keyword">AS</span> 薪资</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> salary <span class="operator">&gt;</span> (<span class="keyword">SELECT</span> <span class="built_in">AVG</span>(salary) <span class="keyword">FROM</span> employees);</span><br></pre></td></tr></table></figure></p>
<p><strong>示例2：查找与特定员工同部门的其他员工</strong> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查找与张三同部门的其他员工</span></span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">  employee_id <span class="keyword">AS</span> 员工ID,</span><br><span class="line">  name <span class="keyword">AS</span> 姓名,</span><br><span class="line">  department <span class="keyword">AS</span> 部门</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> department <span class="operator">=</span> (<span class="keyword">SELECT</span> department <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;张三&#x27;</span>)</span><br><span class="line"><span class="keyword">AND</span> name <span class="operator">!=</span> <span class="string">&#x27;张三&#x27;</span>;</span><br></pre></td></tr></table></figure></p>
<h4 id="多行子查询">多行子查询</h4>
<p>多行子查询返回多行结果，通常与IN、ALL、ANY、EXISTS等操作符一起使用。</p>
<p><strong>语法格式</strong>： <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段名</span><br><span class="line"><span class="keyword">FROM</span> 表名</span><br><span class="line"><span class="keyword">WHERE</span> 字段名 <span class="keyword">IN</span> (<span class="keyword">SELECT</span> 字段名 <span class="keyword">FROM</span> 表名 <span class="keyword">WHERE</span> 条件);</span><br></pre></td></tr></table></figure></p>
<p><strong>示例1：使用IN操作符</strong> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查找销售部门和市场部门的所有员工</span></span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">  employee_id <span class="keyword">AS</span> 员工ID,</span><br><span class="line">  name <span class="keyword">AS</span> 姓名,</span><br><span class="line">  department <span class="keyword">AS</span> 部门</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> department <span class="keyword">IN</span> (</span><br><span class="line">  <span class="keyword">SELECT</span> department_name </span><br><span class="line">  <span class="keyword">FROM</span> departments </span><br><span class="line">  <span class="keyword">WHERE</span> department_name <span class="keyword">IN</span> (<span class="string">&#x27;销售部&#x27;</span>, <span class="string">&#x27;市场部&#x27;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<p><strong>示例2：使用ALL操作符</strong> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查找薪资高于所有实习生的正式员工</span></span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">  employee_id <span class="keyword">AS</span> 员工ID,</span><br><span class="line">  name <span class="keyword">AS</span> 姓名,</span><br><span class="line">  salary <span class="keyword">AS</span> 薪资</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> position <span class="operator">=</span> <span class="string">&#x27;正式员工&#x27;</span></span><br><span class="line"><span class="keyword">AND</span> salary <span class="operator">&gt;</span> <span class="keyword">ALL</span> (</span><br><span class="line">  <span class="keyword">SELECT</span> salary </span><br><span class="line">  <span class="keyword">FROM</span> employees </span><br><span class="line">  <span class="keyword">WHERE</span> position <span class="operator">=</span> <span class="string">&#x27;实习生&#x27;</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<p><strong>示例3：使用ANY操作符</strong> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查找薪资高于任一实习生的正式员工</span></span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">  employee_id <span class="keyword">AS</span> 员工ID,</span><br><span class="line">  name <span class="keyword">AS</span> 姓名,</span><br><span class="line">  salary <span class="keyword">AS</span> 薪资</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> position <span class="operator">=</span> <span class="string">&#x27;正式员工&#x27;</span></span><br><span class="line"><span class="keyword">AND</span> salary <span class="operator">&gt;</span> <span class="keyword">ANY</span> (</span><br><span class="line">  <span class="keyword">SELECT</span> salary </span><br><span class="line">  <span class="keyword">FROM</span> employees </span><br><span class="line">  <span class="keyword">WHERE</span> position <span class="operator">=</span> <span class="string">&#x27;实习生&#x27;</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<p><strong>示例4：使用EXISTS操作符</strong> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查找至少有一个下属的管理者</span></span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">  employee_id <span class="keyword">AS</span> 管理者ID,</span><br><span class="line">  name <span class="keyword">AS</span> 管理者姓名</span><br><span class="line"><span class="keyword">FROM</span> employees e1</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">EXISTS</span> (</span><br><span class="line">  <span class="keyword">SELECT</span> <span class="number">1</span> </span><br><span class="line">  <span class="keyword">FROM</span> employees e2 </span><br><span class="line">  <span class="keyword">WHERE</span> e2.manager_id <span class="operator">=</span> e1.employee_id</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<h4 id="where子查询使用注意事项">WHERE子查询使用注意事项</h4>
<ol type="1">
<li><strong>子查询必须用括号括起来</strong></li>
<li><strong>单行子查询只能返回一个值</strong>，与单行比较运算符配合使用</li>
<li><strong>多行子查询需要使用多行操作符</strong>（IN、ALL、ANY、EXISTS）</li>
<li><strong>性能考虑</strong>：子查询可能会影响性能，特别是在大型表上，考虑使用JOIN替代某些子查询</li>
<li><strong>NULL值处理</strong>：当子查询可能返回NULL值时，注意使用正确的操作符</li>
</ol>
<h3 id="from中的子查询派生表需指定别名">FROM中的子查询（派生表，需指定别名）</h3>
<p>FROM子句中的子查询作为一个临时表（称为派生表或内联视图），在主查询中被使用。派生表必须指定别名。</p>
<h4 id="基本语法">基本语法</h4>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段名</span><br><span class="line"><span class="keyword">FROM</span> (<span class="keyword">SELECT</span> 字段名 <span class="keyword">FROM</span> 表名 <span class="keyword">WHERE</span> 条件) <span class="keyword">AS</span> 派生表别名</span><br><span class="line"><span class="keyword">WHERE</span> 条件;</span><br></pre></td></tr></table></figure>
<h4 id="示例1使用派生表统计部门平均薪资">示例1：使用派生表统计部门平均薪资</h4>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 使用派生表查找平均薪资高于公司总平均薪资的部门</span></span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">  dept_stats.department <span class="keyword">AS</span> 部门,</span><br><span class="line">  dept_stats.avg_salary <span class="keyword">AS</span> 部门平均薪资</span><br><span class="line"><span class="keyword">FROM</span> (</span><br><span class="line">  <span class="keyword">SELECT</span> </span><br><span class="line">    department,</span><br><span class="line">    <span class="built_in">AVG</span>(salary) <span class="keyword">AS</span> avg_salary</span><br><span class="line">  <span class="keyword">FROM</span> employees</span><br><span class="line">  <span class="keyword">GROUP</span> <span class="keyword">BY</span> department</span><br><span class="line">) <span class="keyword">AS</span> dept_stats</span><br><span class="line"><span class="keyword">WHERE</span> dept_stats.avg_salary <span class="operator">&gt;</span> (</span><br><span class="line">  <span class="keyword">SELECT</span> <span class="built_in">AVG</span>(salary) </span><br><span class="line">  <span class="keyword">FROM</span> employees</span><br><span class="line">)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> dept_stats.avg_salary <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure>
<h4 id="示例2复杂派生表与联结">示例2：复杂派生表与联结</h4>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 使用派生表统计每个员工的订单数量和总销售额</span></span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">  e.employee_id <span class="keyword">AS</span> 员工ID,</span><br><span class="line">  e.name <span class="keyword">AS</span> 员工姓名,</span><br><span class="line">  e.department <span class="keyword">AS</span> 部门,</span><br><span class="line">  o.order_count <span class="keyword">AS</span> 订单数量,</span><br><span class="line">  o.total_amount <span class="keyword">AS</span> 总销售额</span><br><span class="line"><span class="keyword">FROM</span> employees e</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> (</span><br><span class="line">  <span class="keyword">SELECT</span> </span><br><span class="line">    salesperson_id,</span><br><span class="line">    <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> order_count,</span><br><span class="line">    <span class="built_in">SUM</span>(order_amount) <span class="keyword">AS</span> total_amount</span><br><span class="line">  <span class="keyword">FROM</span> orders</span><br><span class="line">  <span class="keyword">GROUP</span> <span class="keyword">BY</span> salesperson_id</span><br><span class="line">) <span class="keyword">AS</span> o <span class="keyword">ON</span> e.employee_id <span class="operator">=</span> o.salesperson_id</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> o.total_amount <span class="keyword">DESC</span> <span class="keyword">NULLS LAST</span>;</span><br></pre></td></tr></table></figure>
<h4 id="示例3嵌套派生表">示例3：嵌套派生表</h4>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 使用嵌套派生表进行多层统计分析</span></span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">  yearly_stats.year <span class="keyword">AS</span> 年份,</span><br><span class="line">  yearly_stats.avg_department_salary <span class="keyword">AS</span> 部门平均薪资</span><br><span class="line"><span class="keyword">FROM</span> (</span><br><span class="line">  <span class="keyword">SELECT</span> </span><br><span class="line">    <span class="keyword">YEAR</span>(hire_date) <span class="keyword">AS</span> <span class="keyword">year</span>,</span><br><span class="line">    <span class="built_in">AVG</span>(dept_avg.salary_avg) <span class="keyword">AS</span> avg_department_salary</span><br><span class="line">  <span class="keyword">FROM</span> employees</span><br><span class="line">  <span class="keyword">JOIN</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> </span><br><span class="line">      department,</span><br><span class="line">      <span class="built_in">AVG</span>(salary) <span class="keyword">AS</span> salary_avg</span><br><span class="line">    <span class="keyword">FROM</span> employees</span><br><span class="line">    <span class="keyword">GROUP</span> <span class="keyword">BY</span> department</span><br><span class="line">  ) <span class="keyword">AS</span> dept_avg <span class="keyword">ON</span> employees.department <span class="operator">=</span> dept_avg.department</span><br><span class="line">  <span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">YEAR</span>(hire_date)</span><br><span class="line">) <span class="keyword">AS</span> yearly_stats</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> yearly_stats.year;</span><br></pre></td></tr></table></figure>
<h4 id="from子查询使用注意事项">FROM子查询使用注意事项</h4>
<ol type="1">
<li><strong>必须指定别名</strong>：派生表必须有别名，否则SQL语句会出错</li>
<li><strong>作用域限制</strong>：派生表只在当前查询中可见，不能在其他查询或子查询中引用</li>
<li><strong>性能考虑</strong>：复杂的派生表可能会影响查询性能，特别是嵌套派生表</li>
<li><strong>列名处理</strong>：派生表中的列必须有唯一的名称，可使用AS关键字指定别名</li>
<li><strong>ORDER BY限制</strong>：在派生表中使用ORDER BY通常需要配合LIMIT，否则可能被优化器忽略</li>
</ol>
<h3 id="其他类型的子查询">其他类型的子查询</h3>
<h4 id="select子句中的子查询">SELECT子句中的子查询</h4>
<p>子查询可以出现在SELECT子句中，作为表达式返回单个值。</p>
<p><strong>示例</strong>： <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询每个员工的薪资与部门平均薪资的差额</span></span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">  employee_id <span class="keyword">AS</span> 员工ID,</span><br><span class="line">  name <span class="keyword">AS</span> 姓名,</span><br><span class="line">  department <span class="keyword">AS</span> 部门,</span><br><span class="line">  salary <span class="keyword">AS</span> 当前薪资,</span><br><span class="line">  (<span class="keyword">SELECT</span> <span class="built_in">AVG</span>(salary) <span class="keyword">FROM</span> employees e2 <span class="keyword">WHERE</span> e2.department <span class="operator">=</span> e1.department) <span class="keyword">AS</span> 部门平均薪资,</span><br><span class="line">  salary <span class="operator">-</span> (<span class="keyword">SELECT</span> <span class="built_in">AVG</span>(salary) <span class="keyword">FROM</span> employees e2 <span class="keyword">WHERE</span> e2.department <span class="operator">=</span> e1.department) <span class="keyword">AS</span> 薪资差额</span><br><span class="line"><span class="keyword">FROM</span> employees e1</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> 薪资差额 <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure></p>
<h4 id="having子句中的子查询">HAVING子句中的子查询</h4>
<p>子查询可以在HAVING子句中使用，用于筛选分组结果。</p>
<p><strong>示例</strong>： <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查找平均薪资高于公司总平均薪资的部门</span></span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">  department <span class="keyword">AS</span> 部门,</span><br><span class="line">  <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> 员工数量,</span><br><span class="line">  <span class="built_in">AVG</span>(salary) <span class="keyword">AS</span> 平均薪资</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">AVG</span>(salary) <span class="operator">&gt;</span> (<span class="keyword">SELECT</span> <span class="built_in">AVG</span>(salary) <span class="keyword">FROM</span> employees)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> 平均薪资 <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure></p>
<h4 id="相关子查询correlated-subquery">相关子查询（Correlated Subquery）</h4>
<p>相关子查询是引用外部查询中表的子查询，它为外部查询的每一行执行一次。</p>
<p><strong>示例</strong>： <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查找每个部门薪资最高的员工</span></span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">  e1.employee_id <span class="keyword">AS</span> 员工ID,</span><br><span class="line">  e1.name <span class="keyword">AS</span> 姓名,</span><br><span class="line">  e1.department <span class="keyword">AS</span> 部门,</span><br><span class="line">  e1.salary <span class="keyword">AS</span> 薪资</span><br><span class="line"><span class="keyword">FROM</span> employees e1</span><br><span class="line"><span class="keyword">WHERE</span> e1.salary <span class="operator">=</span> (<span class="keyword">SELECT</span> <span class="built_in">MAX</span>(salary) <span class="keyword">FROM</span> employees e2 <span class="keyword">WHERE</span> e2.department <span class="operator">=</span> e1.department)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> e1.department;</span><br></pre></td></tr></table></figure></p>
<h3 id="子查询的性能优化">子查询的性能优化</h3>
<ol type="1">
<li><strong>使用EXISTS替代IN</strong>：当子查询结果集较大时，EXISTS通常比IN更高效</li>
<li><strong>考虑使用JOIN</strong>：某些子查询可以转换为JOIN操作，提高性能</li>
<li><strong>限制子查询结果集</strong>：使用LIMIT或适当的WHERE条件减少子查询返回的数据量</li>
<li><strong>避免SELECT * </strong>：在子查询中只选择必要的列</li>
<li><strong>使用索引</strong>：确保子查询中使用的列上有适当的索引</li>
<li><strong>避免过于复杂的嵌套</strong>：过度嵌套的子查询可能导致性能问题</li>
</ol>
<p><strong>优化示例</strong>： <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 优化前：使用IN子查询</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> department_id <span class="keyword">IN</span> (<span class="keyword">SELECT</span> department_id <span class="keyword">FROM</span> departments <span class="keyword">WHERE</span> location <span class="operator">=</span> <span class="string">&#x27;北京&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 优化后：使用JOIN</span></span><br><span class="line"><span class="keyword">SELECT</span> e.<span class="operator">*</span> <span class="keyword">FROM</span> employees e <span class="keyword">JOIN</span> departments d <span class="keyword">ON</span> e.department_id <span class="operator">=</span> d.department_id <span class="keyword">WHERE</span> d.location <span class="operator">=</span> <span class="string">&#x27;北京&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 优化前：使用IN和子查询</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> orders <span class="keyword">WHERE</span> customer_id <span class="keyword">IN</span> (<span class="keyword">SELECT</span> customer_id <span class="keyword">FROM</span> customers <span class="keyword">WHERE</span> last_purchase_date <span class="operator">&gt;</span> <span class="string">&#x27;2023-01-01&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 优化后：使用EXISTS</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> orders o <span class="keyword">WHERE</span> <span class="keyword">EXISTS</span> (<span class="keyword">SELECT</span> <span class="number">1</span> <span class="keyword">FROM</span> customers c <span class="keyword">WHERE</span> c.customer_id <span class="operator">=</span> o.customer_id <span class="keyword">AND</span> c.last_purchase_date <span class="operator">&gt;</span> <span class="string">&#x27;2023-01-01&#x27;</span>);</span><br></pre></td></tr></table></figure></p>
<h2 id="联结表多表查询">联结表（多表查询）</h2>
<p>在实际数据库应用中，数据通常分布在多个相关联的表中。联结表（Join）是SQL中用于从多个表中检索数据的强大机制，它通过表之间的关联条件将数据组合在一起。</p>
<h3 id="笛卡尔积无关联条件的联结需避免">笛卡尔积（无关联条件的联结，需避免）</h3>
<p>笛卡尔积（Cartesian Product）是当联结表时不指定关联条件时产生的结果，它会将第一个表的每一行与第二个表的每一行组合，生成所有可能的行组合。</p>
<p><strong>语法</strong>： <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> 表<span class="number">1</span>, 表<span class="number">2</span>;</span><br></pre></td></tr></table></figure></p>
<p><strong>示例</strong>： 假设有employees表（3行）和departments表（2行），不使用WHERE条件的查询将返回3×2=6行数据：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 笛卡尔积查询示例（通常应避免）</span></span><br><span class="line"><span class="keyword">SELECT</span> e.employee_id, e.name, d.department_id, d.department_name</span><br><span class="line"><span class="keyword">FROM</span> employees e, departments d;</span><br></pre></td></tr></table></figure>
<p><strong>注意事项</strong>： 1. 笛卡尔积通常会产生大量不必要的数据行，消耗系统资源 2. 在实际开发中，应始终为联结操作指定适当的关联条件 3. 笛卡尔积有时用于特定的数据生成场景，但一般查询中应避免使用</p>
<h3 id="内部联结inner-join匹配两表关联数据">内部联结（INNER JOIN，匹配两表关联数据）</h3>
<p>内部联结是最常用的联结类型，它只返回满足关联条件的行。</p>
<p><strong>语法</strong>： <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 标准ANSI JOIN语法（推荐）</span></span><br><span class="line"><span class="keyword">SELECT</span> 列名</span><br><span class="line"><span class="keyword">FROM</span> 表<span class="number">1</span></span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> 表<span class="number">2</span> <span class="keyword">ON</span> 表<span class="number">1.</span>列 <span class="operator">=</span> 表<span class="number">2.</span>列;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 传统JOIN语法（WHERE子句指定关联条件）</span></span><br><span class="line"><span class="keyword">SELECT</span> 列名</span><br><span class="line"><span class="keyword">FROM</span> 表<span class="number">1</span>, 表<span class="number">2</span></span><br><span class="line"><span class="keyword">WHERE</span> 表<span class="number">1.</span>列 <span class="operator">=</span> 表<span class="number">2.</span>列;</span><br></pre></td></tr></table></figure></p>
<p><strong>示例</strong>： <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 使用INNER JOIN查询员工及其部门信息</span></span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">  e.employee_id <span class="keyword">AS</span> 员工ID,</span><br><span class="line">  e.name <span class="keyword">AS</span> 员工姓名,</span><br><span class="line">  e.position <span class="keyword">AS</span> 职位,</span><br><span class="line">  d.department_id <span class="keyword">AS</span> 部门ID,</span><br><span class="line">  d.department_name <span class="keyword">AS</span> 部门名称</span><br><span class="line"><span class="keyword">FROM</span> employees e</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> departments d <span class="keyword">ON</span> e.department_id <span class="operator">=</span> d.department_id;</span><br></pre></td></tr></table></figure></p>
<p><strong>注意事项</strong>： 1. 内部联结只返回两表中匹配的数据，不匹配的行不会出现在结果集中 2. 推荐使用ANSI JOIN语法（INNER JOIN…ON），可读性更好 3. 确保在ON子句中指定正确的关联字段，通常是主键和外键的关系</p>
<h3 id="表字段别名简化多表查询语法">表/字段别名（简化多表查询语法）</h3>
<p>当进行多表查询时，使用别名可以简化SQL语句并避免列名冲突。</p>
<p><strong>语法</strong>： <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">  表<span class="number">1</span>别名.列名<span class="number">1</span> <span class="keyword">AS</span> 别名<span class="number">1</span>,</span><br><span class="line">  表<span class="number">2</span>别名.列名<span class="number">2</span> <span class="keyword">AS</span> 别名<span class="number">2</span></span><br><span class="line"><span class="keyword">FROM</span> 表<span class="number">1</span> 表<span class="number">1</span>别名</span><br><span class="line"><span class="keyword">JOIN</span> 表<span class="number">2</span> 表<span class="number">2</span>别名 <span class="keyword">ON</span> 表<span class="number">1</span>别名.关联列 <span class="operator">=</span> 表<span class="number">2</span>别名.关联列;</span><br></pre></td></tr></table></figure></p>
<p><strong>示例</strong>： <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 使用表别名和列别名简化多表查询</span></span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">  e.employee_id <span class="keyword">AS</span> 员工ID,</span><br><span class="line">  e.name <span class="keyword">AS</span> 员工姓名,</span><br><span class="line">  d.department_name <span class="keyword">AS</span> 部门名称,</span><br><span class="line">  p.project_name <span class="keyword">AS</span> 项目名称</span><br><span class="line"><span class="keyword">FROM</span> employees e</span><br><span class="line"><span class="keyword">JOIN</span> departments d <span class="keyword">ON</span> e.department_id <span class="operator">=</span> d.department_id</span><br><span class="line"><span class="keyword">JOIN</span> employee_projects ep <span class="keyword">ON</span> e.employee_id <span class="operator">=</span> ep.employee_id</span><br><span class="line"><span class="keyword">JOIN</span> projects p <span class="keyword">ON</span> ep.project_id <span class="operator">=</span> p.project_id;</span><br></pre></td></tr></table></figure></p>
<p><strong>注意事项</strong>： 1. 表别名通常使用简短的字母或单词（如e表示employees） 2. 别名可以使用AS关键字指定，也可以直接在表名后空格跟别名 3. 一旦定义了表别名，在查询中必须使用别名引用该表的列 4. 当不同表中有相同名称的列时，必须使用表名或表别名限定列名</p>
<h3 id="自然联结natural-join自动匹配同名同类型字段">自然联结（NATURAL JOIN，自动匹配同名同类型字段）</h3>
<p>自然联结会自动基于两个表中名称相同且数据类型兼容的列创建关联条件。</p>
<p><strong>语法</strong>： <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 列名</span><br><span class="line"><span class="keyword">FROM</span> 表<span class="number">1</span></span><br><span class="line"><span class="keyword">NATURAL</span> <span class="keyword">JOIN</span> 表<span class="number">2</span>;</span><br></pre></td></tr></table></figure></p>
<p><strong>示例</strong>： 如果employees表和departments表都有一个名为department_id的列，自然联结会自动基于这个列进行关联：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 自然联结示例</span></span><br><span class="line"><span class="keyword">SELECT</span> employee_id, name, department_name</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">NATURAL</span> <span class="keyword">JOIN</span> departments;</span><br></pre></td></tr></table></figure>
<p><strong>注意事项</strong>： 1. 自然联结依赖于列名的匹配，可能导致意外的结果 2. 不推荐在生产环境中使用自然联结，因为它隐藏了具体的关联条件 3. 如果表结构发生变化（如添加新的同名列），可能会破坏现有查询 4. 使用显式的INNER JOIN和ON子句可以提供更好的可读性和控制</p>
<h3 id="外部联结leftrightfull-join保留左右全表数据">外部联结（LEFT/RIGHT/FULL JOIN，保留左/右/全表数据）</h3>
<p>外部联结不仅返回满足关联条件的行，还会保留一个表或两个表中不匹配的行。</p>
<p><strong>类型与语法</strong>：</p>
<table style="width:100%;">
<colgroup>
<col style="width: 42%" />
<col style="width: 28%" />
<col style="width: 28%" />
</colgroup>
<thead>
<tr class="header">
<th>联结类型</th>
<th>语法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>LEFT JOIN<br>（左联结）</td>
<td>SELECT * FROM 左表 LEFT JOIN 右表 ON 条件</td>
<td>返回左表所有行，右表匹配行，不匹配部分为NULL</td>
</tr>
<tr class="even">
<td>RIGHT JOIN<br>（右联结）</td>
<td>SELECT * FROM 左表 RIGHT JOIN 右表 ON 条件</td>
<td>返回右表所有行，左表匹配行，不匹配部分为NULL</td>
</tr>
<tr class="odd">
<td>FULL JOIN<br>（全联结）</td>
<td>SELECT * FROM 左表 FULL JOIN 右表 ON 条件</td>
<td>返回两表所有行，不匹配部分为NULL（MySQL不直接支持）</td>
</tr>
</tbody>
</table>
<p><strong>示例1：左联结（LEFT JOIN）</strong> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询所有员工及其所属部门，包括未分配部门的员工</span></span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">  e.employee_id <span class="keyword">AS</span> 员工ID,</span><br><span class="line">  e.name <span class="keyword">AS</span> 员工姓名,</span><br><span class="line">  d.department_name <span class="keyword">AS</span> 部门名称</span><br><span class="line"><span class="keyword">FROM</span> employees e</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> departments d <span class="keyword">ON</span> e.department_id <span class="operator">=</span> d.department_id;</span><br></pre></td></tr></table></figure></p>
<p><strong>示例2：右联结（RIGHT JOIN）</strong> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询所有部门及其员工，包括没有员工的部门</span></span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">  d.department_id <span class="keyword">AS</span> 部门ID,</span><br><span class="line">  d.department_name <span class="keyword">AS</span> 部门名称,</span><br><span class="line">  e.employee_id <span class="keyword">AS</span> 员工ID,</span><br><span class="line">  e.name <span class="keyword">AS</span> 员工姓名</span><br><span class="line"><span class="keyword">FROM</span> employees e</span><br><span class="line"><span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> departments d <span class="keyword">ON</span> e.department_id <span class="operator">=</span> d.department_id;</span><br></pre></td></tr></table></figure></p>
<p><strong>示例3：模拟全联结（MySQL不直接支持FULL JOIN）</strong> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 使用UNION模拟全联结</span></span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">  d.department_id <span class="keyword">AS</span> 部门ID,</span><br><span class="line">  d.department_name <span class="keyword">AS</span> 部门名称,</span><br><span class="line">  e.employee_id <span class="keyword">AS</span> 员工ID,</span><br><span class="line">  e.name <span class="keyword">AS</span> 员工姓名</span><br><span class="line"><span class="keyword">FROM</span> employees e</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> departments d <span class="keyword">ON</span> e.department_id <span class="operator">=</span> d.department_id</span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">  d.department_id <span class="keyword">AS</span> 部门ID,</span><br><span class="line">  d.department_name <span class="keyword">AS</span> 部门名称,</span><br><span class="line">  e.employee_id <span class="keyword">AS</span> 员工ID,</span><br><span class="line">  e.name <span class="keyword">AS</span> 员工姓名</span><br><span class="line"><span class="keyword">FROM</span> employees e</span><br><span class="line"><span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> departments d <span class="keyword">ON</span> e.department_id <span class="operator">=</span> d.department_id</span><br><span class="line"><span class="keyword">WHERE</span> e.employee_id <span class="keyword">IS</span> <span class="keyword">NULL</span>;</span><br></pre></td></tr></table></figure></p>
<p><strong>注意事项</strong>： 1. LEFT JOIN和RIGHT JOIN是互补的，可以根据需要选择合适的主表 2. MySQL不直接支持FULL JOIN，需要使用UNION和LEFT/RIGHT JOIN组合实现 3. 外部联结常用于查找“缺失”数据，如未分配任务的员工、没有员工的部门等 4. 在WHERE子句中过滤外部联结的结果时要特别小心，避免意外将外部联结转换为内部联结</p>
<h3 id="高级联结多表联结自联结">高级联结（多表联结、自联结）</h3>
<h4 id="多表联结">多表联结</h4>
<p>在一个查询中可以联结三个或更多的表，按照业务需求组合多个数据源。</p>
<p><strong>示例</strong>： <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 三表联结查询：员工、部门和项目信息</span></span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">  e.employee_id <span class="keyword">AS</span> 员工ID,</span><br><span class="line">  e.name <span class="keyword">AS</span> 员工姓名,</span><br><span class="line">  d.department_name <span class="keyword">AS</span> 部门名称,</span><br><span class="line">  p.project_name <span class="keyword">AS</span> 项目名称,</span><br><span class="line">  ep.role <span class="keyword">AS</span> 在项目中的角色</span><br><span class="line"><span class="keyword">FROM</span> employees e</span><br><span class="line"><span class="keyword">JOIN</span> departments d <span class="keyword">ON</span> e.department_id <span class="operator">=</span> d.department_id</span><br><span class="line"><span class="keyword">JOIN</span> employee_projects ep <span class="keyword">ON</span> e.employee_id <span class="operator">=</span> ep.employee_id</span><br><span class="line"><span class="keyword">JOIN</span> projects p <span class="keyword">ON</span> ep.project_id <span class="operator">=</span> p.project_id</span><br><span class="line"><span class="keyword">WHERE</span> p.start_date <span class="operator">&gt;</span> <span class="string">&#x27;2023-01-01&#x27;</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> e.department_id, e.employee_id;</span><br></pre></td></tr></table></figure></p>
<h4 id="自联结self-join">自联结（Self-Join）</h4>
<p>自联结是将一个表与自身联结，通常用于处理表中的层级关系或比较表中的行。</p>
<p><strong>示例1：查询员工及其经理信息</strong> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 自联结查询：找出每个员工及其经理</span></span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">  e.employee_id <span class="keyword">AS</span> 员工ID,</span><br><span class="line">  e.name <span class="keyword">AS</span> 员工姓名,</span><br><span class="line">  m.employee_id <span class="keyword">AS</span> 经理ID,</span><br><span class="line">  m.name <span class="keyword">AS</span> 经理姓名</span><br><span class="line"><span class="keyword">FROM</span> employees e</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> employees m <span class="keyword">ON</span> e.manager_id <span class="operator">=</span> m.employee_id;</span><br></pre></td></tr></table></figure></p>
<p><strong>示例2：查找薪资高于同部门平均水平的员工</strong> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 自联结结合子查询：找出薪资高于部门平均的员工</span></span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">  e.employee_id <span class="keyword">AS</span> 员工ID,</span><br><span class="line">  e.name <span class="keyword">AS</span> 员工姓名,</span><br><span class="line">  e.department_id <span class="keyword">AS</span> 部门ID,</span><br><span class="line">  e.salary <span class="keyword">AS</span> 员工薪资,</span><br><span class="line">  d.avg_salary <span class="keyword">AS</span> 部门平均薪资</span><br><span class="line"><span class="keyword">FROM</span> employees e</span><br><span class="line"><span class="keyword">JOIN</span> (</span><br><span class="line">  <span class="keyword">SELECT</span> department_id, <span class="built_in">AVG</span>(salary) <span class="keyword">AS</span> avg_salary</span><br><span class="line">  <span class="keyword">FROM</span> employees</span><br><span class="line">  <span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id</span><br><span class="line">) d <span class="keyword">ON</span> e.department_id <span class="operator">=</span> d.department_id</span><br><span class="line"><span class="keyword">WHERE</span> e.salary <span class="operator">&gt;</span> d.avg_salary</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> e.department_id, e.salary <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure></p>
<p><strong>高级联结注意事项</strong>： 1. 多表联结时，注意联结顺序可能影响查询性能 2. 使用适当的索引可以显著提高联结操作的性能 3. 自联结时必须使用表别名来区分同一表的不同实例 4. 复杂的多表联结可能导致性能问题，应考虑使用子查询或视图优化 5. 联结多个大表时，应评估查询的复杂度和执行计划</p>
<h2 id="组合查询union">组合查询：UNION</h2>
<p>组合查询（UNION）是SQL中用于合并两个或多个SELECT语句结果集的操作符。它允许将多个查询的结果作为一个组合结果集返回，常用于从不同表或同一表的不同条件下获取相关数据并合并展示。</p>
<h3 id="union基本用法合并多个查询结果集">UNION基本用法（合并多个查询结果集）</h3>
<p>UNION操作符用于合并两个或多个SELECT语句的结果集，并自动去除重复的行。</p>
<p><strong>语法</strong>： <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 列<span class="number">1</span>, 列<span class="number">2</span>, ... <span class="keyword">FROM</span> 表<span class="number">1</span> [<span class="keyword">WHERE</span> 条件]</span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> 列<span class="number">1</span>, 列<span class="number">2</span>, ... <span class="keyword">FROM</span> 表<span class="number">2</span> [<span class="keyword">WHERE</span> 条件];</span><br></pre></td></tr></table></figure></p>
<p><strong>使用条件</strong>： 1. 每个SELECT语句必须具有相同数量的列 2. 对应列的数据类型必须兼容 3. 通常结果集中的列名由第一个SELECT语句决定</p>
<p><strong>示例1：合并两个表的查询结果</strong> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询所有员工和客户的联系信息</span></span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">  <span class="string">&#x27;employee&#x27;</span> <span class="keyword">AS</span> 类型,</span><br><span class="line">  employee_id <span class="keyword">AS</span> ID,</span><br><span class="line">  name <span class="keyword">AS</span> 姓名,</span><br><span class="line">  email <span class="keyword">AS</span> 邮箱,</span><br><span class="line">  phone <span class="keyword">AS</span> 电话</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> department <span class="operator">=</span> <span class="string">&#x27;销售&#x27;</span></span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">  <span class="string">&#x27;customer&#x27;</span> <span class="keyword">AS</span> 类型,</span><br><span class="line">  customer_id <span class="keyword">AS</span> ID,</span><br><span class="line">  customer_name <span class="keyword">AS</span> 姓名,</span><br><span class="line">  customer_email <span class="keyword">AS</span> 邮箱,</span><br><span class="line">  customer_phone <span class="keyword">AS</span> 电话</span><br><span class="line"><span class="keyword">FROM</span> customers</span><br><span class="line"><span class="keyword">WHERE</span> region <span class="operator">=</span> <span class="string">&#x27;华东&#x27;</span>;</span><br></pre></td></tr></table></figure></p>
<p><strong>示例2：同一表中不同条件的结果合并</strong> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询薪资高于8000的员工和工作年限超过5年的员工</span></span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">  employee_id,</span><br><span class="line">  name,</span><br><span class="line">  salary,</span><br><span class="line">  hire_date,</span><br><span class="line">  <span class="string">&#x27;高薪员工&#x27;</span> <span class="keyword">AS</span> 类型</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> salary <span class="operator">&gt;</span> <span class="number">8000</span></span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">  employee_id,</span><br><span class="line">  name,</span><br><span class="line">  salary,</span><br><span class="line">  hire_date,</span><br><span class="line">  <span class="string">&#x27;资深员工&#x27;</span> <span class="keyword">AS</span> 类型</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> DATEDIFF(CURDATE(), hire_date) <span class="operator">/</span> <span class="number">365</span> <span class="operator">&gt;</span> <span class="number">5</span>;</span><br></pre></td></tr></table></figure></p>
<p><strong>UNION使用注意事项</strong>： 1. UNION默认会去除重复行，这会增加额外的处理开销 2. 每个SELECT语句必须返回相同数量的列，且对应列的数据类型必须兼容 3. 列名可以不同，但结果集将使用第一个SELECT语句的列名 4. 可以使用ORDER BY子句对最终结果进行排序，但必须放在最后一个SELECT语句之后 5. ORDER BY影响的是整个组合后的结果集，而不是单个SELECT语句的结果</p>
<h3 id="union与union-all的区别去重-vs-保留重复">UNION与UNION ALL的区别（去重 vs 保留重复）</h3>
<p><strong>UNION ALL</strong> 是UNION的一个变种，它不会去除结果集中的重复行，直接合并所有行。</p>
<p><strong>语法</strong>： <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 列<span class="number">1</span>, 列<span class="number">2</span>, ... <span class="keyword">FROM</span> 表<span class="number">1</span> [<span class="keyword">WHERE</span> 条件]</span><br><span class="line"><span class="keyword">UNION</span> <span class="keyword">ALL</span></span><br><span class="line"><span class="keyword">SELECT</span> 列<span class="number">1</span>, 列<span class="number">2</span>, ... <span class="keyword">FROM</span> 表<span class="number">2</span> [<span class="keyword">WHERE</span> 条件];</span><br></pre></td></tr></table></figure></p>
<p><strong>UNION与UNION ALL的区别对比表</strong>：</p>
<table>
<thead>
<tr class="header">
<th>特性</th>
<th>UNION</th>
<th>UNION ALL</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>重复行处理</td>
<td>自动去除重复行</td>
<td>保留所有行（包括重复行）</td>
</tr>
<tr class="even">
<td>性能</td>
<td>较低（需要额外的去重操作）</td>
<td>较高（不需要去重）</td>
</tr>
<tr class="odd">
<td>适用场景</td>
<td>需要唯一结果集</td>
<td>需要包含所有结果，包括重复</td>
</tr>
<tr class="even">
<td>执行速度</td>
<td>较慢</td>
<td>较快</td>
</tr>
<tr class="odd">
<td>结果集大小</td>
<td>可能小于各SELECT语句结果集之和</td>
<td>等于各SELECT语句结果集之和</td>
</tr>
</tbody>
</table>
<p><strong>示例1：UNION ALL示例</strong> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 保留所有重复行的合并查询</span></span><br><span class="line"><span class="keyword">SELECT</span> product_name, category, price <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> category <span class="operator">=</span> <span class="string">&#x27;电子产品&#x27;</span></span><br><span class="line"><span class="keyword">UNION</span> <span class="keyword">ALL</span></span><br><span class="line"><span class="keyword">SELECT</span> product_name, category, price <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> price <span class="operator">&gt;</span> <span class="number">1000</span>;</span><br></pre></td></tr></table></figure></p>
<p><strong>示例2：对比UNION和UNION ALL的结果差异</strong> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建一个示例表</span></span><br><span class="line"><span class="keyword">CREATE TABLE</span> test_union (id <span class="type">INT</span>, name <span class="type">VARCHAR</span>(<span class="number">50</span>));</span><br><span class="line"><span class="keyword">INSERT INTO</span> test_union <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="string">&#x27;A&#x27;</span>), (<span class="number">2</span>, <span class="string">&#x27;B&#x27;</span>), (<span class="number">3</span>, <span class="string">&#x27;C&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- UNION示例（去重）</span></span><br><span class="line"><span class="keyword">SELECT</span> id, name <span class="keyword">FROM</span> test_union</span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> id, name <span class="keyword">FROM</span> test_union;</span><br><span class="line"><span class="comment">-- 结果：3行（去重后）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- UNION ALL示例（保留重复）</span></span><br><span class="line"><span class="keyword">SELECT</span> id, name <span class="keyword">FROM</span> test_union</span><br><span class="line"><span class="keyword">UNION</span> <span class="keyword">ALL</span></span><br><span class="line"><span class="keyword">SELECT</span> id, name <span class="keyword">FROM</span> test_union;</span><br><span class="line"><span class="comment">-- 结果：6行（保留所有重复）</span></span><br></pre></td></tr></table></figure></p>
<p><strong>使用建议</strong>： 1. 如果确认查询结果不会有重复，或需要保留所有重复行，应使用UNION ALL以提高性能 2. 对于大数据集的合并操作，UNION ALL的性能优势更为明显 3. 当需要唯一结果集时才使用UNION 4. 无论使用哪种方式，都应确保各个SELECT语句返回兼容的列结构</p>
<p><strong>高级用法示例</strong>： <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 使用UNION ALL和子查询进行复杂数据合并和统计</span></span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">  <span class="keyword">month</span>, </span><br><span class="line">  <span class="built_in">SUM</span>(sales) <span class="keyword">AS</span> total_sales,</span><br><span class="line">  <span class="built_in">SUM</span>(<span class="keyword">CASE</span> <span class="keyword">WHEN</span> region <span class="operator">=</span> <span class="string">&#x27;北区&#x27;</span> <span class="keyword">THEN</span> sales <span class="keyword">ELSE</span> <span class="number">0</span> <span class="keyword">END</span>) <span class="keyword">AS</span> north_sales,</span><br><span class="line">  <span class="built_in">SUM</span>(<span class="keyword">CASE</span> <span class="keyword">WHEN</span> region <span class="operator">=</span> <span class="string">&#x27;南区&#x27;</span> <span class="keyword">THEN</span> sales <span class="keyword">ELSE</span> <span class="number">0</span> <span class="keyword">END</span>) <span class="keyword">AS</span> south_sales</span><br><span class="line"><span class="keyword">FROM</span> (</span><br><span class="line">  <span class="comment">-- 北区销售数据</span></span><br><span class="line">  <span class="keyword">SELECT</span> </span><br><span class="line">    DATE_FORMAT(order_date, <span class="string">&#x27;%Y-%m&#x27;</span>) <span class="keyword">AS</span> <span class="keyword">month</span>,</span><br><span class="line">    <span class="string">&#x27;北区&#x27;</span> <span class="keyword">AS</span> region,</span><br><span class="line">    <span class="built_in">SUM</span>(order_amount) <span class="keyword">AS</span> sales</span><br><span class="line">  <span class="keyword">FROM</span> orders</span><br><span class="line">  <span class="keyword">WHERE</span> region <span class="operator">=</span> <span class="string">&#x27;北区&#x27;</span> <span class="keyword">AND</span> order_date <span class="keyword">BETWEEN</span> <span class="string">&#x27;2023-01-01&#x27;</span> <span class="keyword">AND</span> <span class="string">&#x27;2023-12-31&#x27;</span></span><br><span class="line">  <span class="keyword">GROUP</span> <span class="keyword">BY</span> DATE_FORMAT(order_date, <span class="string">&#x27;%Y-%m&#x27;</span>)</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">UNION</span> <span class="keyword">ALL</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">-- 南区销售数据</span></span><br><span class="line">  <span class="keyword">SELECT</span> </span><br><span class="line">    DATE_FORMAT(order_date, <span class="string">&#x27;%Y-%m&#x27;</span>) <span class="keyword">AS</span> <span class="keyword">month</span>,</span><br><span class="line">    <span class="string">&#x27;南区&#x27;</span> <span class="keyword">AS</span> region,</span><br><span class="line">    <span class="built_in">SUM</span>(order_amount) <span class="keyword">AS</span> sales</span><br><span class="line">  <span class="keyword">FROM</span> orders</span><br><span class="line">  <span class="keyword">WHERE</span> region <span class="operator">=</span> <span class="string">&#x27;南区&#x27;</span> <span class="keyword">AND</span> order_date <span class="keyword">BETWEEN</span> <span class="string">&#x27;2023-01-01&#x27;</span> <span class="keyword">AND</span> <span class="string">&#x27;2023-12-31&#x27;</span></span><br><span class="line">  <span class="keyword">GROUP</span> <span class="keyword">BY</span> DATE_FORMAT(order_date, <span class="string">&#x27;%Y-%m&#x27;</span>)</span><br><span class="line">) <span class="keyword">AS</span> regional_sales</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">month</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">month</span>;</span><br></pre></td></tr></table></figure></p>
<h3 id="union的性能优化建议">UNION的性能优化建议</h3>
<ol type="1">
<li><strong>优先使用UNION ALL</strong>：如果不需要去重，UNION ALL比UNION效率高很多</li>
<li><strong>限制结果集大小</strong>：在每个SELECT语句中使用WHERE条件过滤不必要的数据</li>
<li><strong>合理索引</strong>：为各个SELECT语句中的WHERE条件字段创建适当的索引</li>
<li><strong>避免在UNION中使用复杂函数</strong>：尽量在UNION之前处理数据转换和计算</li>
<li><strong>考虑使用临时表</strong>：对于非常复杂的UNION查询，可以考虑使用临时表存储中间结果</li>
<li><strong>列数精简</strong>：只选择必要的列，减少数据传输量</li>
</ol>
<h2 id="全文本搜索基础用法">全文本搜索（基础用法）</h2>
<p>全文本搜索是MySQL提供的一种高级搜索功能，用于在文本数据中进行复杂的关键词搜索，比简单的LIKE查询更强大、更高效。</p>
<h3 id="全文本搜索的基本概念与作用">全文本搜索的基本概念与作用</h3>
<p><strong>全文本搜索的概念</strong>： 全文本搜索是一种基于文本内容的搜索技术，它能够在文本数据中查找包含指定关键词的记录，并根据相关性对结果进行排序。</p>
<p><strong>全文本搜索的主要作用</strong>： 1. 实现复杂的文本内容检索 2. 支持关键词、短语和布尔逻辑搜索 3. 根据相关性对结果排序 4. 比LIKE查询（特别是使用通配符的查询）效率更高 5. 支持自然语言搜索模式</p>
<p><strong>适用场景</strong>： - 文章内容搜索 - 产品描述搜索 - 用户评论搜索 - 日志分析 - 文档管理系统</p>
<h3 id="创建全文本索引">创建全文本索引</h3>
<p>在使用全文本搜索之前，需要先为目标表创建全文本索引。</p>
<p><strong>语法</strong>： <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> FULLTEXT INDEX 索引名 <span class="keyword">ON</span> 表名(列名<span class="number">1</span>, 列名<span class="number">2</span>, ...);</span><br></pre></td></tr></table></figure></p>
<p><strong>示例</strong>： <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 为文章表创建全文本索引</span></span><br><span class="line"><span class="keyword">CREATE TABLE</span> articles (</span><br><span class="line">  id <span class="type">INT</span> <span class="keyword">PRIMARY KEY</span> AUTO_INCREMENT,</span><br><span class="line">  title <span class="type">VARCHAR</span>(<span class="number">200</span>),</span><br><span class="line">  content TEXT,</span><br><span class="line">  publish_date <span class="type">DATE</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 在title和content列上创建全文本索引</span></span><br><span class="line"><span class="keyword">CREATE</span> FULLTEXT INDEX idx_article_search <span class="keyword">ON</span> articles(title, content);</span><br></pre></td></tr></table></figure></p>
<p><strong>注意事项</strong>： 1. 全文本索引只能用于MyISAM和InnoDB存储引擎 2. 仅适用于CHAR、VARCHAR和TEXT类型的列 3. 一个表可以有多个全文本索引，但通常在需要搜索的列上创建一个复合索引 4. 索引会占用额外的存储空间，但能显著提高搜索性能</p>
<h3 id="使用match-against进行全文本搜索">使用MATCH AGAINST进行全文本搜索</h3>
<p>全文本搜索主要通过MATCH()和AGAINST()函数实现。</p>
<p><strong>基本语法</strong>： <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 列名</span><br><span class="line"><span class="keyword">FROM</span> 表名</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">MATCH</span>(列名<span class="number">1</span>, 列名<span class="number">2</span>, ...) AGAINST(<span class="string">&#x27;搜索关键词&#x27;</span> [搜索模式]);</span><br></pre></td></tr></table></figure></p>
<p><strong>搜索模式</strong>： 1. <strong>自然语言模式（默认）</strong>：理解搜索短语的自然语言含义 2. <strong>布尔模式</strong>：使用布尔操作符组合关键词进行精确搜索 3. <strong>查询扩展模式</strong>：基于初始结果扩展搜索范围</p>
<h3 id="自然语言模式搜索默认">1. 自然语言模式搜索（默认）</h3>
<p><strong>语法</strong>： <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 列名</span><br><span class="line"><span class="keyword">FROM</span> 表名</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">MATCH</span>(列名<span class="number">1</span>, 列名<span class="number">2</span>, ...) AGAINST(<span class="string">&#x27;搜索关键词&#x27;</span>);</span><br></pre></td></tr></table></figure></p>
<p><strong>示例</strong>： <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 在文章表中搜索包含&quot;数据库&quot;关键词的文章</span></span><br><span class="line"><span class="keyword">SELECT</span> id, title, content</span><br><span class="line"><span class="keyword">FROM</span> articles</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">MATCH</span>(title, content) AGAINST(<span class="string">&#x27;数据库&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 搜索包含多个关键词的文章（或关系）</span></span><br><span class="line"><span class="keyword">SELECT</span> id, title, content</span><br><span class="line"><span class="keyword">FROM</span> articles</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">MATCH</span>(title, content) AGAINST(<span class="string">&#x27;数据库 MySQL&#x27;</span>);</span><br></pre></td></tr></table></figure></p>
<p><strong>自然语言模式特点</strong>： 1. 默认按相关性排序结果 2. 忽略常见词（停用词）如“a”、“the”、“and”等 3. 忽略出现频率过高的词（超过50%的行） 4. 不区分大小写（取决于字符集和排序规则）</p>
<h3 id="布尔模式搜索">2. 布尔模式搜索</h3>
<p>布尔模式支持更精确的控制，使用布尔操作符组合关键词。</p>
<p><strong>语法</strong>： <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 列名</span><br><span class="line"><span class="keyword">FROM</span> 表名</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">MATCH</span>(列名<span class="number">1</span>, 列名<span class="number">2</span>, ...) AGAINST(<span class="string">&#x27;搜索条件&#x27;</span> <span class="keyword">IN</span> <span class="type">BOOLEAN</span> MODE);</span><br></pre></td></tr></table></figure></p>
<p><strong>常用布尔操作符</strong>：</p>
<table>
<thead>
<tr class="header">
<th>操作符</th>
<th>作用</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>+</td>
<td>必须包含该词</td>
<td>+数据库 +MySQL</td>
</tr>
<tr class="even">
<td>-</td>
<td>必须不包含该词</td>
<td>+数据库 -Oracle</td>
</tr>
<tr class="odd">
<td>&gt;</td>
<td>提高该词的相关性</td>
<td>+数据库 &gt;MySQL</td>
</tr>
<tr class="even">
<td>&lt;</td>
<td>降低该词的相关性</td>
<td>+数据库 &lt;MySQL</td>
</tr>
<tr class="odd">
<td>*</td>
<td>词尾通配符</td>
<td>data* 匹配 data、database、databases等</td>
</tr>
<tr class="even">
<td>""</td>
<td>精确短语匹配</td>
<td>“数据库管理系统”</td>
</tr>
<tr class="odd">
<td>()</td>
<td>分组</td>
<td>+(数据库 OR MySQL) +优化</td>
</tr>
</tbody>
</table>
<p><strong>示例</strong>： <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 搜索必须包含&quot;数据库&quot;且不包含&quot;Oracle&quot;的文章</span></span><br><span class="line"><span class="keyword">SELECT</span> id, title, content</span><br><span class="line"><span class="keyword">FROM</span> articles</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">MATCH</span>(title, content) AGAINST(<span class="string">&#x27;+数据库 -Oracle&#x27;</span> <span class="keyword">IN</span> <span class="type">BOOLEAN</span> MODE);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 搜索必须包含&quot;MySQL优化&quot;这个短语的文章</span></span><br><span class="line"><span class="keyword">SELECT</span> id, title, content</span><br><span class="line"><span class="keyword">FROM</span> articles</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">MATCH</span>(title, content) AGAINST(<span class="string">&#x27;&quot;MySQL优化&quot;&#x27;</span> <span class="keyword">IN</span> <span class="type">BOOLEAN</span> MODE);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 搜索包含以&quot;数据&quot;开头的词和&quot;性能&quot;的文章</span></span><br><span class="line"><span class="keyword">SELECT</span> id, title, content</span><br><span class="line"><span class="keyword">FROM</span> articles</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">MATCH</span>(title, content) AGAINST(<span class="string">&#x27;+数据* +性能&#x27;</span> <span class="keyword">IN</span> <span class="type">BOOLEAN</span> MODE);</span><br></pre></td></tr></table></figure></p>
<h3 id="查询扩展模式搜索">3. 查询扩展模式搜索</h3>
<p>查询扩展模式首先执行自然语言搜索，然后基于初始结果中的关键词进行二次搜索，以扩展搜索范围。</p>
<p><strong>语法</strong>： <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 列名</span><br><span class="line"><span class="keyword">FROM</span> 表名</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">MATCH</span>(列名<span class="number">1</span>, 列名<span class="number">2</span>, ...) AGAINST(<span class="string">&#x27;搜索关键词&#x27;</span> <span class="keyword">WITH</span> QUERY EXPANSION);</span><br></pre></td></tr></table></figure></p>
<p><strong>示例</strong>： <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 使用查询扩展模式搜索与&quot;数据库优化&quot;相关的文章</span></span><br><span class="line"><span class="keyword">SELECT</span> id, title, content</span><br><span class="line"><span class="keyword">FROM</span> articles</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">MATCH</span>(title, content) AGAINST(<span class="string">&#x27;数据库优化&#x27;</span> <span class="keyword">WITH</span> QUERY EXPANSION);</span><br></pre></td></tr></table></figure></p>
<p><strong>查询扩展模式特点</strong>： 1. 可能返回更多相关但不完全匹配的结果 2. 适用于需要扩大搜索范围的场景 3. 可能降低搜索精度，但提高召回率</p>
<h3 id="获取相关性得分">获取相关性得分</h3>
<p>可以通过在SELECT子句中包含MATCH() AGAINST()函数来获取结果的相关性得分。</p>
<p><strong>语法</strong>： <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 列名, <span class="keyword">MATCH</span>(列名<span class="number">1</span>, 列名<span class="number">2</span>, ...) AGAINST(<span class="string">&#x27;搜索关键词&#x27;</span>) <span class="keyword">AS</span> relevance_score</span><br><span class="line"><span class="keyword">FROM</span> 表名</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">MATCH</span>(列名<span class="number">1</span>, 列名<span class="number">2</span>, ...) AGAINST(<span class="string">&#x27;搜索关键词&#x27;</span>);</span><br></pre></td></tr></table></figure></p>
<p><strong>示例</strong>： <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 获取搜索结果及其相关性得分</span></span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">  id, </span><br><span class="line">  title, </span><br><span class="line">  <span class="keyword">MATCH</span>(title, content) AGAINST(<span class="string">&#x27;MySQL优化&#x27;</span> <span class="keyword">IN</span> <span class="type">BOOLEAN</span> MODE) <span class="keyword">AS</span> relevance_score</span><br><span class="line"><span class="keyword">FROM</span> articles</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">MATCH</span>(title, content) AGAINST(<span class="string">&#x27;MySQL优化&#x27;</span> <span class="keyword">IN</span> <span class="type">BOOLEAN</span> MODE)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> relevance_score <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure></p>
<h3 id="全文本搜索的注意事项">全文本搜索的注意事项</h3>
<ol type="1">
<li><strong>索引更新</strong>：
<ul>
<li>当表中数据发生变化时，全文本索引会自动更新</li>
<li>对于大数据量插入，考虑先禁用索引，插入数据后再重建索引</li>
</ul></li>
<li><strong>性能优化</strong>：
<ul>
<li>只对需要搜索的列创建全文本索引</li>
<li>避免在小表上使用全文本搜索（直接使用LIKE可能更简单）</li>
<li>对于非常大的表，考虑使用专门的搜索引擎如Elasticsearch</li>
</ul></li>
<li><strong>配置参数</strong>：
<ul>
<li>MySQL默认有一些配置参数控制全文本搜索的行为</li>
<li>可以调整ft_min_word_len参数设置最小搜索词长度（默认4个字符）</li>
<li>可以自定义停用词列表</li>
</ul></li>
<li><strong>限制</strong>：
<ul>
<li>全文本索引有大小限制</li>
<li>搜索结果可能受到MySQL停用词列表的影响</li>
<li>对于不支持全文本索引的存储引擎，需要使用其他方法</li>
</ul></li>
</ol>
<h3 id="全文本搜索与like查询的对比">全文本搜索与LIKE查询的对比</h3>
<table>
<thead>
<tr class="header">
<th>特性</th>
<th>全文本搜索</th>
<th>LIKE查询</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>搜索效率</td>
<td>高（使用索引）</td>
<td>低（尤其是以通配符开头的查询）</td>
</tr>
<tr class="even">
<td>搜索功能</td>
<td>强大（支持自然语言、布尔逻辑）</td>
<td>简单（仅支持通配符匹配）</td>
</tr>
<tr class="odd">
<td>相关性排序</td>
<td>支持</td>
<td>不支持</td>
</tr>
<tr class="even">
<td>适用场景</td>
<td>大型文本搜索</td>
<td>简单模式匹配</td>
</tr>
<tr class="odd">
<td>索引支持</td>
<td>需要全文本索引</td>
<td>可使用普通索引（有限）</td>
</tr>
<tr class="even">
<td>资源消耗</td>
<td>索引创建时较高，搜索时较低</td>
<td>搜索时较高</td>
</tr>
</tbody>
</table>
<p><strong>示例对比</strong>： <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 使用全文本搜索</span></span><br><span class="line"><span class="keyword">SELECT</span> id, title <span class="keyword">FROM</span> articles </span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">MATCH</span>(title, content) AGAINST(<span class="string">&#x27;MySQL性能优化&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 等效的LIKE查询</span></span><br><span class="line"><span class="keyword">SELECT</span> id, title <span class="keyword">FROM</span> articles </span><br><span class="line"><span class="keyword">WHERE</span> title <span class="keyword">LIKE</span> <span class="string">&#x27;%MySQL%&#x27;</span> <span class="keyword">OR</span> content <span class="keyword">LIKE</span> <span class="string">&#x27;%MySQL%&#x27;</span></span><br><span class="line">   <span class="keyword">OR</span> title <span class="keyword">LIKE</span> <span class="string">&#x27;%性能优化%&#x27;</span> <span class="keyword">OR</span> content <span class="keyword">LIKE</span> <span class="string">&#x27;%性能优化%&#x27;</span>;</span><br></pre></td></tr></table></figure></p>
<h1 id="数据操作增删改">数据操作（增删改）</h1>
<h2 id="insert插入数据">INSERT（插入数据）</h2>
<p>INSERT语句用于向表中插入新记录。MySQL支持多种插入数据的方式，下面分别介绍：</p>
<h3 id="插入单行数据insert-into-表列1-values值1">插入单行数据（<code>INSERT INTO 表(列1) VALUES(值1)</code>）</h3>
<p><strong>基本语法</strong>： <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT INTO</span> 表名 (列<span class="number">1</span>, 列<span class="number">2</span>, 列<span class="number">3</span>, ...) <span class="keyword">VALUES</span> (值<span class="number">1</span>, 值<span class="number">2</span>, 值<span class="number">3</span>, ...);</span><br></pre></td></tr></table></figure></p>
<p><strong>示例</strong>：向员工表插入一条记录 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT INTO</span> employees (id, name, age, department, salary) </span><br><span class="line"><span class="keyword">VALUES</span> (<span class="number">1001</span>, <span class="string">&#x27;张三&#x27;</span>, <span class="number">28</span>, <span class="string">&#x27;技术部&#x27;</span>, <span class="number">8000</span>);</span><br></pre></td></tr></table></figure></p>
<p><strong>简化写法</strong>：如果插入所有列且顺序与表结构一致，可以省略列名列表 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT INTO</span> employees </span><br><span class="line"><span class="keyword">VALUES</span> (<span class="number">1002</span>, <span class="string">&#x27;李四&#x27;</span>, <span class="number">32</span>, <span class="string">&#x27;市场部&#x27;</span>, <span class="number">9000</span>);</span><br></pre></td></tr></table></figure></p>
<p><strong>注意事项</strong>： - 字符串类型的值需要用单引号或双引号括起来 - 数值类型的值直接写，不需要引号 - 如果某列允许NULL值且不提供数据，可以写NULL或省略该列</p>
<h3 id="插入多行数据insert-into-表-values值1值2">插入多行数据（<code>INSERT INTO 表 VALUES(值1),(值2)</code>）</h3>
<p>通过在VALUES子句中提供多个值列表，可以一次性插入多条记录，比多次执行单行插入更高效。</p>
<p><strong>基本语法</strong>： <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT INTO</span> 表名 (列<span class="number">1</span>, 列<span class="number">2</span>, ...) </span><br><span class="line"><span class="keyword">VALUES</span> (值<span class="number">1</span>_1, 值<span class="number">1</span>_2, ...),</span><br><span class="line">       (值<span class="number">2</span>_1, 值<span class="number">2</span>_2, ...),</span><br><span class="line">       (值<span class="number">3</span>_1, 值<span class="number">3</span>_2, ...);</span><br></pre></td></tr></table></figure></p>
<p><strong>示例</strong>：向员工表批量插入多条记录 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT INTO</span> employees (id, name, age, department, salary) </span><br><span class="line"><span class="keyword">VALUES</span> (<span class="number">1003</span>, <span class="string">&#x27;王五&#x27;</span>, <span class="number">25</span>, <span class="string">&#x27;财务部&#x27;</span>, <span class="number">7500</span>),</span><br><span class="line">       (<span class="number">1004</span>, <span class="string">&#x27;赵六&#x27;</span>, <span class="number">35</span>, <span class="string">&#x27;技术部&#x27;</span>, <span class="number">12000</span>),</span><br><span class="line">       (<span class="number">1005</span>, <span class="string">&#x27;钱七&#x27;</span>, <span class="number">29</span>, <span class="string">&#x27;人事部&#x27;</span>, <span class="number">8500</span>);</span><br></pre></td></tr></table></figure></p>
<p><strong>优势</strong>： - 减少数据库连接次数，提高性能 - 原子性操作，要么全部插入成功，要么全部失败 - 减少网络传输开销</p>
<h3 id="插入查询结果insert-...-select批量复制数据">插入查询结果（<code>INSERT ... SELECT</code>，批量复制数据）</h3>
<p>使用INSERT … SELECT语句可以将一个查询的结果集插入到另一个表中，常用于数据迁移、备份或批量处理。</p>
<p><strong>基本语法</strong>： <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT INTO</span> 目标表 (列<span class="number">1</span>, 列<span class="number">2</span>, ...)</span><br><span class="line"><span class="keyword">SELECT</span> 列<span class="number">1</span>, 列<span class="number">2</span>, ...</span><br><span class="line"><span class="keyword">FROM</span> 源表</span><br><span class="line"><span class="keyword">WHERE</span> 条件;</span><br></pre></td></tr></table></figure></p>
<p><strong>示例</strong>：将技术部员工复制到临时表 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 先创建临时表</span></span><br><span class="line"><span class="keyword">CREATE TABLE</span> temp_tech_employees <span class="keyword">LIKE</span> employees;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 将技术部员工数据插入临时表</span></span><br><span class="line"><span class="keyword">INSERT INTO</span> temp_tech_employees (id, name, age, department, salary)</span><br><span class="line"><span class="keyword">SELECT</span> id, name, age, department, salary</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> department <span class="operator">=</span> <span class="string">&#x27;技术部&#x27;</span>;</span><br></pre></td></tr></table></figure></p>
<p><strong>高级用法</strong>：插入时进行数据转换或计算 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 插入时调整薪资并添加入职日期</span></span><br><span class="line"><span class="keyword">INSERT INTO</span> employee_history (emp_id, emp_name, department, adjusted_salary, hire_date)</span><br><span class="line"><span class="keyword">SELECT</span> id, name, department, salary <span class="operator">*</span> <span class="number">1.1</span>, CURDATE()</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> hire_date <span class="operator">&lt;</span> <span class="string">&#x27;2023-01-01&#x27;</span>;</span><br></pre></td></tr></table></figure></p>
<h3 id="insert-ignore忽略冲突">INSERT IGNORE（忽略冲突）</h3>
<p>当插入数据可能导致唯一键冲突时，可以使用INSERT IGNORE来忽略冲突的记录，继续插入其他记录。</p>
<p><strong>语法</strong>： <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> IGNORE <span class="keyword">INTO</span> 表名 (列<span class="number">1</span>, 列<span class="number">2</span>, ...)</span><br><span class="line"><span class="keyword">VALUES</span> (值<span class="number">1</span>, 值<span class="number">2</span>, ...);</span><br></pre></td></tr></table></figure></p>
<p><strong>示例</strong>：插入可能存在重复ID的记录 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 如果ID=1001的记录已存在，则忽略这条插入</span></span><br><span class="line"><span class="keyword">INSERT</span> IGNORE <span class="keyword">INTO</span> employees (id, name, age, department, salary)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="number">1001</span>, <span class="string">&#x27;张三&#x27;</span>, <span class="number">29</span>, <span class="string">&#x27;技术部&#x27;</span>, <span class="number">8500</span>);</span><br></pre></td></tr></table></figure></p>
<h3 id="insert-on-duplicate-key-update冲突时更新">INSERT … ON DUPLICATE KEY UPDATE（冲突时更新）</h3>
<p>当插入数据发生唯一键冲突时，不仅可以忽略，还可以选择更新已存在的记录。</p>
<p><strong>语法</strong>： <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT INTO</span> 表名 (列<span class="number">1</span>, 列<span class="number">2</span>, ...) </span><br><span class="line"><span class="keyword">VALUES</span> (值<span class="number">1</span>, 值<span class="number">2</span>, ...)</span><br><span class="line"><span class="keyword">ON</span> DUPLICATE KEY <span class="keyword">UPDATE</span> 列<span class="number">1</span><span class="operator">=</span>新值<span class="number">1</span>, 列<span class="number">2</span><span class="operator">=</span>新值<span class="number">2</span>, ...;</span><br></pre></td></tr></table></figure></p>
<p><strong>示例</strong>：插入或更新员工信息 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT INTO</span> employees (id, name, age, department, salary)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="number">1001</span>, <span class="string">&#x27;张三&#x27;</span>, <span class="number">29</span>, <span class="string">&#x27;技术部&#x27;</span>, <span class="number">8500</span>)</span><br><span class="line"><span class="keyword">ON</span> DUPLICATE KEY <span class="keyword">UPDATE</span> </span><br><span class="line">    name<span class="operator">=</span><span class="string">&#x27;张三&#x27;</span>,</span><br><span class="line">    age<span class="operator">=</span><span class="number">29</span>,</span><br><span class="line">    department<span class="operator">=</span><span class="string">&#x27;技术部&#x27;</span>,</span><br><span class="line">    salary<span class="operator">=</span><span class="number">8500</span>;</span><br></pre></td></tr></table></figure></p>
<p><strong>使用VALUES()引用插入值</strong>： <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT INTO</span> employees (id, name, age, department, salary)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="number">1001</span>, <span class="string">&#x27;张三&#x27;</span>, <span class="number">29</span>, <span class="string">&#x27;技术部&#x27;</span>, <span class="number">8500</span>)</span><br><span class="line"><span class="keyword">ON</span> DUPLICATE KEY <span class="keyword">UPDATE</span> </span><br><span class="line">    name<span class="operator">=</span><span class="keyword">VALUES</span>(name),</span><br><span class="line">    age<span class="operator">=</span><span class="keyword">VALUES</span>(age),</span><br><span class="line">    department<span class="operator">=</span><span class="keyword">VALUES</span>(department),</span><br><span class="line">    salary<span class="operator">=</span><span class="keyword">VALUES</span>(salary);</span><br></pre></td></tr></table></figure></p>
<h3 id="插入注意事项">插入注意事项</h3>
<ol type="1">
<li><p><strong>自增字段</strong>：如果表有自增主键，插入时可以不指定该字段，MySQL会自动生成 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT INTO</span> employees (name, age, department, salary)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;孙八&#x27;</span>, <span class="number">31</span>, <span class="string">&#x27;销售部&#x27;</span>, <span class="number">9500</span>);</span><br></pre></td></tr></table></figure></p></li>
<li><p><strong>日期时间</strong>：插入日期时间可以使用字符串或函数 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 使用字符串</span></span><br><span class="line"><span class="keyword">INSERT INTO</span> events (event_name, event_date)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;产品发布会&#x27;</span>, <span class="string">&#x27;2024-12-01 10:00:00&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 使用函数</span></span><br><span class="line"><span class="keyword">INSERT INTO</span> events (event_name, event_date)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;技术沙龙&#x27;</span>, NOW());</span><br></pre></td></tr></table></figure></p></li>
<li><p><strong>事务性</strong>：在事务中使用INSERT可以确保数据一致性 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line"><span class="keyword">INSERT INTO</span> orders (customer_id, order_date) <span class="keyword">VALUES</span> (<span class="number">101</span>, NOW());</span><br><span class="line"><span class="keyword">INSERT INTO</span> order_items (order_id, product_id, quantity) <span class="keyword">VALUES</span> (LAST_INSERT_ID(), <span class="number">501</span>, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure></p></li>
<li><p><strong>性能考虑</strong>：</p>
<ul>
<li>批量插入多行数据比单行插入效率高</li>
<li>插入大量数据时考虑关闭自动提交</li>
<li>适当使用索引，但注意插入时索引会增加开销</li>
</ul></li>
</ol>
<h2 id="update更新数据">UPDATE（更新数据）</h2>
<p>UPDATE语句用于修改表中已存在的记录。MySQL提供了灵活的更新语法，可以更新单个或多个字段，以及基于特定条件更新记录。</p>
<h3 id="基本用法update-表-set-列值-where-条件">基本用法（<code>UPDATE 表 SET 列=值 WHERE 条件</code>）</h3>
<p><strong>基本语法</strong>： <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> 表名</span><br><span class="line"><span class="keyword">SET</span> 列<span class="number">1</span><span class="operator">=</span>值<span class="number">1</span>, 列<span class="number">2</span><span class="operator">=</span>值<span class="number">2</span>, ...</span><br><span class="line"><span class="keyword">WHERE</span> 条件;</span><br></pre></td></tr></table></figure></p>
<p><strong>示例</strong>：更新单个员工的薪资 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> employees</span><br><span class="line"><span class="keyword">SET</span> salary <span class="operator">=</span> <span class="number">8500</span></span><br><span class="line"><span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1001</span>;</span><br></pre></td></tr></table></figure></p>
<p><strong>示例</strong>：同时更新多个字段 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> employees</span><br><span class="line"><span class="keyword">SET</span> name <span class="operator">=</span> <span class="string">&#x27;张三(已更名)&#x27;</span>, age <span class="operator">=</span> <span class="number">29</span>, department <span class="operator">=</span> <span class="string">&#x27;研发部&#x27;</span></span><br><span class="line"><span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1001</span>;</span><br></pre></td></tr></table></figure></p>
<h3 id="更新多个记录">更新多个记录</h3>
<p>通过条件可以同时更新符合条件的多条记录。</p>
<p><strong>示例</strong>：给技术部所有员工加薪10% <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> employees</span><br><span class="line"><span class="keyword">SET</span> salary <span class="operator">=</span> salary <span class="operator">*</span> <span class="number">1.1</span></span><br><span class="line"><span class="keyword">WHERE</span> department <span class="operator">=</span> <span class="string">&#x27;技术部&#x27;</span>;</span><br></pre></td></tr></table></figure></p>
<h3 id="基于其他表的数据更新">基于其他表的数据更新</h3>
<p>使用UPDATE JOIN可以基于其他表的数据来更新当前表。</p>
<p><strong>语法</strong>： <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> 表<span class="number">1</span></span><br><span class="line"><span class="keyword">JOIN</span> 表<span class="number">2</span> <span class="keyword">ON</span> 表<span class="number">1.</span>列 <span class="operator">=</span> 表<span class="number">2.</span>列</span><br><span class="line"><span class="keyword">SET</span> 表<span class="number">1.</span>列<span class="number">1</span> <span class="operator">=</span> 值<span class="number">1</span>, 表<span class="number">1.</span>列<span class="number">2</span> <span class="operator">=</span> 值<span class="number">2</span>, ...</span><br><span class="line"><span class="keyword">WHERE</span> 条件;</span><br></pre></td></tr></table></figure></p>
<p><strong>示例</strong>：根据部门表的信息更新员工表的部门名称 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 假设我们有一个departments表存储最新的部门信息</span></span><br><span class="line"><span class="keyword">UPDATE</span> employees e</span><br><span class="line"><span class="keyword">JOIN</span> departments d <span class="keyword">ON</span> e.department_id <span class="operator">=</span> d.id</span><br><span class="line"><span class="keyword">SET</span> e.department_name <span class="operator">=</span> d.new_name</span><br><span class="line"><span class="keyword">WHERE</span> d.need_update <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure></p>
<h3 id="使用case语句进行条件更新">使用CASE语句进行条件更新</h3>
<p>在UPDATE语句中使用CASE可以实现复杂的条件逻辑更新。</p>
<p><strong>示例</strong>：根据员工绩效调整薪资 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> employees</span><br><span class="line"><span class="keyword">SET</span> salary <span class="operator">=</span> <span class="keyword">CASE</span></span><br><span class="line">    <span class="keyword">WHEN</span> performance_rating <span class="operator">=</span> <span class="string">&#x27;优秀&#x27;</span> <span class="keyword">THEN</span> salary <span class="operator">*</span> <span class="number">1.15</span></span><br><span class="line">    <span class="keyword">WHEN</span> performance_rating <span class="operator">=</span> <span class="string">&#x27;良好&#x27;</span> <span class="keyword">THEN</span> salary <span class="operator">*</span> <span class="number">1.10</span></span><br><span class="line">    <span class="keyword">WHEN</span> performance_rating <span class="operator">=</span> <span class="string">&#x27;一般&#x27;</span> <span class="keyword">THEN</span> salary <span class="operator">*</span> <span class="number">1.05</span></span><br><span class="line">    <span class="keyword">ELSE</span> salary</span><br><span class="line"><span class="keyword">END</span></span><br><span class="line"><span class="keyword">WHERE</span> hire_date <span class="operator">&lt;</span> <span class="string">&#x27;2023-01-01&#x27;</span>;</span><br></pre></td></tr></table></figure></p>
<h3 id="更新自增字段">更新自增字段</h3>
<p>虽然不常见，但在某些情况下可能需要手动更新自增字段。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 需要特殊权限才能更新自增字段</span></span><br><span class="line"><span class="keyword">UPDATE</span> employees</span><br><span class="line"><span class="keyword">SET</span> id <span class="operator">=</span> <span class="number">2000</span></span><br><span class="line"><span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1001</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 通常更安全的做法是重新设置自增计数器</span></span><br><span class="line"><span class="keyword">ALTER TABLE</span> employees AUTO_INCREMENT <span class="operator">=</span> <span class="number">3000</span>;</span><br></pre></td></tr></table></figure>
<h3 id="update的重要注意事项">UPDATE的重要注意事项</h3>
<ol type="1">
<li><p><strong>WHERE条件</strong>：始终添加WHERE条件，否则会更新表中的所有记录！ <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 危险操作！会更新所有员工的薪资</span></span><br><span class="line"><span class="keyword">UPDATE</span> employees <span class="keyword">SET</span> salary <span class="operator">=</span> <span class="number">8000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 正确做法：添加WHERE条件</span></span><br><span class="line"><span class="keyword">UPDATE</span> employees <span class="keyword">SET</span> salary <span class="operator">=</span> <span class="number">8000</span> <span class="keyword">WHERE</span> department <span class="operator">=</span> <span class="string">&#x27;人事部&#x27;</span>;</span><br></pre></td></tr></table></figure></p></li>
<li><p><strong>事务性</strong>：在重要更新操作前开启事务，以便在出错时可以回滚 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line"><span class="keyword">UPDATE</span> accounts <span class="keyword">SET</span> balance <span class="operator">=</span> balance <span class="operator">-</span> <span class="number">1000</span> <span class="keyword">WHERE</span> account_id <span class="operator">=</span> <span class="number">123</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> accounts <span class="keyword">SET</span> balance <span class="operator">=</span> balance <span class="operator">+</span> <span class="number">1000</span> <span class="keyword">WHERE</span> account_id <span class="operator">=</span> <span class="number">456</span>;</span><br><span class="line"><span class="comment">-- 如果有错误，执行 ROLLBACK;</span></span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure></p></li>
<li><p><strong>性能考虑</strong>：</p>
<ul>
<li>确保WHERE条件使用的列有索引</li>
<li>只更新必要的字段</li>
<li>对于大批量更新，考虑分批处理</li>
</ul></li>
<li><p><strong>触发器影响</strong>：更新操作可能会触发定义在表上的触发器</p></li>
<li><p><strong>权限控制</strong>：确保当前用户有表的UPDATE权限</p></li>
<li><p><strong>更新NULL值</strong>：可以显式将列值设置为NULL <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> employees <span class="keyword">SET</span> department <span class="operator">=</span> <span class="keyword">NULL</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1001</span>;</span><br></pre></td></tr></table></figure></p></li>
</ol>
<h2 id="delete删除数据">DELETE（删除数据）</h2>
<p>DELETE语句用于从表中删除记录。MySQL提供了灵活的删除语法，可以删除单行、多行或全部记录，也可以基于特定条件删除记录。</p>
<h3 id="基本用法delete-from-表-where-条件">基本用法（<code>DELETE FROM 表 WHERE 条件</code>）</h3>
<p><strong>基本语法</strong>： <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> 表名</span><br><span class="line"><span class="keyword">WHERE</span> 条件;</span><br></pre></td></tr></table></figure></p>
<p><strong>示例</strong>：删除单个员工记录 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1001</span>;</span><br></pre></td></tr></table></figure></p>
<p><strong>示例</strong>：删除满足特定条件的多条记录 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> department <span class="operator">=</span> <span class="string">&#x27;财务部&#x27;</span> <span class="keyword">AND</span> age <span class="operator">&gt;</span> <span class="number">60</span>;</span><br></pre></td></tr></table></figure></p>
<h3 id="删除表中的所有记录">删除表中的所有记录</h3>
<p>如果不带WHERE条件，DELETE语句会删除表中的所有记录。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 删除employees表中的所有记录（谨慎使用！）</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure>
<h3 id="使用limit限制删除数量">使用LIMIT限制删除数量</h3>
<p>可以使用LIMIT子句限制一次删除的记录数量。</p>
<p><strong>语法</strong>： <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> 表名</span><br><span class="line"><span class="keyword">WHERE</span> 条件</span><br><span class="line">LIMIT 数量;</span><br></pre></td></tr></table></figure></p>
<p><strong>示例</strong>：删除10条年龄小于18的员工记录 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> age <span class="operator">&lt;</span> <span class="number">18</span></span><br><span class="line">LIMIT <span class="number">10</span>;</span><br></pre></td></tr></table></figure></p>
<h3 id="多表删除">多表删除</h3>
<p>MySQL支持使用DELETE语句同时从多个表中删除记录。</p>
<p><strong>语法</strong>： <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> 表<span class="number">1</span>, 表<span class="number">2</span></span><br><span class="line"><span class="keyword">FROM</span> 表<span class="number">1</span></span><br><span class="line"><span class="keyword">JOIN</span> 表<span class="number">2</span> <span class="keyword">ON</span> 表<span class="number">1.</span>列 <span class="operator">=</span> 表<span class="number">2.</span>列</span><br><span class="line"><span class="keyword">WHERE</span> 条件;</span><br></pre></td></tr></table></figure></p>
<p><strong>示例</strong>：删除员工及其相关的薪资记录 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> e, s</span><br><span class="line"><span class="keyword">FROM</span> employees e</span><br><span class="line"><span class="keyword">JOIN</span> salaries s <span class="keyword">ON</span> e.id <span class="operator">=</span> s.employee_id</span><br><span class="line"><span class="keyword">WHERE</span> e.department <span class="operator">=</span> <span class="string">&#x27;已解散部门&#x27;</span>;</span><br></pre></td></tr></table></figure></p>
<h3 id="从子查询结果中删除">从子查询结果中删除</h3>
<p>可以基于子查询的结果来删除记录。</p>
<p><strong>示例</strong>：删除没有订单记录的客户 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> customers</span><br><span class="line"><span class="keyword">WHERE</span> customer_id <span class="keyword">NOT</span> <span class="keyword">IN</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> customer_id <span class="keyword">FROM</span> orders</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<h3 id="delete与truncate的区别">DELETE与TRUNCATE的区别</h3>
<table>
<thead>
<tr class="header">
<th>特性</th>
<th>DELETE</th>
<th>TRUNCATE</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>操作类型</td>
<td>DML（数据操作语言）</td>
<td>DDL（数据定义语言）</td>
</tr>
<tr class="even">
<td>回滚</td>
<td>支持事务回滚</td>
<td>通常不支持回滚（取决于存储引擎）</td>
</tr>
<tr class="odd">
<td>速度</td>
<td>逐行删除，较慢</td>
<td>直接删除数据页，速度快</td>
</tr>
<tr class="even">
<td>自增列</td>
<td>保留自增计数器的值</td>
<td>重置自增计数器（通常重置为1）</td>
</tr>
<tr class="odd">
<td>WHERE条件</td>
<td>支持WHERE条件过滤</td>
<td>不支持WHERE条件，只能清空全表</td>
</tr>
<tr class="even">
<td>触发器</td>
<td>会触发DELETE触发器</td>
<td>不会触发触发器</td>
</tr>
<tr class="odd">
<td>权限</td>
<td>需要DELETE权限</td>
<td>需要DROP权限</td>
</tr>
<tr class="even">
<td>日志记录</td>
<td>记录每行删除操作，日志较大</td>
<td>只记录页的释放，日志较小</td>
</tr>
</tbody>
</table>
<p><strong>示例</strong>： <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 使用DELETE删除</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> department <span class="operator">=</span> <span class="string">&#x27;人事部&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 使用TRUNCATE清空整个表</span></span><br><span class="line"><span class="keyword">TRUNCATE</span> <span class="keyword">TABLE</span> temp_employees;</span><br></pre></td></tr></table></figure></p>
<h3 id="delete的重要注意事项">DELETE的重要注意事项</h3>
<ol type="1">
<li><p><strong>WHERE条件</strong>：始终添加WHERE条件，否则会删除表中的所有记录！ <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 危险操作！会删除所有员工记录</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> employees;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 正确做法：添加WHERE条件</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> termination_date <span class="operator">&lt;</span> <span class="string">&#x27;2023-01-01&#x27;</span>;</span><br></pre></td></tr></table></figure></p></li>
<li><p><strong>事务性</strong>：在重要删除操作前开启事务，以便在出错时可以回滚 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> order_items <span class="keyword">WHERE</span> order_id <span class="operator">=</span> <span class="number">1001</span>;</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> orders <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1001</span>;</span><br><span class="line"><span class="comment">-- 如果有错误，执行 ROLLBACK;</span></span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure></p></li>
<li><p><strong>性能考虑</strong>：</p>
<ul>
<li>对于大批量删除，考虑分批处理</li>
<li>对于清空整个表，使用TRUNCATE通常比DELETE更高效</li>
<li>确保WHERE条件使用的列有索引</li>
</ul></li>
<li><p><strong>级联删除</strong>：如果表定义了外键约束并设置了级联删除，删除主表记录会自动删除相关的从表记录 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 假设orders表和order_items表有级联删除关系</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> orders <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1001</span>; <span class="comment">-- 会同时删除order_items中相关记录</span></span><br></pre></td></tr></table></figure></p></li>
<li><p><strong>索引影响</strong>：删除大量数据后，考虑重建索引以提高性能</p></li>
<li><p><strong>DELETE JOIN</strong>：使用DELETE JOIN可以高效地删除关联数据</p></li>
<li><p><strong>DELETE IGNORE</strong>：使用DELETE IGNORE可以忽略删除过程中的错误 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> IGNORE <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> id <span class="operator">&gt;</span> <span class="number">2000</span>;</span><br></pre></td></tr></table></figure></p></li>
</ol>
<h2 id="事务处理基础">事务处理基础</h2>
<p>事务是数据库操作的一个逻辑单位，包含一组数据库操作命令，这些命令要么全部成功执行，要么全部不执行。事务管理是数据库系统中确保数据一致性和可靠性的核心机制。</p>
<h3 id="事务的acid特性原子性一致性隔离性持久性">事务的ACID特性（原子性、一致性、隔离性、持久性）</h3>
<p>事务具有四个关键特性，通常被称为ACID特性，这是保证数据库事务可靠性和一致性的基础：</p>
<h4 id="原子性atomicity">原子性（Atomicity）</h4>
<p>原子性确保事务中的所有操作要么全部成功执行，要么全部失败回滚，没有中间状态。</p>
<p><strong>核心含义</strong>：事务是一个不可分割的工作单位，就像原子一样不可再分。</p>
<p><strong>示例</strong>：银行转账操作 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line"><span class="keyword">UPDATE</span> accounts <span class="keyword">SET</span> balance <span class="operator">=</span> balance <span class="operator">-</span> <span class="number">1000</span> <span class="keyword">WHERE</span> account_id <span class="operator">=</span> <span class="number">123</span>;  <span class="comment">-- 转出账户扣款</span></span><br><span class="line"><span class="keyword">UPDATE</span> accounts <span class="keyword">SET</span> balance <span class="operator">=</span> balance <span class="operator">+</span> <span class="number">1000</span> <span class="keyword">WHERE</span> account_id <span class="operator">=</span> <span class="number">456</span>;  <span class="comment">-- 转入账户入账</span></span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure> 如果第一个UPDATE成功而第二个UPDATE失败，整个事务将回滚，确保账户余额的一致性。</p>
<h4 id="一致性consistency">一致性（Consistency）</h4>
<p>一致性确保事务执行前后，数据库从一个一致性状态转变为另一个一致性状态。</p>
<p><strong>核心含义</strong>：事务必须确保数据库的完整性约束不被破坏。</p>
<p><strong>示例</strong>：假设账户余额不能为负数 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line"><span class="keyword">UPDATE</span> accounts <span class="keyword">SET</span> balance <span class="operator">=</span> balance <span class="operator">-</span> <span class="number">5000</span> <span class="keyword">WHERE</span> account_id <span class="operator">=</span> <span class="number">123</span>;  <span class="comment">-- 尝试转出超过余额的金额</span></span><br><span class="line"><span class="comment">-- 如果余额不足，此操作会导致一致性破坏</span></span><br><span class="line"><span class="comment">-- 数据库约束或应用程序应检测并回滚事务</span></span><br><span class="line"><span class="keyword">ROLLBACK</span>;</span><br></pre></td></tr></table></figure></p>
<h4 id="隔离性isolation">隔离性（Isolation）</h4>
<p>隔离性确保多个并发事务之间互不干扰，一个事务的操作不会对另一个事务产生可见影响。</p>
<p><strong>核心含义</strong>：事务之间相互隔离，避免数据不一致。</p>
<p><strong>示例</strong>：两个并发更新同一账户的事务 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 事务1</span></span><br><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line"><span class="keyword">SELECT</span> balance <span class="keyword">FROM</span> accounts <span class="keyword">WHERE</span> account_id <span class="operator">=</span> <span class="number">123</span>;  <span class="comment">-- 读取余额</span></span><br><span class="line"><span class="keyword">UPDATE</span> accounts <span class="keyword">SET</span> balance <span class="operator">=</span> balance <span class="operator">-</span> <span class="number">1000</span> <span class="keyword">WHERE</span> account_id <span class="operator">=</span> <span class="number">123</span>;</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 事务2（并发执行）</span></span><br><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line"><span class="keyword">SELECT</span> balance <span class="keyword">FROM</span> accounts <span class="keyword">WHERE</span> account_id <span class="operator">=</span> <span class="number">123</span>;  <span class="comment">-- 读取余额</span></span><br><span class="line"><span class="keyword">UPDATE</span> accounts <span class="keyword">SET</span> balance <span class="operator">=</span> balance <span class="operator">+</span> <span class="number">500</span>;  <span class="comment">-- 更新余额</span></span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure> 隔离级别决定了事务2读取的是事务1修改前还是修改后的数据。</p>
<h4 id="持久性durability">持久性（Durability）</h4>
<p>持久性确保一旦事务提交，其对数据库的更改将永久保存，即使系统发生崩溃或重启。</p>
<p><strong>核心含义</strong>：事务提交后，数据更改是持久的、不可逆的。</p>
<p><strong>实现机制</strong>：通过事务日志（redo log）确保，即使数据库系统崩溃，重启后也能通过日志恢复已提交的事务。</p>
<h3 id="acid特性对比表">ACID特性对比表</h3>
<table>
<thead>
<tr class="header">
<th>特性</th>
<th>描述</th>
<th>目的</th>
<th>实现机制</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>原子性</td>
<td>事务中的所有操作要么全部成功，要么全部失败回滚</td>
<td>防止数据处于中间不一致状态</td>
<td>事务日志、回滚机制</td>
</tr>
<tr class="even">
<td>一致性</td>
<td>事务执行前后数据库从一个一致性状态变为另一个一致性状态</td>
<td>确保数据满足完整性约束</td>
<td>约束检查、触发器</td>
</tr>
<tr class="odd">
<td>隔离性</td>
<td>多个并发事务之间相互隔离，互不干扰</td>
<td>避免并发问题（脏读、不可重复读、幻读）</td>
<td>锁机制、MVCC</td>
</tr>
<tr class="even">
<td>持久性</td>
<td>事务提交后，更改永久保存</td>
<td>确保数据不会因系统故障丢失</td>
<td>事务日志、数据文件持久化</td>
</tr>
</tbody>
</table>
<h3 id="事务操作start-transactioncommit提交rollback回滚">事务操作：<code>START TRANSACTION</code>/<code>COMMIT</code>（提交）/<code>ROLLBACK</code>（回滚）</h3>
<h4 id="启动事务start-transaction">启动事务：START TRANSACTION</h4>
<p><strong>语法</strong>： <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line"><span class="comment">-- 或</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br></pre></td></tr></table></figure></p>
<p><strong>示例</strong>： <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line"><span class="comment">-- 事务中的SQL语句将在此处执行</span></span><br></pre></td></tr></table></figure></p>
<h4 id="提交事务commit">提交事务：COMMIT</h4>
<p>提交事务会使事务中的所有更改永久生效。</p>
<p><strong>语法</strong>： <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure></p>
<p><strong>示例</strong>： <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line"><span class="keyword">UPDATE</span> accounts <span class="keyword">SET</span> balance <span class="operator">=</span> balance <span class="operator">-</span> <span class="number">1000</span> <span class="keyword">WHERE</span> account_id <span class="operator">=</span> <span class="number">123</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> accounts <span class="keyword">SET</span> balance <span class="operator">=</span> balance <span class="operator">+</span> <span class="number">1000</span> <span class="keyword">WHERE</span> account_id <span class="operator">=</span> <span class="number">456</span>;</span><br><span class="line"><span class="keyword">COMMIT</span>;  <span class="comment">-- 提交事务，更改永久生效</span></span><br></pre></td></tr></table></figure></p>
<h4 id="回滚事务rollback">回滚事务：ROLLBACK</h4>
<p>回滚事务会撤销事务中的所有更改，恢复到事务开始前的状态。</p>
<p><strong>语法</strong>： <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ROLLBACK</span>;</span><br></pre></td></tr></table></figure></p>
<p><strong>示例</strong>： <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line"><span class="keyword">UPDATE</span> accounts <span class="keyword">SET</span> balance <span class="operator">=</span> balance <span class="operator">-</span> <span class="number">1000</span> <span class="keyword">WHERE</span> account_id <span class="operator">=</span> <span class="number">123</span>;</span><br><span class="line"><span class="comment">-- 发现错误或条件不满足</span></span><br><span class="line"><span class="keyword">ROLLBACK</span>;  <span class="comment">-- 回滚事务，所有更改被撤销</span></span><br></pre></td></tr></table></figure></p>
<h4 id="事务保存点savepoint">事务保存点：SAVEPOINT</h4>
<p>对于复杂事务，可以设置保存点，允许回滚到特定位置，而不是整个事务的开始。</p>
<p><strong>语法</strong>： <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SAVEPOINT</span> 保存点名称;</span><br><span class="line"><span class="keyword">ROLLBACK</span> <span class="keyword">TO</span> <span class="keyword">SAVEPOINT</span> 保存点名称;</span><br><span class="line"><span class="keyword">RELEASE</span> <span class="keyword">SAVEPOINT</span> 保存点名称;  <span class="comment">-- 删除保存点</span></span><br></pre></td></tr></table></figure></p>
<p><strong>示例</strong>： <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 操作1：更新用户状态</span></span><br><span class="line"><span class="keyword">UPDATE</span> users <span class="keyword">SET</span> status <span class="operator">=</span> <span class="string">&#x27;active&#x27;</span> <span class="keyword">WHERE</span> user_id <span class="operator">=</span> <span class="number">1001</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 设置保存点</span></span><br><span class="line"><span class="keyword">SAVEPOINT</span> update_status;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 操作2：更新用户积分</span></span><br><span class="line"><span class="keyword">UPDATE</span> user_points <span class="keyword">SET</span> points <span class="operator">=</span> points <span class="operator">+</span> <span class="number">100</span> <span class="keyword">WHERE</span> user_id <span class="operator">=</span> <span class="number">1001</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 如果积分更新出错，可以回滚到保存点</span></span><br><span class="line"><span class="keyword">ROLLBACK</span> <span class="keyword">TO</span> <span class="keyword">SAVEPOINT</span> update_status;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 此时只有积分更新被回滚，用户状态更新仍然有效</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 继续其他操作或提交事务</span></span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure></p>
<h3 id="事务类型">事务类型</h3>
<h4 id="显式事务">显式事务</h4>
<p>显式启动和结束的事务，使用START TRANSACTION和COMMIT/ROLLBACK语句。</p>
<p><strong>示例</strong>： <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line"><span class="keyword">INSERT INTO</span> orders (customer_id, order_date) <span class="keyword">VALUES</span> (<span class="number">101</span>, NOW());</span><br><span class="line"><span class="keyword">INSERT INTO</span> order_items (order_id, product_id, quantity) <span class="keyword">VALUES</span> (LAST_INSERT_ID(), <span class="number">501</span>, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure></p>
<h4 id="隐式事务">隐式事务</h4>
<p>MySQL默认开启自动提交模式，每条SQL语句自动成为一个事务并立即提交。</p>
<p><strong>控制自动提交</strong>： <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 关闭自动提交</span></span><br><span class="line"><span class="keyword">SET</span> autocommit <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">-- 执行的SQL语句不会自动提交，需要显式COMMIT</span></span><br><span class="line"><span class="keyword">INSERT INTO</span> users (name) <span class="keyword">VALUES</span> (<span class="string">&#x27;张三&#x27;</span>);</span><br><span class="line"><span class="keyword">COMMIT</span>;  <span class="comment">-- 手动提交</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 开启自动提交（默认）</span></span><br><span class="line"><span class="keyword">SET</span> autocommit <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure></p>
<h4 id="自动提交事务">自动提交事务</h4>
<p>单条SQL语句作为独立事务，自动开始和提交。</p>
<p><strong>示例</strong>： <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 默认情况下，这条语句自动作为一个事务执行并提交</span></span><br><span class="line"><span class="keyword">UPDATE</span> products <span class="keyword">SET</span> price <span class="operator">=</span> price <span class="operator">*</span> <span class="number">1.05</span> <span class="keyword">WHERE</span> category <span class="operator">=</span> <span class="string">&#x27;electronics&#x27;</span>;</span><br></pre></td></tr></table></figure></p>
<h3 id="事务处理的重要注意事项">事务处理的重要注意事项</h3>
<ol type="1">
<li><strong>事务范围控制</strong>：
<ul>
<li>事务应尽可能简短，避免长时间占用锁资源</li>
<li>不要在事务中执行耗时操作（如等待用户输入）</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 不推荐：事务包含耗时查询或处理</span></span><br><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line"><span class="comment">-- 复杂的报表查询（耗时）</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> large_table <span class="keyword">WHERE</span> complex_condition;</span><br><span class="line"><span class="comment">-- 更新操作</span></span><br><span class="line"><span class="keyword">UPDATE</span> small_table <span class="keyword">SET</span> status <span class="operator">=</span> <span class="string">&#x27;processed&#x27;</span>;</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure></li>
<li><strong>错误处理</strong>：
<ul>
<li>在应用程序中捕获SQL错误，并适当回滚事务</li>
<li>使用SAVEPOINT实现部分回滚</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line"><span class="keyword">SAVEPOINT</span> before_update;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 可能失败的操作</span></span><br><span class="line"><span class="keyword">UPDATE</span> accounts <span class="keyword">SET</span> balance <span class="operator">=</span> balance <span class="operator">-</span> <span class="number">1000</span> <span class="keyword">WHERE</span> account_id <span class="operator">=</span> <span class="number">123</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 检查是否成功</span></span><br><span class="line"><span class="comment">-- 如果失败，执行: ROLLBACK TO SAVEPOINT before_update;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure></li>
<li><strong>死锁预防</strong>：
<ul>
<li>以相同顺序访问表，避免循环等待</li>
<li>尽量减少事务持有锁的时间</li>
<li>设置合理的锁超时时间</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 推荐：按固定顺序访问表</span></span><br><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line"><span class="keyword">UPDATE</span> accounts <span class="keyword">SET</span> balance <span class="operator">=</span> balance <span class="operator">-</span> <span class="number">1000</span> <span class="keyword">WHERE</span> account_id <span class="operator">=</span> <span class="number">123</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> accounts <span class="keyword">SET</span> balance <span class="operator">=</span> balance <span class="operator">+</span> <span class="number">1000</span> <span class="keyword">WHERE</span> account_id <span class="operator">=</span> <span class="number">456</span>;</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure></li>
<li><strong>隔离级别选择</strong>：
<ul>
<li>根据业务需求选择适当的隔离级别（详见7.4.3节）</li>
<li>更高的隔离级别提供更好的数据一致性，但可能影响性能</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 设置事务隔离级别</span></span><br><span class="line"><span class="keyword">SET</span> TRANSACTION ISOLATION LEVEL READ COMMITTED;</span><br><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line"><span class="comment">-- 事务操作</span></span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure></li>
<li><strong>事务日志</strong>：
<ul>
<li>确保事务日志配置正确，以支持持久性和恢复</li>
<li>定期备份事务日志</li>
</ul></li>
<li><strong>并发控制</strong>：
<ul>
<li>了解不同存储引擎的并发控制机制（InnoDB使用MVCC）</li>
<li>合理使用索引减少锁竞争</li>
</ul></li>
<li><strong>事务监控</strong>：
<ul>
<li>监控长时间运行的事务</li>
<li>识别并解决锁等待问题</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看当前运行的事务</span></span><br><span class="line"><span class="keyword">SHOW</span> ENGINE INNODB STATUS;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看锁等待情况</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> information_schema.innodb_lock_waits;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="事务示例完整的银行转账流程">事务示例：完整的银行转账流程</h3>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 关闭自动提交，开始显式事务</span></span><br><span class="line"><span class="keyword">SET</span> autocommit <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 1. 检查余额是否充足</span></span><br><span class="line"><span class="keyword">SELECT</span> balance <span class="keyword">INTO</span> <span class="variable">@balance</span> <span class="keyword">FROM</span> accounts <span class="keyword">WHERE</span> account_id <span class="operator">=</span> <span class="number">123</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2. 如果余额不足，回滚事务（在应用程序中实现判断逻辑）</span></span><br><span class="line"><span class="comment">-- 这里假设应用程序判断余额充足后继续执行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 3. 执行扣款操作</span></span><br><span class="line"><span class="keyword">UPDATE</span> accounts <span class="keyword">SET</span> balance <span class="operator">=</span> balance <span class="operator">-</span> <span class="number">1000</span> <span class="keyword">WHERE</span> account_id <span class="operator">=</span> <span class="number">123</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 4. 执行入账操作</span></span><br><span class="line"><span class="keyword">UPDATE</span> accounts <span class="keyword">SET</span> balance <span class="operator">=</span> balance <span class="operator">+</span> <span class="number">1000</span> <span class="keyword">WHERE</span> account_id <span class="operator">=</span> <span class="number">456</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 5. 记录交易日志</span></span><br><span class="line"><span class="keyword">INSERT INTO</span> transactions (from_account, to_account, amount, transaction_date) </span><br><span class="line"><span class="keyword">VALUES</span> (<span class="number">123</span>, <span class="number">456</span>, <span class="number">1000</span>, NOW());</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 6. 提交事务</span></span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 恢复自动提交（可选）</span></span><br><span class="line"><span class="keyword">SET</span> autocommit <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>这个完整的转账示例展示了事务如何确保数据一致性，即使在复杂的业务流程中也能保证所有相关操作要么全部成功，要么全部失败。</p>
<h1 id="表操作创建修改删除">表操作（创建、修改、删除）</h1>
<h2 id="创建表create-table">创建表：CREATE TABLE</h2>
<h3 id="基本语法指定字段名数据类型约束">基本语法（指定字段名、数据类型、约束）</h3>
<h3 id="表约束保证数据完整性">表约束（保证数据完整性）</h3>
<ul>
<li>实体完整性：PRIMARY KEY（主键，唯一标识记录）</li>
<li>参照完整性：FOREIGN KEY（外键，关联其他表主键）</li>
<li>域完整性：NOT NULL（非空）、UNIQUE（唯一）、DEFAULT（默认值）</li>
</ul>
<h3 id="自增字段auto_increment主键常用">自增字段：AUTO_INCREMENT（主键常用）</h3>
<h2 id="更新表alter-table添加修改删除字段约束">更新表：ALTER TABLE（添加/修改/删除字段、约束）</h2>
<h2 id="删除表drop-table谨慎使用不可逆">删除表：DROP TABLE（谨慎使用，不可逆）</h2>
<h2 id="重命名表rename-table">重命名表：RENAME TABLE</h2>
<h2 id="索引基础性能优化入门">索引基础（性能优化入门）</h2>
<h3 id="索引的作用加速查询">索引的作用（加速查询）</h3>
<h3 id="创建索引create-indexcreate-unique-index">创建索引：<code>CREATE INDEX</code>/<code>CREATE UNIQUE INDEX</code></h3>
<h3 id="删除索引drop-index">删除索引：<code>DROP INDEX</code></h3>
<h1 id="进阶理论与技术实操深化">进阶理论与技术（实操深化）</h1>
<h2 id="数据库存储">7.1 数据库存储</h2>
<h3 id="存储策略数据文件的存储方式">7.1.1 存储策略（数据文件的存储方式）</h3>
<h3 id="常用存储引擎innodbmyisam">7.1.2 常用存储引擎（InnoDB、MyISAM）</h3>
<ul>
<li>核心区别（事务支持、索引类型、锁机制）</li>
<li>适用场景选择</li>
</ul>
<h2 id="数据库索引进阶">7.2 数据库索引进阶</h2>
<h3 id="索引原理快速查找的核心逻辑">7.2.1 索引原理（快速查找的核心逻辑）</h3>
<h3 id="索引类型b树索引哈希索引全文索引等">7.2.2 索引类型（B树索引、哈希索引、全文索引等）</h3>
<ul>
<li>B树/B+树索引（MySQL默认，适用于范围查询）</li>
<li>哈希索引（适用于等值查询，局限性说明）</li>
</ul>
<h3 id="索引管理查看索引优化索引">7.2.3 索引管理（查看索引、优化索引）</h3>
<h2 id="查询处理与优化">7.3 查询处理与优化</h2>
<h3 id="查询处理过程解析优化执行">7.3.1 查询处理过程（解析→优化→执行）</h3>
<h3 id="基础优化技巧避免select-合理建索引优化where条件">7.3.2 基础优化技巧（避免<code>SELECT *</code>、合理建索引、优化WHERE条件）</h3>
<h3 id="代数优化与物理优化简单理解改写查询语句选择最优执行计划">7.3.3 代数优化与物理优化（简单理解：改写查询语句、选择最优执行计划）</h3>
<h2 id="事务处理技术进阶">7.4 事务处理技术进阶</h2>
<h3 id="事务调度及其正确性避免脏读不可重复读幻读">7.4.1 事务调度及其正确性（避免脏读、不可重复读、幻读）</h3>
<p>事务调度是指将多个事务的操作按照一定顺序执行的过程。在并发环境下，合理的调度策略对于保证数据库一致性至关重要。</p>
<h4 id="事务调度的类型">事务调度的类型</h4>
<ol type="1">
<li><p><strong>串行调度</strong>：多个事务按照顺序依次执行，一个事务完成后另一个事务才开始。这种调度方式能确保事务的正确性，但并发性较差。</p></li>
<li><p><strong>并行调度</strong>：多个事务的操作交替执行，提高了系统吞吐量，但需要额外的机制来确保数据一致性。</p></li>
<li><p><strong>冲突可串行化调度</strong>：虽然事务操作是交替执行的，但执行结果等价于某个串行调度的结果。</p></li>
</ol>
<h4 id="调度正确性的判断">调度正确性的判断</h4>
<p>一个调度是正确的，当且仅当它是冲突可串行化的。判断调度冲突可串行化的常用方法是<strong>优先图法</strong>：</p>
<ul>
<li>为每个事务创建一个节点</li>
<li>对于两个不同事务的冲突操作（如读写冲突、写写冲突、写读冲突），从第一个操作所在的事务指向第二个操作所在的事务</li>
<li>如果优先图中不存在环，则调度是冲突可串行化的</li>
</ul>
<h4 id="并发事务中的问题">并发事务中的问题</h4>
<p>在没有适当并发控制的情况下，可能出现以下问题：</p>
<ol type="1">
<li><p><strong>脏读（Dirty Read）</strong>：读取到其他事务未提交的数据。如果该事务回滚，那么读取到的数据就是无效的。</p></li>
<li><p><strong>不可重复读（Non-repeatable Read）</strong>：同一事务中多次读取同一数据得到不同结果，因为中间被其他事务修改并提交了。</p></li>
<li><p><strong>幻读（Phantom Read）</strong>：同一事务中多次执行相同的查询，返回的结果集行数不同，因为其他事务插入或删除了符合条件的行。</p></li>
</ol>
<h4 id="调度实例分析">调度实例分析</h4>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 事务T1</span></span><br><span class="line"><span class="keyword">BEGIN</span> TRANSACTION;</span><br><span class="line"><span class="keyword">UPDATE</span> accounts <span class="keyword">SET</span> balance <span class="operator">=</span> balance <span class="operator">-</span> <span class="number">100</span> <span class="keyword">WHERE</span> account_id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">SELECT</span> balance <span class="keyword">FROM</span> accounts <span class="keyword">WHERE</span> account_id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 事务T2</span></span><br><span class="line"><span class="keyword">BEGIN</span> TRANSACTION;</span><br><span class="line"><span class="keyword">SELECT</span> balance <span class="keyword">FROM</span> accounts <span class="keyword">WHERE</span> account_id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> accounts <span class="keyword">SET</span> balance <span class="operator">=</span> balance <span class="operator">+</span> <span class="number">50</span> <span class="keyword">WHERE</span> account_id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure>
<p>不同调度顺序会产生不同的结果，只有确保冲突可串行化才能保证数据一致性。MySQL通过锁机制和MVCC（多版本并发控制）来实现正确的事务调度。</p>
<h3 id="并发控制锁机制基础行锁表锁">7.4.2 并发控制（锁机制基础：行锁、表锁）</h3>
<p>并发控制是数据库管理系统中确保多个并发事务能够正确执行而不互相干扰的机制。MySQL提供了多种并发控制方法，其中最主要的是锁机制和多版本并发控制（MVCC）。</p>
<h4 id="锁机制详解">锁机制详解</h4>
<p>锁是最基本的并发控制机制，MySQL支持多种类型的锁：</p>
<ol type="1">
<li><p><strong>按粒度分类</strong>：</p>
<ul>
<li><strong>表锁（Table Lock）</strong>：锁定整个表，开销小但并发度低。
<ul>
<li>读锁（共享锁）：多个事务可以同时读取，但不能修改。</li>
<li>写锁（排他锁）：阻塞其他所有读写操作。</li>
</ul></li>
<li><strong>行锁（Row Lock）</strong>：锁定单行数据，开销大但并发度高。
<ul>
<li>InnoDB存储引擎支持行级锁，是MySQL并发性能的关键。</li>
</ul></li>
<li><strong>页锁（Page Lock）</strong>：锁定数据页，粒度介于表锁和行锁之间。</li>
</ul></li>
<li><p><strong>按操作类型分类</strong>：</p>
<ul>
<li><strong>共享锁（Shared Lock）</strong>：<code>LOCK IN SHARE MODE</code>，允许其他事务读取但不能修改。</li>
<li><strong>排他锁（Exclusive Lock）</strong>：<code>FOR UPDATE</code>，阻止其他事务的读写操作。</li>
<li><strong>意向锁（Intention Lock）</strong>：表明事务稍后可能需要获取的锁类型。</li>
</ul></li>
</ol>
<h4 id="行锁的实现">行锁的实现</h4>
<p>InnoDB的行锁是通过在索引记录上设置锁来实现的，主要包括：</p>
<ol type="1">
<li><strong>记录锁（Record Lock）</strong>：锁定单个索引记录。</li>
<li><strong>间隙锁（Gap Lock）</strong>：锁定索引记录之间的间隙，防止插入幻行。</li>
<li><strong>临键锁（Next-Key Lock）</strong>：记录锁+间隙锁的组合，是InnoDB默认的行锁算法。</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 显式加共享锁</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">10</span> LOCK <span class="keyword">IN</span> SHARE MODE;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 显式加排他锁</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">10</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure>
<h4 id="多版本并发控制mvcc">多版本并发控制（MVCC）</h4>
<p>MVCC是一种非阻塞的并发控制方法，通过保存数据的多个版本来实现并发访问：</p>
<ol type="1">
<li><strong>工作原理</strong>：
<ul>
<li>每个事务看到的数据是事务开始时的快照版本。</li>
<li>写入操作不会阻塞读取操作，提高了并发性能。</li>
</ul></li>
<li><strong>InnoDB中的实现</strong>：
<ul>
<li>通过<code>DB_TRX_ID</code>（事务ID）和<code>DB_ROLL_PTR</code>（回滚指针）实现。</li>
<li>利用undo日志构建历史版本数据。</li>
</ul></li>
<li><strong>MVCC的优势</strong>：
<ul>
<li>读写操作可以并发执行，互不阻塞。</li>
<li>避免了读操作的锁竞争，提高了系统吞吐量。</li>
</ul></li>
</ol>
<h4 id="死锁deadlock处理">死锁（Deadlock）处理</h4>
<p>死锁是指两个或多个事务互相等待对方释放锁的状态：</p>
<ol type="1">
<li><strong>死锁检测与预防</strong>：
<ul>
<li>InnoDB会自动检测死锁，并回滚代价较小的事务。</li>
<li>预防策略：按固定顺序访问资源，设置合理的锁超时时间。</li>
</ul></li>
<li><strong>查看死锁信息</strong>： <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> ENGINE INNODB STATUS;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="锁竞争优化策略">锁竞争优化策略</h4>
<ol type="1">
<li><strong>减少锁持有时间</strong>：
<ul>
<li>事务应尽可能简短，快速提交。</li>
<li>避免在事务中执行耗时操作（如网络请求、复杂计算）。</li>
</ul></li>
<li><strong>选择合适的锁粒度</strong>：
<ul>
<li>读多写少的场景考虑使用MVCC。</li>
<li>写操作频繁时合理使用索引，减小锁范围。</li>
</ul></li>
<li><strong>使用索引优化锁</strong>：
<ul>
<li>确保WHERE条件使用索引，避免全表扫描导致的表锁。</li>
</ul></li>
</ol>
<h3 id="事务隔离级别read-uncommittedread-committedrepeatable-readserializable">7.4.3 事务隔离级别（READ UNCOMMITTED→READ COMMITTED→REPEATABLE READ→SERIALIZABLE）</h3>
<p>事务隔离级别定义了多个并发事务之间的隔离程度，MySQL提供了四种标准的隔离级别，按照隔离强度从低到高依次为：</p>
<h4 id="读未提交read-uncommitted">1. 读未提交（READ UNCOMMITTED）</h4>
<ul>
<li><strong>定义</strong>：事务可以读取其他事务未提交的数据。</li>
<li><strong>可能的问题</strong>：脏读、不可重复读、幻读。</li>
<li><strong>适用场景</strong>：极少使用，仅适用于对数据一致性要求极低的场景。</li>
<li><strong>性能</strong>：最高，但安全性最低。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 设置隔离级别</span></span><br><span class="line"><span class="keyword">SET</span> SESSION TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;</span><br></pre></td></tr></table></figure>
<h4 id="读已提交read-committed">2. 读已提交（READ COMMITTED）</h4>
<ul>
<li><strong>定义</strong>：事务只能读取其他事务已提交的数据。</li>
<li><strong>解决的问题</strong>：防止脏读。</li>
<li><strong>可能的问题</strong>：不可重复读、幻读。</li>
<li><strong>适用场景</strong>：大多数OLTP系统，如电子商务网站。</li>
<li><strong>性能</strong>：较高，是许多数据库的默认隔离级别（但不是MySQL的）。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 设置隔离级别</span></span><br><span class="line"><span class="keyword">SET</span> SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;</span><br></pre></td></tr></table></figure>
<h4 id="可重复读repeatable-read">3. 可重复读（REPEATABLE READ）</h4>
<ul>
<li><strong>定义</strong>：事务在整个过程中看到的数据保持一致。</li>
<li><strong>解决的问题</strong>：防止脏读和不可重复读。</li>
<li><strong>可能的问题</strong>：在InnoDB中使用MVCC可以有效解决幻读，但理论上仍可能出现。</li>
<li><strong>适用场景</strong>：MySQL InnoDB的默认隔离级别，适用于大多数业务场景。</li>
<li><strong>性能</strong>：良好，兼顾了一致性和并发性能。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 设置隔离级别</span></span><br><span class="line"><span class="keyword">SET</span> SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;</span><br></pre></td></tr></table></figure>
<h4 id="串行化serializable">4. 串行化（SERIALIZABLE）</h4>
<ul>
<li><strong>定义</strong>：最高级别的隔离，强制事务串行执行。</li>
<li><strong>解决的问题</strong>：防止脏读、不可重复读和幻读。</li>
<li><strong>适用场景</strong>：对数据一致性要求极高，且并发量较低的场景。</li>
<li><strong>性能</strong>：最低，但安全性最高。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 设置隔离级别</span></span><br><span class="line"><span class="keyword">SET</span> SESSION TRANSACTION ISOLATION LEVEL SERIALIZABLE;</span><br></pre></td></tr></table></figure>
<h4 id="隔离级别比较表">隔离级别比较表</h4>
<table>
<thead>
<tr class="header">
<th>隔离级别</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
<th>并发性</th>
<th>适用场景</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>READ UNCOMMITTED</td>
<td>可能</td>
<td>可能</td>
<td>可能</td>
<td>最高</td>
<td>极少使用</td>
</tr>
<tr class="even">
<td>READ COMMITTED</td>
<td>不可能</td>
<td>可能</td>
<td>可能</td>
<td>高</td>
<td>大多数OLTP系统</td>
</tr>
<tr class="odd">
<td>REPEATABLE READ</td>
<td>不可能</td>
<td>不可能</td>
<td>基本不可能</td>
<td>中</td>
<td>MySQL默认，一般业务</td>
</tr>
<tr class="even">
<td>SERIALIZABLE</td>
<td>不可能</td>
<td>不可能</td>
<td>不可能</td>
<td>低</td>
<td>严格一致性要求</td>
</tr>
</tbody>
</table>
<h4 id="innodb中的隔离级别实现">InnoDB中的隔离级别实现</h4>
<p>InnoDB通过结合锁机制和MVCC实现不同的隔离级别：</p>
<ol type="1">
<li><strong>READ UNCOMMITTED</strong>：直接读取最新数据。</li>
<li><strong>READ COMMITTED</strong>：使用MVCC，但每次读取都生成新的快照。</li>
<li><strong>REPEATABLE READ</strong>（默认）：使用MVCC，整个事务期间使用同一快照。</li>
<li><strong>SERIALIZABLE</strong>：使用锁机制，强制事务串行执行。</li>
</ol>
<h4 id="隔离级别与锁的关系">隔离级别与锁的关系</h4>
<ul>
<li>较低的隔离级别通常使用MVCC，读写不互斥，并发性能更好。</li>
<li>较高的隔离级别通常使用更强的锁机制，确保数据一致性但降低并发性能。</li>
</ul>
<h4 id="设置全局隔离级别">设置全局隔离级别</h4>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 设置全局隔离级别（需要重启会话生效）</span></span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> TRANSACTION ISOLATION LEVEL REPEATABLE READ;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看当前隔离级别</span></span><br><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@GLOBAL</span>.transaction_isolation, @<span class="variable">@SESSION</span>.transaction_isolation;</span><br></pre></td></tr></table></figure>
<p>在实际应用中，应根据业务需求和并发性能要求，选择合适的隔离级别。大多数情况下，MySQL的默认级别（REPEATABLE READ）能满足需求。</p>
<h3 id="恢复技术事务日志的作用崩溃后数据恢复">7.4.4 恢复技术（事务日志的作用：崩溃后数据恢复）</h3>
<p>数据库恢复技术是保证事务持久性的关键机制，主要通过事务日志来实现。当系统崩溃或发生故障时，MySQL可以利用日志将数据库恢复到一致的状态。</p>
<h4 id="事务日志类型">事务日志类型</h4>
<p>MySQL中主要的日志类型包括：</p>
<ol type="1">
<li><strong>重做日志（Redo Log）</strong>：
<ul>
<li><strong>作用</strong>：记录数据修改操作，确保已提交事务的持久性。</li>
<li><strong>特点</strong>：
<ul>
<li>物理日志，记录数据页的修改。</li>
<li>采用WAL（Write-Ahead Logging）策略，先写日志再写数据。</li>
<li>循环写入，有固定大小。</li>
</ul></li>
<li><strong>组成</strong>：
<ul>
<li><code>ib_logfile0</code>和<code>ib_logfile1</code>（InnoDB引擎）</li>
</ul></li>
</ul></li>
<li><strong>回滚日志（Undo Log）</strong>：
<ul>
<li><strong>作用</strong>：记录数据修改前的状态，用于事务回滚和MVCC。</li>
<li><strong>特点</strong>：
<ul>
<li>逻辑日志，记录操作的反操作。</li>
<li>存储在共享表空间或独立回滚段中。</li>
<li>事务提交后会被清理。</li>
</ul></li>
</ul></li>
<li><strong>二进制日志（Binary Log）</strong>：
<ul>
<li><strong>作用</strong>：记录所有数据修改操作，用于复制和时间点恢复。</li>
<li><strong>特点</strong>：
<ul>
<li>逻辑日志，记录SQL语句或行更改。</li>
<li>追加写入，不会覆盖。</li>
</ul></li>
<li><strong>格式</strong>：STATEMENT（语句）、ROW（行）、MIXED（混合）</li>
</ul></li>
</ol>
<h4 id="wal预写式日志策略">WAL（预写式日志）策略</h4>
<p>WAL是保证事务ACID特性的核心机制：</p>
<ol type="1">
<li><strong>工作流程</strong>：
<ul>
<li>修改数据前，先将修改操作记录到重做日志。</li>
<li>重做日志持久化后，才执行实际的数据修改。</li>
<li>事务提交时，确保日志刷盘。</li>
</ul></li>
<li><strong>优势</strong>：
<ul>
<li>减少磁盘随机写入，提高性能。</li>
<li>确保即使系统崩溃，也能恢复已提交的事务。</li>
</ul></li>
</ol>
<h4 id="恢复机制详解">恢复机制详解</h4>
<p>数据库恢复主要基于两个原则：</p>
<ol type="1">
<li><strong>向前滚（Redo）</strong>：
<ul>
<li><strong>目的</strong>：重做所有已提交但尚未写入数据文件的事务。</li>
<li><strong>过程</strong>：
<ul>
<li>扫描重做日志，找出所有已提交但未持久化的事务。</li>
<li>重新执行这些事务的修改操作。</li>
</ul></li>
</ul></li>
<li><strong>向后滚（Undo）</strong>：
<ul>
<li><strong>目的</strong>：撤销所有未提交的事务，恢复到事务开始前的状态。</li>
<li><strong>过程</strong>：
<ul>
<li>查找未提交的事务。</li>
<li>使用回滚日志执行相反的操作。</li>
</ul></li>
</ul></li>
</ol>
<h4 id="崩溃恢复过程">崩溃恢复过程</h4>
<p>当MySQL实例意外崩溃并重启时，InnoDB引擎会自动执行恢复过程：</p>
<ol type="1">
<li><strong>分析阶段（Analysis）</strong>：
<ul>
<li>扫描重做日志，构建完整的事务列表。</li>
<li>确定哪些事务需要重做，哪些需要回滚。</li>
</ul></li>
<li><strong>重做阶段（Redo）</strong>：
<ul>
<li>执行所有已提交事务的重做操作。</li>
<li>将数据恢复到崩溃前的一致状态。</li>
</ul></li>
<li><strong>回滚阶段（Undo）</strong>：
<ul>
<li>回滚所有未提交的事务。</li>
<li>释放相关资源和锁。</li>
</ul></li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看InnoDB日志配置</span></span><br><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;innodb_log%&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看二进制日志配置</span></span><br><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;log_bin%&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看当前二进制日志文件</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="type">BINARY</span> LOGS;</span><br></pre></td></tr></table></figure>
<h4 id="时间点恢复point-in-time-recovery">时间点恢复（Point-in-Time Recovery）</h4>
<p>利用二进制日志可以实现更精细的恢复：</p>
<ol type="1">
<li><strong>基本原理</strong>：
<ul>
<li>从完整备份恢复到某个时间点。</li>
<li>然后应用备份后到目标时间点的二进制日志。</li>
</ul></li>
<li><strong>恢复步骤</strong>：
<ul>
<li>恢复最近的完整备份。</li>
<li>使用<code>mysqlbinlog</code>工具解析二进制日志。</li>
<li>应用特定时间段的日志。</li>
</ul></li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 示例：从二进制日志恢复到特定时间点</span></span><br><span class="line"><span class="comment">-- 1. 先恢复完整备份</span></span><br><span class="line"><span class="comment">-- 2. 应用二进制日志</span></span><br><span class="line">mysqlbinlog <span class="comment">--start-datetime=&#x27;2024-01-01 10:00:00&#x27; --stop-datetime=&#x27;2024-01-01 11:00:00&#x27; /var/lib/mysql/mysql-bin.000001 | mysql -u root -p</span></span><br></pre></td></tr></table></figure>
<h4 id="日志管理最佳实践">日志管理最佳实践</h4>
<ol type="1">
<li><strong>重做日志配置</strong>：
<ul>
<li>设置合理的日志文件大小（建议512MB-2GB）。</li>
<li>适当增加日志文件数量，提高并发性能。</li>
</ul></li>
<li><strong>二进制日志管理</strong>：
<ul>
<li>启用自动清理，避免磁盘空间耗尽。</li>
<li>定期备份二进制日志。</li>
</ul></li>
<li><strong>监控与维护</strong>：
<ul>
<li>监控日志文件大小和增长速度。</li>
<li>定期检查日志写入性能。</li>
</ul></li>
</ol>
<p>通过合理配置和管理事务日志，可以有效保障数据库的安全性和可靠性，确保在系统故障时能够快速恢复数据。</p>
<h3 id="事务优化与最佳实践">7.4.5 事务优化与最佳实践</h3>
<p>在实际应用中，事务的使用需要平衡数据一致性和性能。以下是事务优化的关键策略和最佳实践：</p>
<h4 id="事务设计原则">事务设计原则</h4>
<ol type="1">
<li><strong>保持事务简短</strong>：
<ul>
<li>事务应尽可能小，减少锁定资源的时间。</li>
<li>避免在事务中执行非数据库操作（如文件IO、网络请求）。</li>
</ul></li>
<li><strong>批量处理策略</strong>：
<ul>
<li>对于大量数据操作，考虑分批处理，避免长时间占用事务资源。</li>
<li>使用<code>INSERT DELAYED</code>或<code>LOAD DATA INFILE</code>等高性能导入方式。</li>
</ul></li>
<li><strong>合理组织操作顺序</strong>：
<ul>
<li>先执行查询操作，再执行修改操作。</li>
<li>先锁定资源需求较少的表，再锁定资源需求较多的表。</li>
</ul></li>
</ol>
<h4 id="性能优化技巧">性能优化技巧</h4>
<ol type="1">
<li><strong>索引优化</strong>：
<ul>
<li>确保事务中的查询条件都有适当的索引。</li>
<li>避免在事务中执行全表扫描，这会导致表锁。</li>
</ul></li>
<li><strong>锁定策略优化</strong>：
<ul>
<li>最小化锁定范围，只锁定必要的数据。</li>
<li>合理利用行锁，避免升级为表锁。</li>
<li>使用<code>SELECT ... FOR UPDATE</code>时明确指定条件，避免锁定过多行。</li>
</ul></li>
<li><strong>隔离级别选择</strong>：
<ul>
<li>根据业务需求选择合适的隔离级别，避免过度隔离。</li>
<li>读多写少场景可考虑使用<code>READ COMMITTED</code>提高并发性能。</li>
</ul></li>
<li><strong>事务提交时机</strong>：
<ul>
<li>及时提交成功的事务，释放资源。</li>
<li>设置合理的事务超时时间，避免长时间运行的事务。</li>
</ul></li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 设置事务超时时间（单位：秒）</span></span><br><span class="line"><span class="keyword">SET</span> SESSION innodb_lock_wait_timeout <span class="operator">=</span> <span class="number">50</span>;</span><br></pre></td></tr></table></figure>
<h4 id="常见问题及解决方案">常见问题及解决方案</h4>
<ol type="1">
<li><strong>死锁问题</strong>：
<ul>
<li><strong>症状</strong>：事务执行过程中出现<code>Deadlock found when trying to get lock</code>错误。</li>
<li><strong>解决方法</strong>：
<ul>
<li>按固定顺序访问表和资源。</li>
<li>减少事务持有锁的时间。</li>
<li>使用<code>SHOW ENGINE INNODB STATUS</code>分析死锁原因。</li>
</ul></li>
</ul></li>
<li><strong>长时间运行的事务</strong>：
<ul>
<li><strong>症状</strong>：占用资源时间过长，导致其他事务等待。</li>
<li><strong>解决方法</strong>：
<ul>
<li>分解大事务为多个小事务。</li>
<li>优化事务中的查询语句。</li>
<li>监控并终止异常的长时间运行事务。</li>
</ul></li>
</ul></li>
<li><strong>锁等待超时</strong>：
<ul>
<li><strong>症状</strong>：事务因等待锁超时失败。</li>
<li><strong>解决方法</strong>：
<ul>
<li>增加锁等待超时时间。</li>
<li>优化事务以减少锁竞争。</li>
<li>使用乐观锁替代悲观锁。</li>
</ul></li>
</ul></li>
</ol>
<h4 id="监控与诊断">监控与诊断</h4>
<ol type="1">
<li><strong>关键监控指标</strong>：
<ul>
<li>活跃事务数量</li>
<li>锁等待时间和次数</li>
<li>事务响应时间</li>
<li>死锁发生频率</li>
</ul></li>
<li><strong>诊断命令</strong>： <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看当前活跃事务</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> information_schema.innodb_trx;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看锁等待情况</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> information_schema.innodb_lock_waits;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看锁信息</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> information_schema.innodb_locks;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看InnoDB状态（包含死锁信息）</span></span><br><span class="line"><span class="keyword">SHOW</span> ENGINE INNODB STATUS;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="最佳实践示例">最佳实践示例</h4>
<ol type="1">
<li><p><strong>批量更新优化</strong>： <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 不推荐：单个大事务更新大量数据</span></span><br><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line"><span class="keyword">UPDATE</span> large_table <span class="keyword">SET</span> status <span class="operator">=</span> <span class="number">1</span> <span class="keyword">WHERE</span> created_at <span class="operator">&lt;</span> <span class="string">&#x27;2024-01-01&#x27;</span>; <span class="comment">-- 假设有百万行</span></span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 推荐：分批更新，控制事务大小</span></span><br><span class="line"><span class="keyword">SET</span> <span class="variable">@batch_size</span> <span class="operator">=</span> <span class="number">10000</span>;</span><br><span class="line"><span class="keyword">SET</span> <span class="variable">@last_id</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">WHILE <span class="variable">@batch_size</span> <span class="operator">=</span> <span class="number">10000</span> DO</span><br><span class="line">  <span class="keyword">START</span> TRANSACTION;</span><br><span class="line">  <span class="keyword">UPDATE</span> large_table <span class="keyword">SET</span> status <span class="operator">=</span> <span class="number">1</span> </span><br><span class="line">  <span class="keyword">WHERE</span> created_at <span class="operator">&lt;</span> <span class="string">&#x27;2024-01-01&#x27;</span> <span class="keyword">AND</span> id <span class="operator">&gt;</span> <span class="variable">@last_id</span> </span><br><span class="line">  <span class="keyword">ORDER</span> <span class="keyword">BY</span> id LIMIT <span class="variable">@batch_size</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">SET</span> <span class="variable">@batch_size</span> <span class="operator">=</span> ROW_COUNT();</span><br><span class="line">  <span class="keyword">SET</span> <span class="variable">@last_id</span> <span class="operator">=</span> LAST_INSERT_ID();</span><br><span class="line">  <span class="keyword">COMMIT</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">-- 可选：每批处理后短暂暂停，减轻系统压力</span></span><br><span class="line">  DO SLEEP(<span class="number">0.1</span>);</span><br><span class="line"><span class="keyword">END</span> WHILE;</span><br></pre></td></tr></table></figure></p></li>
<li><p><strong>合理使用事务隔离级别</strong>： <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 报表查询场景，可使用READ UNCOMMITTED提高性能</span></span><br><span class="line"><span class="keyword">SET</span> SESSION TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> orders <span class="keyword">WHERE</span> status <span class="operator">=</span> <span class="string">&#x27;completed&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 金融交易场景，使用SERIALIZABLE保证一致性</span></span><br><span class="line"><span class="keyword">SET</span> SESSION TRANSACTION ISOLATION LEVEL SERIALIZABLE;</span><br><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line"><span class="comment">-- 交易操作...</span></span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure></p></li>
</ol>
<p>通过遵循这些最佳实践，可以在保证数据一致性的同时，显著提高MySQL数据库的事务处理性能和并发能力。</p>
<h2 id="数据库完整性进阶">7.5 数据库完整性进阶</h2>
<ul>
<li>实体完整性（主键约束强化）</li>
<li>参照完整性（外键约束的级联操作：ON DELETE/UPDATE）</li>
<li>其他完整性约束（CHECK约束、自定义约束）</li>
</ul>
<h1 id="高级数据库特性">8. 高级数据库特性</h1>
<h2 id="视图">8.1 视图</h2>
<h3 id="创建视图create-view简化复杂查询">8.1.1 创建视图：<code>CREATE VIEW</code>（简化复杂查询）</h3>
<h3 id="使用与修改视图select-from-视图alter-view">8.1.2 使用与修改视图（<code>SELECT * FROM 视图</code>/<code>ALTER VIEW</code>）</h3>
<h3 id="视图的优缺点">8.1.3 视图的优缺点</h3>
<h2 id="存储过程">8.2 存储过程</h2>
<h3 id="创建存储过程create-procedure封装复杂逻辑">8.2.1 创建存储过程：<code>CREATE PROCEDURE</code>（封装复杂逻辑）</h3>
<h3 id="调用存储过程call-存储过程名">8.2.2 调用存储过程：<code>CALL 存储过程名()</code></h3>
<h3 id="存储过程的参数inoutinout">8.2.3 存储过程的参数（IN/OUT/INOUT）</h3>
<h2 id="游标遍历查询结果集">8.3 游标（遍历查询结果集）</h2>
<h2 id="触发器">8.4 触发器</h2>
<h3 id="创建触发器create-trigger自动执行逻辑">8.4.1 创建触发器：<code>CREATE TRIGGER</code>（自动执行逻辑）</h3>
<h3 id="触发时机beforeafter与触发类型insertupdatedelete">8.4.2 触发时机（BEFORE/AFTER）与触发类型（INSERT/UPDATE/DELETE）</h3>
<h1 id="数据库管理与维护">9. 数据库管理与维护</h1>
<h2 id="访问控制与用户管理">9.1 访问控制与用户管理</h2>
<h3 id="创建用户create-user">9.1.1 创建用户：<code>CREATE USER</code></h3>
<h3 id="授权grant-权限-on-数据库.表-to-用户">9.1.2 授权：<code>GRANT 权限 ON 数据库.表 TO 用户</code></h3>
<h3 id="撤销权限revoke-权限-on-数据库.表-from-用户">9.1.3 撤销权限：<code>REVOKE 权限 ON 数据库.表 FROM 用户</code></h3>
<h3 id="删除用户drop-user">9.1.4 删除用户：<code>DROP USER</code></h3>
<h2 id="数据备份">9.2 数据备份</h2>
<h3 id="逻辑备份mysqldump命令">9.2.1 逻辑备份（<code>mysqldump</code>命令）</h3>
<h3 id="恢复数据source命令mysql--u用户名--p-数据库-备份文件">9.2.2 恢复数据（<code>SOURCE</code>命令/<code>mysql -u用户名 -p 数据库 &lt; 备份文件</code>）</h3>
<h2 id="数据库维护">9.3 数据库维护</h2>
<ul>
<li>优化表：<code>OPTIMIZE TABLE</code></li>
<li>检查表：<code>CHECK TABLE</code></li>
</ul>
<h2 id="问题诊断与日志">9.4 问题诊断与日志</h2>
<h3 id="诊断启动问题配置文件检查端口占用排查">9.4.1 诊断启动问题（配置文件检查、端口占用排查）</h3>
<h3 id="查看日志文件错误日志查询日志慢查询日志">9.4.2 查看日志文件（错误日志、查询日志、慢查询日志）</h3>
<h2 id="性能改善">9.5 性能改善</h2>
<ul>
<li>慢查询优化（分析慢查询日志）</li>
<li>索引优化（避免无效索引、覆盖索引使用）</li>
<li>配置参数调整（基础参数：连接数、缓存大小）</li>
</ul>
<h1 id="深入理论拓展可选进阶学习者">10. 深入理论拓展（可选，进阶学习者）</h1>
<h2 id="阿姆斯特朗公理体系函数依赖的推理规则">10.1 阿姆斯特朗公理体系（函数依赖的推理规则）</h2>
<h2 id="模式分解无损连接分解保持函数依赖分解">10.2 模式分解（无损连接分解、保持函数依赖分解）</h2>
<h2 id="多值依赖与第四范式4nf">10.3 多值依赖与第四范式（4NF）</h2>
<h2 id="其他高级范式bcnf等">10.4 其他高级范式（BCNF等）</h2>

    </div>

    
    
    

      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/DataBase/" rel="tag"><i class="fa fa-tag"></i> DataBase</a>
              <a href="/tags/MySQL/" rel="tag"><i class="fa fa-tag"></i> MySQL</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2025/10/29/top/" rel="prev" title="现在开始，还来得及">
      <i class="fa fa-chevron-left"></i> 现在开始，还来得及
    </a></div>
      <div class="post-nav-item">
    <a href="/2025/12/04/C_C++%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/" rel="next" title="C/C++环境配置（更新ing）">
      C/C++环境配置（更新ing） <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AD%A6%E4%B9%A0%E9%A1%BB%E7%9F%A5warning"><span class="nav-number">1.</span> <span class="nav-text">学习须知（Warning）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA"><span class="nav-number">2.</span> <span class="nav-text">数据库基础理论</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E6%A0%B8%E5%BF%83"><span class="nav-number">2.1.</span> <span class="nav-text">数据库设计核心</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#e-r%E6%A8%A1%E5%9E%8B%E5%AE%9E%E4%BD%93-%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%9E%8B"><span class="nav-number">2.1.1.</span> <span class="nav-text">E-R模型（实体-关系模型）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-number">2.1.1.1.</span> <span class="nav-text">基本概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#e-r%E5%9B%BE"><span class="nav-number">2.1.1.2.</span> <span class="nav-text">E-R图</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A7%84%E8%8C%83%E5%8C%96%E5%85%A5%E9%97%A8"><span class="nav-number">2.1.2.</span> <span class="nav-text">关系数据库规范化入门</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E8%A7%84%E8%8C%83%E5%8C%96"><span class="nav-number">2.1.2.1.</span> <span class="nav-text">为什么需要规范化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E4%BE%9D%E8%B5%96%E5%9F%BA%E7%A1%80"><span class="nav-number">2.1.2.2.</span> <span class="nav-text">函数依赖基础</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%B8%E5%BF%83%E8%8C%83%E5%BC%8F"><span class="nav-number">2.1.2.3.</span> <span class="nav-text">核心范式</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E8%8C%83%E5%BC%8F1nf"><span class="nav-number">2.1.2.3.1.</span> <span class="nav-text">第一范式（1NF）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%AC%AC%E4%BA%8C%E8%8C%83%E5%BC%8F2nf"><span class="nav-number">2.1.2.3.2.</span> <span class="nav-text">第二范式（2NF）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%AC%AC%E4%B8%89%E8%8C%83%E5%BC%8F3nf"><span class="nav-number">2.1.2.3.3.</span> <span class="nav-text">第三范式（3NF）</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%84%E8%8C%83%E5%8C%96%E4%B8%8E%E5%8F%8D%E8%A7%84%E8%8C%83%E5%8C%96"><span class="nav-number">2.1.2.4.</span> <span class="nav-text">规范化与反规范化</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%A0%B8%E5%BF%83%E6%9C%AF%E8%AF%AD%E8%A7%A3%E6%9E%90"><span class="nav-number">3.</span> <span class="nav-text">核心术语解析</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C"><span class="nav-number">4.</span> <span class="nav-text">数据库基础操作</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2select%E8%AF%AD%E5%8F%A5"><span class="nav-number">5.</span> <span class="nav-text">数据查询：SELECT语句</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#select-%E5%9F%BA%E6%9C%AC%E6%A0%BC%E5%BC%8F"><span class="nav-number">5.1.</span> <span class="nav-text">SELECT 基本格式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#distinct-%E5%85%B3%E9%94%AE%E5%AD%97%E7%BB%93%E6%9E%9C%E5%8E%BB%E9%87%8D"><span class="nav-number">5.2.</span> <span class="nav-text">DISTINCT 关键字（结果去重）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#limit%E5%85%B3%E9%94%AE%E5%AD%97%E5%88%86%E9%A1%B5%E5%9F%BA%E7%A1%80%E9%99%90%E5%88%B6%E7%BB%93%E6%9E%9C%E8%A1%8C%E6%95%B0"><span class="nav-number">5.3.</span> <span class="nav-text">LIMIT关键字（分页基础）（限制结果行数）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#order-by%E5%AD%90%E5%8F%A5%E7%BB%93%E6%9E%9C%E6%8E%92%E5%BA%8F%E5%8D%87%E5%BA%8Fasc%E9%99%8D%E5%BA%8Fdesc"><span class="nav-number">5.4.</span> <span class="nav-text">ORDER BY子句（结果排序）（升序ASC&#x2F;降序DESC）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#where%E5%AD%90%E5%8F%A5%E6%95%B0%E6%8D%AE%E7%AD%9B%E9%80%89"><span class="nav-number">5.5.</span> <span class="nav-text">WHERE子句（数据筛选）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="nav-number">5.5.1.</span> <span class="nav-text">基础操作符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A9%BA%E5%80%BC%E6%A3%80%E6%9F%A5is-nullis-not-null"><span class="nav-number">5.5.2.</span> <span class="nav-text">空值检查：IS NULL&#x2F;IS NOT NULL</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%BB%E8%BE%91%E6%93%8D%E4%BD%9C%E7%AC%A6andorinnot"><span class="nav-number">5.5.3.</span> <span class="nav-text">逻辑操作符（AND&#x2F;OR&#x2F;IN&#x2F;NOT）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#and-%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="nav-number">5.5.3.1.</span> <span class="nav-text">AND 操作符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#or-%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="nav-number">5.5.3.2.</span> <span class="nav-text">OR 操作符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#and-%E4%B8%8E-or-%E7%9A%84%E8%BF%90%E8%A1%8C%E9%A1%BA%E5%BA%8F"><span class="nav-number">5.5.3.3.</span> <span class="nav-text">AND 与 OR 的运行顺序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#in-%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="nav-number">5.5.3.4.</span> <span class="nav-text">IN 操作符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#not-%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="nav-number">5.5.3.5.</span> <span class="nav-text">NOT 操作符</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#like%E4%B8%8E%E9%80%9A%E9%85%8D%E7%AC%A6_%E6%A8%A1%E7%B3%8A%E6%9F%A5%E8%AF%A2"><span class="nav-number">5.5.4.</span> <span class="nav-text">LIKE与通配符（%\\_）(模糊查询)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#like-%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="nav-number">5.5.4.1.</span> <span class="nav-text">LIKE 操作符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%99%BE%E5%88%86%E5%8F%B7%E9%80%9A%E9%85%8D%E7%AC%A6"><span class="nav-number">5.5.4.2.</span> <span class="nav-text">百分号（%）通配符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%8B%E5%88%92%E7%BA%BF_%E9%80%9A%E9%85%8D%E7%AC%A6"><span class="nav-number">5.5.4.3.</span> <span class="nav-text">下划线（_）通配符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BD%AC%E4%B9%89%E9%80%9A%E9%85%8D%E7%AC%A6"><span class="nav-number">5.5.4.4.</span> <span class="nav-text">转义通配符</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#regexp%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%A4%8D%E6%9D%82%E5%8C%B9%E9%85%8D"><span class="nav-number">5.5.5.</span> <span class="nav-text">REGEXP（正则表达式）(复杂匹配)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-.-%E5%8C%B9%E9%85%8D%E5%8D%95%E4%B8%AA%E4%BB%BB%E6%84%8F%E5%AD%97%E7%AC%A6"><span class="nav-number">5.5.5.1.</span> <span class="nav-text">使用 . 匹配单个任意字符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-%E5%8C%B9%E9%85%8D%E5%A4%9A%E4%B8%AA%E6%A8%A1%E5%BC%8F%E9%80%BB%E8%BE%91%E6%88%96"><span class="nav-number">5.5.5.2.</span> <span class="nav-text">使用 | 匹配多个模式（逻辑“或”）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-%E5%8C%B9%E9%85%8D%E6%8C%87%E5%AE%9A%E5%AD%97%E7%AC%A6%E9%9B%86%E4%B8%AD%E7%9A%84%E4%BB%BB%E6%84%8F%E4%B8%80%E4%B8%AA"><span class="nav-number">5.5.5.3.</span> <span class="nav-text">使用 [] 匹配指定字符集中的任意一个</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8---%E5%9C%A8-%E5%86%85%E5%AE%9A%E4%B9%89%E5%AD%97%E7%AC%A6%E8%8C%83%E5%9B%B4"><span class="nav-number">5.5.5.4.</span> <span class="nav-text">使用 - 在 [] 内定义字符范围</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-%E5%8C%B9%E9%85%8D%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6%E8%BD%AC%E4%B9%89"><span class="nav-number">5.5.5.5.</span> <span class="nav-text">使用 \\ 匹配特殊字符（转义）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8C%B9%E9%85%8D%E5%AD%97%E7%AC%A6%E7%B1%BB%E9%A2%84%E8%AE%BE%E5%B8%B8%E7%94%A8%E5%AD%97%E7%AC%A6%E9%9B%86"><span class="nav-number">5.5.5.6.</span> <span class="nav-text">匹配字符类（预设常用字符集）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E9%87%8D%E5%A4%8D%E5%85%83%E5%AD%97%E7%AC%A6%E5%8C%B9%E9%85%8D%E5%A4%9A%E4%B8%AA%E5%AD%97%E7%AC%A6"><span class="nav-number">5.5.5.7.</span> <span class="nav-text">使用重复元字符匹配多个字符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%AE%9A%E4%BD%8D%E7%AC%A6%E5%8C%B9%E9%85%8D%E4%BD%8D%E7%BD%AE"><span class="nav-number">5.5.5.8.</span> <span class="nav-text">使用定位符匹配位置</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%9A%84%E5%8F%8C%E9%87%8D%E7%94%A8%E9%80%94"><span class="nav-number">5.5.5.9.</span> <span class="nav-text">^ 的双重用途</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E8%AE%A1%E7%AE%97%E5%AD%97%E6%AE%B5"><span class="nav-number">5.6.</span> <span class="nav-text">创建计算字段</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#concat%E5%87%BD%E6%95%B0%E6%8B%BC%E6%8E%A5%E5%AD%97%E6%AE%B5"><span class="nav-number">5.6.1.</span> <span class="nav-text">CONCAT()函数（拼接字段）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%AD%E6%B3%95%E6%A0%BC%E5%BC%8F"><span class="nav-number">5.6.1.1.</span> <span class="nav-text">语法格式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E6%93%8D%E7%A4%BA%E4%BE%8B%E5%9F%BA%E4%BA%8E-employees-%E8%A1%A8"><span class="nav-number">5.6.1.2.</span> <span class="nav-text">实操示例（基于 employees 表）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-1%E6%8B%BC%E6%8E%A5-%E5%A7%93%E5%90%8D-%E9%83%A8%E9%97%A8%E5%AD%97%E6%AE%B5-%E5%9B%BA%E5%AE%9A%E6%96%87%E6%9C%AC-%E5%AD%97%E6%AE%B5"><span class="nav-number">5.6.1.2.1.</span> <span class="nav-text">示例 1：拼接 “姓名 + 部门”（字段 + 固定文本 + 字段）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-2%E6%8B%BC%E6%8E%A5-%E5%A7%93%E5%90%8D-%E9%82%AE%E7%AE%B1%E5%90%8E%E7%BC%80%E5%AD%97%E6%AE%B5-%E5%9B%BA%E5%AE%9A%E6%96%87%E6%9C%AC"><span class="nav-number">5.6.1.2.2.</span> <span class="nav-text">示例 2：拼接 “姓名 + 邮箱后缀”（字段 + 固定文本）</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A1%A5%E5%85%85concat_ws-%E9%81%BF%E5%85%8D-null-%E9%97%AE%E9%A2%98"><span class="nav-number">5.6.1.3.</span> <span class="nav-text">补充：CONCAT_WS() 避免 NULL 问题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ltrim-rtrim-trim%E5%87%BD%E6%95%B0%E5%8E%BB%E9%99%A4%E7%A9%BA%E6%A0%BC"><span class="nav-number">5.6.2.</span> <span class="nav-text">LTRIM()&#x2F; RTRIM()&#x2F; TRIM()函数（去除空格）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%AD%E6%B3%95%E6%A0%BC%E5%BC%8F-1"><span class="nav-number">5.6.2.1.</span> <span class="nav-text">语法格式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E6%93%8D%E7%A4%BA%E4%BE%8B%E5%9F%BA%E4%BA%8E-employees-%E8%A1%A8-1"><span class="nav-number">5.6.2.2.</span> <span class="nav-text">实操示例（基于 employees 表）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">5.6.2.3.</span> <span class="nav-text">实际应用场景</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#as-%E5%85%B3%E9%94%AE%E5%AD%97%E5%AD%97%E6%AE%B5%E5%88%AB%E5%90%8D"><span class="nav-number">5.6.3.</span> <span class="nav-text">AS 关键字（字段别名）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%AD%E6%B3%95%E6%A0%BC%E5%BC%8F-2"><span class="nav-number">5.6.3.1.</span> <span class="nav-text">语法格式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E6%93%8D%E7%A4%BA%E4%BE%8B%E5%9F%BA%E4%BA%8E-employees-%E8%A1%A8-2"><span class="nav-number">5.6.3.2.</span> <span class="nav-text">实操示例（基于 employees 表）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E6%93%8D%E7%A4%BA%E4%BE%8B%E5%88%AB%E5%90%8D%E5%90%AB%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6%E7%94%A8%E5%BC%95%E5%8F%B7%E5%8C%85%E8%A3%B9"><span class="nav-number">5.6.3.3.</span> <span class="nav-text">实操示例：别名含特殊字符（用引号包裹）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%97%E6%9C%AF%E8%AE%A1%E7%AE%97%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E5%8F%96%E6%A8%A1"><span class="nav-number">5.6.4.</span> <span class="nav-text">算术计算（加减乘除、取模%）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%94%AF%E6%8C%81%E7%9A%84%E8%BF%90%E7%AE%97%E7%B1%BB%E5%9E%8B"><span class="nav-number">5.6.4.1.</span> <span class="nav-text">支持的运算类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E6%93%8D%E7%A4%BA%E4%BE%8B%E5%9F%BA%E4%BA%8E-employees-%E8%A1%A8-3"><span class="nav-number">5.6.4.2.</span> <span class="nav-text">实操示例（基于 employees 表）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-1%E8%AE%A1%E7%AE%97%E5%B9%B4%E8%96%AA%E4%B9%98%E6%B3%95"><span class="nav-number">5.6.4.2.1.</span> <span class="nav-text">示例 1：计算年薪（乘法）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-2%E8%AE%A1%E7%AE%97%E8%96%AA%E8%B5%84%E5%B7%AE%E5%80%BC%E5%87%8F%E6%B3%95"><span class="nav-number">5.6.4.2.2.</span> <span class="nav-text">示例 2：计算薪资差值（减法）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-3%E5%8F%96%E6%A8%A1%E5%88%A4%E6%96%AD%E5%A5%87%E5%81%B6"><span class="nav-number">5.6.4.2.3.</span> <span class="nav-text">示例 3：取模判断奇偶（%）</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-number">5.6.4.3.</span> <span class="nav-text">注意事项</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0"><span class="nav-number">5.7.</span> <span class="nav-text">数据处理函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E6%9C%AC%E5%87%BD%E6%95%B0upperlowerlength%E7%AD%89"><span class="nav-number">5.7.1.</span> <span class="nav-text">文本函数（UPPER()&#x2F;LOWER()&#x2F;LENGTH()等）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E6%96%87%E6%9C%AC%E5%87%BD%E6%95%B0%E8%A1%A8"><span class="nav-number">5.7.1.1.</span> <span class="nav-text">常用文本函数表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%AD%E6%B3%95%E6%A0%BC%E5%BC%8F%E4%B8%8E%E7%A4%BA%E4%BE%8B"><span class="nav-number">5.7.1.2.</span> <span class="nav-text">语法格式与示例</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#upperlower---%E5%A4%A7%E5%B0%8F%E5%86%99%E8%BD%AC%E6%8D%A2"><span class="nav-number">5.7.1.2.1.</span> <span class="nav-text">1. UPPER()&#x2F;LOWER() - 大小写转换</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#lengthchar_length---%E9%95%BF%E5%BA%A6%E8%AE%A1%E7%AE%97"><span class="nav-number">5.7.1.2.2.</span> <span class="nav-text">2. LENGTH()&#x2F;CHAR_LENGTH() - 长度计算</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#substring---%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%88%AA%E5%8F%96"><span class="nav-number">5.7.1.2.3.</span> <span class="nav-text">3. SUBSTRING() - 字符串截取</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#replace---%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9B%BF%E6%8D%A2"><span class="nav-number">5.7.1.2.4.</span> <span class="nav-text">4. REPLACE() - 字符串替换</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#instr---%E6%9F%A5%E6%89%BE%E5%AD%90%E4%B8%B2%E4%BD%8D%E7%BD%AE"><span class="nav-number">5.7.1.2.5.</span> <span class="nav-text">5. INSTR() - 查找子串位置</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E5%80%BC%E5%87%BD%E6%95%B0roundabsfloor%E7%AD%89"><span class="nav-number">5.7.2.</span> <span class="nav-text">数值函数（ROUND()&#x2F;ABS()&#x2F;FLOOR()等）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E6%95%B0%E5%80%BC%E5%87%BD%E6%95%B0%E8%A1%A8"><span class="nav-number">5.7.2.1.</span> <span class="nav-text">常用数值函数表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%AD%E6%B3%95%E6%A0%BC%E5%BC%8F%E4%B8%8E%E7%A4%BA%E4%BE%8B-1"><span class="nav-number">5.7.2.2.</span> <span class="nav-text">语法格式与示例</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#round---%E5%9B%9B%E8%88%8D%E4%BA%94%E5%85%A5"><span class="nav-number">5.7.2.2.1.</span> <span class="nav-text">1. ROUND() - 四舍五入</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#floorceil---%E5%8F%96%E6%95%B4"><span class="nav-number">5.7.2.2.2.</span> <span class="nav-text">2. FLOOR()&#x2F;CEIL() - 取整</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#abs---%E7%BB%9D%E5%AF%B9%E5%80%BC"><span class="nav-number">5.7.2.2.3.</span> <span class="nav-text">3. ABS() - 绝对值</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#rand---%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%94%9F%E6%88%90"><span class="nav-number">5.7.2.2.4.</span> <span class="nav-text">4. RAND() - 随机数生成</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4%E5%87%BD%E6%95%B0nowdate_formatdatediff%E7%AD%89"><span class="nav-number">5.7.3.</span> <span class="nav-text">日期时间函数（NOW()&#x2F;DATE_FORMAT()&#x2F;DATEDIFF()等）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4%E5%87%BD%E6%95%B0%E8%A1%A8"><span class="nav-number">5.7.3.1.</span> <span class="nav-text">常用日期时间函数表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4%E6%A0%BC%E5%BC%8F%E5%8C%96%E7%AC%A6%E5%8F%B7"><span class="nav-number">5.7.3.2.</span> <span class="nav-text">常用日期时间格式化符号</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%AD%E6%B3%95%E6%A0%BC%E5%BC%8F%E4%B8%8E%E7%A4%BA%E4%BE%8B-2"><span class="nav-number">5.7.3.3.</span> <span class="nav-text">语法格式与示例</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4"><span class="nav-number">5.7.3.3.1.</span> <span class="nav-text">1. 获取当前日期时间</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#date_format---%E6%97%A5%E6%9C%9F%E6%A0%BC%E5%BC%8F%E5%8C%96"><span class="nav-number">5.7.3.3.2.</span> <span class="nav-text">2. DATE_FORMAT() - 日期格式化</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#datedifftimestampdiff---%E6%97%A5%E6%9C%9F%E5%B7%AE%E5%80%BC%E8%AE%A1%E7%AE%97"><span class="nav-number">5.7.3.3.3.</span> <span class="nav-text">3. DATEDIFF()&#x2F;TIMESTAMPDIFF() - 日期差值计算</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#date_adddate_sub---%E6%97%A5%E6%9C%9F%E5%A2%9E%E5%87%8F"><span class="nav-number">5.7.3.3.4.</span> <span class="nav-text">4. DATE_ADD()&#x2F;DATE_SUB() - 日期增减</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8F%90%E5%8F%96%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4%E9%83%A8%E5%88%86"><span class="nav-number">5.7.3.3.5.</span> <span class="nav-text">5. 提取日期时间部分</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%81%9A%E9%9B%86%E5%87%BD%E6%95%B0%E7%BB%9F%E8%AE%A1%E8%AE%A1%E7%AE%97"><span class="nav-number">5.8.</span> <span class="nav-text">聚集函数（统计计算）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0countsumavgmaxmin"><span class="nav-number">5.8.1.</span> <span class="nav-text">常用函数：COUNT()&#x2F;SUM()&#x2F;AVG()&#x2F;MAX()&#x2F;MIN()</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E8%81%9A%E9%9B%86%E5%87%BD%E6%95%B0%E8%A1%A8"><span class="nav-number">5.8.1.1.</span> <span class="nav-text">常用聚集函数表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%AD%E6%B3%95%E6%A0%BC%E5%BC%8F%E4%B8%8E%E7%A4%BA%E4%BE%8B-3"><span class="nav-number">5.8.1.2.</span> <span class="nav-text">语法格式与示例</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#count---%E8%AE%A1%E6%95%B0%E5%87%BD%E6%95%B0"><span class="nav-number">5.8.1.2.1.</span> <span class="nav-text">1. COUNT() - 计数函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#sum---%E6%B1%82%E5%92%8C%E5%87%BD%E6%95%B0"><span class="nav-number">5.8.1.2.2.</span> <span class="nav-text">2. SUM() - 求和函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#avg---%E5%B9%B3%E5%9D%87%E5%80%BC%E5%87%BD%E6%95%B0"><span class="nav-number">5.8.1.2.3.</span> <span class="nav-text">3. AVG() - 平均值函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#maxmin---%E6%9C%80%E5%A4%A7%E6%9C%80%E5%B0%8F%E5%80%BC%E5%87%BD%E6%95%B0"><span class="nav-number">5.8.1.2.4.</span> <span class="nav-text">4. MAX()&#x2F;MIN() - 最大&#x2F;最小值函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#group_concat---%E5%88%86%E7%BB%84%E8%BF%9E%E6%8E%A5%E5%87%BD%E6%95%B0"><span class="nav-number">5.8.1.2.5.</span> <span class="nav-text">5. GROUP_CONCAT() - 分组连接函数</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%81%9A%E9%9B%86%E5%87%BD%E6%95%B0%E4%B8%8Ewhere%E5%AD%90%E5%8F%A5%E7%BB%93%E5%90%88"><span class="nav-number">5.8.1.3.</span> <span class="nav-text">聚集函数与WHERE子句结合</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#group-by-%E5%AD%90%E5%8F%A5%E5%88%86%E7%BB%84%E6%95%B0%E6%8D%AE"><span class="nav-number">5.9.</span> <span class="nav-text">GROUP BY 子句（分组数据）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95%E6%8C%89%E6%8C%87%E5%AE%9A%E5%AD%97%E6%AE%B5%E5%88%86%E7%BB%84"><span class="nav-number">5.9.1.</span> <span class="nav-text">基本用法（按指定字段分组）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%AD%E6%B3%95%E6%A0%BC%E5%BC%8F-3"><span class="nav-number">5.9.1.1.</span> <span class="nav-text">语法格式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E7%A4%BA%E4%BE%8B"><span class="nav-number">5.9.1.2.</span> <span class="nav-text">基本示例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#group-by-%E4%B8%8E%E8%81%9A%E9%9B%86%E5%87%BD%E6%95%B0%E7%BB%93%E5%90%88"><span class="nav-number">5.9.1.3.</span> <span class="nav-text">GROUP BY 与聚集函数结合</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-number">5.9.1.4.</span> <span class="nav-text">使用注意事项</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AD%9B%E9%80%89%E5%88%86%E7%BB%84having%E5%AD%90%E5%8F%A5%E4%B8%8Ewhere%E7%9A%84%E5%8C%BA%E5%88%AB%E7%AD%9B%E9%80%89%E5%88%86%E7%BB%84%E7%BB%93%E6%9E%9C-vs-%E7%AD%9B%E9%80%89%E8%A1%8C"><span class="nav-number">5.9.2.</span> <span class="nav-text">筛选分组：HAVING子句（与WHERE的区别：筛选分组结果 vs 筛选行）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#having-%E8%AF%AD%E6%B3%95%E6%A0%BC%E5%BC%8F"><span class="nav-number">5.9.2.1.</span> <span class="nav-text">HAVING 语法格式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#having-%E4%B8%8E-where-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">5.9.2.2.</span> <span class="nav-text">HAVING 与 WHERE 的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#having-%E5%9F%BA%E6%9C%AC%E7%A4%BA%E4%BE%8B"><span class="nav-number">5.9.2.3.</span> <span class="nav-text">HAVING 基本示例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#where-%E4%B8%8E-having-%E7%BB%93%E5%90%88%E4%BD%BF%E7%94%A8"><span class="nav-number">5.9.2.4.</span> <span class="nav-text">WHERE 与 HAVING 结合使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#having-%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-number">5.9.2.5.</span> <span class="nav-text">HAVING 使用注意事项</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%90%E6%9F%A5%E8%AF%A2"><span class="nav-number">5.10.</span> <span class="nav-text">子查询</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%90%E6%9F%A5%E8%AF%A2%E7%9A%84%E5%88%86%E7%B1%BB"><span class="nav-number">5.10.1.</span> <span class="nav-text">子查询的分类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#where%E4%B8%AD%E7%9A%84%E5%AD%90%E6%9F%A5%E8%AF%A2%E5%8D%95%E8%A1%8C%E5%AD%90%E6%9F%A5%E8%AF%A2%E5%A4%9A%E8%A1%8C%E5%AD%90%E6%9F%A5%E8%AF%A2in"><span class="nav-number">5.10.2.</span> <span class="nav-text">WHERE中的子查询（单行子查询&#x2F;多行子查询IN）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8D%95%E8%A1%8C%E5%AD%90%E6%9F%A5%E8%AF%A2"><span class="nav-number">5.10.2.1.</span> <span class="nav-text">单行子查询</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%9A%E8%A1%8C%E5%AD%90%E6%9F%A5%E8%AF%A2"><span class="nav-number">5.10.2.2.</span> <span class="nav-text">多行子查询</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#where%E5%AD%90%E6%9F%A5%E8%AF%A2%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-number">5.10.2.3.</span> <span class="nav-text">WHERE子查询使用注意事项</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#from%E4%B8%AD%E7%9A%84%E5%AD%90%E6%9F%A5%E8%AF%A2%E6%B4%BE%E7%94%9F%E8%A1%A8%E9%9C%80%E6%8C%87%E5%AE%9A%E5%88%AB%E5%90%8D"><span class="nav-number">5.10.3.</span> <span class="nav-text">FROM中的子查询（派生表，需指定别名）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="nav-number">5.10.3.1.</span> <span class="nav-text">基本语法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B1%E4%BD%BF%E7%94%A8%E6%B4%BE%E7%94%9F%E8%A1%A8%E7%BB%9F%E8%AE%A1%E9%83%A8%E9%97%A8%E5%B9%B3%E5%9D%87%E8%96%AA%E8%B5%84"><span class="nav-number">5.10.3.2.</span> <span class="nav-text">示例1：使用派生表统计部门平均薪资</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B2%E5%A4%8D%E6%9D%82%E6%B4%BE%E7%94%9F%E8%A1%A8%E4%B8%8E%E8%81%94%E7%BB%93"><span class="nav-number">5.10.3.3.</span> <span class="nav-text">示例2：复杂派生表与联结</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B3%E5%B5%8C%E5%A5%97%E6%B4%BE%E7%94%9F%E8%A1%A8"><span class="nav-number">5.10.3.4.</span> <span class="nav-text">示例3：嵌套派生表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#from%E5%AD%90%E6%9F%A5%E8%AF%A2%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-number">5.10.3.5.</span> <span class="nav-text">FROM子查询使用注意事项</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B6%E4%BB%96%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%AD%90%E6%9F%A5%E8%AF%A2"><span class="nav-number">5.10.4.</span> <span class="nav-text">其他类型的子查询</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#select%E5%AD%90%E5%8F%A5%E4%B8%AD%E7%9A%84%E5%AD%90%E6%9F%A5%E8%AF%A2"><span class="nav-number">5.10.4.1.</span> <span class="nav-text">SELECT子句中的子查询</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#having%E5%AD%90%E5%8F%A5%E4%B8%AD%E7%9A%84%E5%AD%90%E6%9F%A5%E8%AF%A2"><span class="nav-number">5.10.4.2.</span> <span class="nav-text">HAVING子句中的子查询</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%9B%B8%E5%85%B3%E5%AD%90%E6%9F%A5%E8%AF%A2correlated-subquery"><span class="nav-number">5.10.4.3.</span> <span class="nav-text">相关子查询（Correlated Subquery）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%90%E6%9F%A5%E8%AF%A2%E7%9A%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="nav-number">5.10.5.</span> <span class="nav-text">子查询的性能优化</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%81%94%E7%BB%93%E8%A1%A8%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2"><span class="nav-number">5.11.</span> <span class="nav-text">联结表（多表查询）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%9B%E5%8D%A1%E5%B0%94%E7%A7%AF%E6%97%A0%E5%85%B3%E8%81%94%E6%9D%A1%E4%BB%B6%E7%9A%84%E8%81%94%E7%BB%93%E9%9C%80%E9%81%BF%E5%85%8D"><span class="nav-number">5.11.1.</span> <span class="nav-text">笛卡尔积（无关联条件的联结，需避免）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E9%83%A8%E8%81%94%E7%BB%93inner-join%E5%8C%B9%E9%85%8D%E4%B8%A4%E8%A1%A8%E5%85%B3%E8%81%94%E6%95%B0%E6%8D%AE"><span class="nav-number">5.11.2.</span> <span class="nav-text">内部联结（INNER JOIN，匹配两表关联数据）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A1%A8%E5%AD%97%E6%AE%B5%E5%88%AB%E5%90%8D%E7%AE%80%E5%8C%96%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2%E8%AF%AD%E6%B3%95"><span class="nav-number">5.11.3.</span> <span class="nav-text">表&#x2F;字段别名（简化多表查询语法）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E7%84%B6%E8%81%94%E7%BB%93natural-join%E8%87%AA%E5%8A%A8%E5%8C%B9%E9%85%8D%E5%90%8C%E5%90%8D%E5%90%8C%E7%B1%BB%E5%9E%8B%E5%AD%97%E6%AE%B5"><span class="nav-number">5.11.4.</span> <span class="nav-text">自然联结（NATURAL JOIN，自动匹配同名同类型字段）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%96%E9%83%A8%E8%81%94%E7%BB%93leftrightfull-join%E4%BF%9D%E7%95%99%E5%B7%A6%E5%8F%B3%E5%85%A8%E8%A1%A8%E6%95%B0%E6%8D%AE"><span class="nav-number">5.11.5.</span> <span class="nav-text">外部联结（LEFT&#x2F;RIGHT&#x2F;FULL JOIN，保留左&#x2F;右&#x2F;全表数据）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%AB%98%E7%BA%A7%E8%81%94%E7%BB%93%E5%A4%9A%E8%A1%A8%E8%81%94%E7%BB%93%E8%87%AA%E8%81%94%E7%BB%93"><span class="nav-number">5.11.6.</span> <span class="nav-text">高级联结（多表联结、自联结）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%9A%E8%A1%A8%E8%81%94%E7%BB%93"><span class="nav-number">5.11.6.1.</span> <span class="nav-text">多表联结</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%87%AA%E8%81%94%E7%BB%93self-join"><span class="nav-number">5.11.6.2.</span> <span class="nav-text">自联结（Self-Join）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%84%E5%90%88%E6%9F%A5%E8%AF%A2union"><span class="nav-number">5.12.</span> <span class="nav-text">组合查询：UNION</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#union%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95%E5%90%88%E5%B9%B6%E5%A4%9A%E4%B8%AA%E6%9F%A5%E8%AF%A2%E7%BB%93%E6%9E%9C%E9%9B%86"><span class="nav-number">5.12.1.</span> <span class="nav-text">UNION基本用法（合并多个查询结果集）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#union%E4%B8%8Eunion-all%E7%9A%84%E5%8C%BA%E5%88%AB%E5%8E%BB%E9%87%8D-vs-%E4%BF%9D%E7%95%99%E9%87%8D%E5%A4%8D"><span class="nav-number">5.12.2.</span> <span class="nav-text">UNION与UNION ALL的区别（去重 vs 保留重复）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#union%E7%9A%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%BB%BA%E8%AE%AE"><span class="nav-number">5.12.3.</span> <span class="nav-text">UNION的性能优化建议</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%A8%E6%96%87%E6%9C%AC%E6%90%9C%E7%B4%A2%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95"><span class="nav-number">5.13.</span> <span class="nav-text">全文本搜索（基础用法）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%A8%E6%96%87%E6%9C%AC%E6%90%9C%E7%B4%A2%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E4%B8%8E%E4%BD%9C%E7%94%A8"><span class="nav-number">5.13.1.</span> <span class="nav-text">全文本搜索的基本概念与作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%85%A8%E6%96%87%E6%9C%AC%E7%B4%A2%E5%BC%95"><span class="nav-number">5.13.2.</span> <span class="nav-text">创建全文本索引</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8match-against%E8%BF%9B%E8%A1%8C%E5%85%A8%E6%96%87%E6%9C%AC%E6%90%9C%E7%B4%A2"><span class="nav-number">5.13.3.</span> <span class="nav-text">使用MATCH AGAINST进行全文本搜索</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%BC%8F%E6%90%9C%E7%B4%A2%E9%BB%98%E8%AE%A4"><span class="nav-number">5.13.4.</span> <span class="nav-text">1. 自然语言模式搜索（默认）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%83%E5%B0%94%E6%A8%A1%E5%BC%8F%E6%90%9C%E7%B4%A2"><span class="nav-number">5.13.5.</span> <span class="nav-text">2. 布尔模式搜索</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9F%A5%E8%AF%A2%E6%89%A9%E5%B1%95%E6%A8%A1%E5%BC%8F%E6%90%9C%E7%B4%A2"><span class="nav-number">5.13.6.</span> <span class="nav-text">3. 查询扩展模式搜索</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E7%9B%B8%E5%85%B3%E6%80%A7%E5%BE%97%E5%88%86"><span class="nav-number">5.13.7.</span> <span class="nav-text">获取相关性得分</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%A8%E6%96%87%E6%9C%AC%E6%90%9C%E7%B4%A2%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-number">5.13.8.</span> <span class="nav-text">全文本搜索的注意事项</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%A8%E6%96%87%E6%9C%AC%E6%90%9C%E7%B4%A2%E4%B8%8Elike%E6%9F%A5%E8%AF%A2%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="nav-number">5.13.9.</span> <span class="nav-text">全文本搜索与LIKE查询的对比</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C%E5%A2%9E%E5%88%A0%E6%94%B9"><span class="nav-number">6.</span> <span class="nav-text">数据操作（增删改）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#insert%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE"><span class="nav-number">6.1.</span> <span class="nav-text">INSERT（插入数据）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8F%92%E5%85%A5%E5%8D%95%E8%A1%8C%E6%95%B0%E6%8D%AEinsert-into-%E8%A1%A8%E5%88%971-values%E5%80%BC1"><span class="nav-number">6.1.1.</span> <span class="nav-text">插入单行数据（INSERT INTO 表(列1) VALUES(值1)）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8F%92%E5%85%A5%E5%A4%9A%E8%A1%8C%E6%95%B0%E6%8D%AEinsert-into-%E8%A1%A8-values%E5%80%BC1%E5%80%BC2"><span class="nav-number">6.1.2.</span> <span class="nav-text">插入多行数据（INSERT INTO 表 VALUES(值1),(值2)）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8F%92%E5%85%A5%E6%9F%A5%E8%AF%A2%E7%BB%93%E6%9E%9Cinsert-...-select%E6%89%B9%E9%87%8F%E5%A4%8D%E5%88%B6%E6%95%B0%E6%8D%AE"><span class="nav-number">6.1.3.</span> <span class="nav-text">插入查询结果（INSERT ... SELECT，批量复制数据）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#insert-ignore%E5%BF%BD%E7%95%A5%E5%86%B2%E7%AA%81"><span class="nav-number">6.1.4.</span> <span class="nav-text">INSERT IGNORE（忽略冲突）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#insert-on-duplicate-key-update%E5%86%B2%E7%AA%81%E6%97%B6%E6%9B%B4%E6%96%B0"><span class="nav-number">6.1.5.</span> <span class="nav-text">INSERT … ON DUPLICATE KEY UPDATE（冲突时更新）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8F%92%E5%85%A5%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-number">6.1.6.</span> <span class="nav-text">插入注意事项</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#update%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE"><span class="nav-number">6.2.</span> <span class="nav-text">UPDATE（更新数据）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95update-%E8%A1%A8-set-%E5%88%97%E5%80%BC-where-%E6%9D%A1%E4%BB%B6"><span class="nav-number">6.2.1.</span> <span class="nav-text">基本用法（UPDATE 表 SET 列&#x3D;值 WHERE 条件）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9B%B4%E6%96%B0%E5%A4%9A%E4%B8%AA%E8%AE%B0%E5%BD%95"><span class="nav-number">6.2.2.</span> <span class="nav-text">更新多个记录</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E5%85%B6%E4%BB%96%E8%A1%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E6%9B%B4%E6%96%B0"><span class="nav-number">6.2.3.</span> <span class="nav-text">基于其他表的数据更新</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8case%E8%AF%AD%E5%8F%A5%E8%BF%9B%E8%A1%8C%E6%9D%A1%E4%BB%B6%E6%9B%B4%E6%96%B0"><span class="nav-number">6.2.4.</span> <span class="nav-text">使用CASE语句进行条件更新</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9B%B4%E6%96%B0%E8%87%AA%E5%A2%9E%E5%AD%97%E6%AE%B5"><span class="nav-number">6.2.5.</span> <span class="nav-text">更新自增字段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#update%E7%9A%84%E9%87%8D%E8%A6%81%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-number">6.2.6.</span> <span class="nav-text">UPDATE的重要注意事项</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#delete%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE"><span class="nav-number">6.3.</span> <span class="nav-text">DELETE（删除数据）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95delete-from-%E8%A1%A8-where-%E6%9D%A1%E4%BB%B6"><span class="nav-number">6.3.1.</span> <span class="nav-text">基本用法（DELETE FROM 表 WHERE 条件）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E8%A1%A8%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E8%AE%B0%E5%BD%95"><span class="nav-number">6.3.2.</span> <span class="nav-text">删除表中的所有记录</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8limit%E9%99%90%E5%88%B6%E5%88%A0%E9%99%A4%E6%95%B0%E9%87%8F"><span class="nav-number">6.3.3.</span> <span class="nav-text">使用LIMIT限制删除数量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E8%A1%A8%E5%88%A0%E9%99%A4"><span class="nav-number">6.3.4.</span> <span class="nav-text">多表删除</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%8E%E5%AD%90%E6%9F%A5%E8%AF%A2%E7%BB%93%E6%9E%9C%E4%B8%AD%E5%88%A0%E9%99%A4"><span class="nav-number">6.3.5.</span> <span class="nav-text">从子查询结果中删除</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#delete%E4%B8%8Etruncate%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">6.3.6.</span> <span class="nav-text">DELETE与TRUNCATE的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#delete%E7%9A%84%E9%87%8D%E8%A6%81%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-number">6.3.7.</span> <span class="nav-text">DELETE的重要注意事项</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E5%9F%BA%E7%A1%80"><span class="nav-number">6.4.</span> <span class="nav-text">事务处理基础</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1%E7%9A%84acid%E7%89%B9%E6%80%A7%E5%8E%9F%E5%AD%90%E6%80%A7%E4%B8%80%E8%87%B4%E6%80%A7%E9%9A%94%E7%A6%BB%E6%80%A7%E6%8C%81%E4%B9%85%E6%80%A7"><span class="nav-number">6.4.1.</span> <span class="nav-text">事务的ACID特性（原子性、一致性、隔离性、持久性）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8E%9F%E5%AD%90%E6%80%A7atomicity"><span class="nav-number">6.4.1.1.</span> <span class="nav-text">原子性（Atomicity）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%80%E8%87%B4%E6%80%A7consistency"><span class="nav-number">6.4.1.2.</span> <span class="nav-text">一致性（Consistency）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9A%94%E7%A6%BB%E6%80%A7isolation"><span class="nav-number">6.4.1.3.</span> <span class="nav-text">隔离性（Isolation）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8C%81%E4%B9%85%E6%80%A7durability"><span class="nav-number">6.4.1.4.</span> <span class="nav-text">持久性（Durability）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#acid%E7%89%B9%E6%80%A7%E5%AF%B9%E6%AF%94%E8%A1%A8"><span class="nav-number">6.4.2.</span> <span class="nav-text">ACID特性对比表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1%E6%93%8D%E4%BD%9Cstart-transactioncommit%E6%8F%90%E4%BA%A4rollback%E5%9B%9E%E6%BB%9A"><span class="nav-number">6.4.3.</span> <span class="nav-text">事务操作：START TRANSACTION&#x2F;COMMIT（提交）&#x2F;ROLLBACK（回滚）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%AF%E5%8A%A8%E4%BA%8B%E5%8A%A1start-transaction"><span class="nav-number">6.4.3.1.</span> <span class="nav-text">启动事务：START TRANSACTION</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8F%90%E4%BA%A4%E4%BA%8B%E5%8A%A1commit"><span class="nav-number">6.4.3.2.</span> <span class="nav-text">提交事务：COMMIT</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9B%9E%E6%BB%9A%E4%BA%8B%E5%8A%A1rollback"><span class="nav-number">6.4.3.3.</span> <span class="nav-text">回滚事务：ROLLBACK</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1%E4%BF%9D%E5%AD%98%E7%82%B9savepoint"><span class="nav-number">6.4.3.4.</span> <span class="nav-text">事务保存点：SAVEPOINT</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1%E7%B1%BB%E5%9E%8B"><span class="nav-number">6.4.4.</span> <span class="nav-text">事务类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%98%BE%E5%BC%8F%E4%BA%8B%E5%8A%A1"><span class="nav-number">6.4.4.1.</span> <span class="nav-text">显式事务</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9A%90%E5%BC%8F%E4%BA%8B%E5%8A%A1"><span class="nav-number">6.4.4.2.</span> <span class="nav-text">隐式事务</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%87%AA%E5%8A%A8%E6%8F%90%E4%BA%A4%E4%BA%8B%E5%8A%A1"><span class="nav-number">6.4.4.3.</span> <span class="nav-text">自动提交事务</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E7%9A%84%E9%87%8D%E8%A6%81%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-number">6.4.5.</span> <span class="nav-text">事务处理的重要注意事项</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1%E7%A4%BA%E4%BE%8B%E5%AE%8C%E6%95%B4%E7%9A%84%E9%93%B6%E8%A1%8C%E8%BD%AC%E8%B4%A6%E6%B5%81%E7%A8%8B"><span class="nav-number">6.4.6.</span> <span class="nav-text">事务示例：完整的银行转账流程</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%A1%A8%E6%93%8D%E4%BD%9C%E5%88%9B%E5%BB%BA%E4%BF%AE%E6%94%B9%E5%88%A0%E9%99%A4"><span class="nav-number">7.</span> <span class="nav-text">表操作（创建、修改、删除）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E8%A1%A8create-table"><span class="nav-number">7.1.</span> <span class="nav-text">创建表：CREATE TABLE</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E6%8C%87%E5%AE%9A%E5%AD%97%E6%AE%B5%E5%90%8D%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%BA%A6%E6%9D%9F"><span class="nav-number">7.1.1.</span> <span class="nav-text">基本语法（指定字段名、数据类型、约束）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A1%A8%E7%BA%A6%E6%9D%9F%E4%BF%9D%E8%AF%81%E6%95%B0%E6%8D%AE%E5%AE%8C%E6%95%B4%E6%80%A7"><span class="nav-number">7.1.2.</span> <span class="nav-text">表约束（保证数据完整性）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E5%A2%9E%E5%AD%97%E6%AE%B5auto_increment%E4%B8%BB%E9%94%AE%E5%B8%B8%E7%94%A8"><span class="nav-number">7.1.3.</span> <span class="nav-text">自增字段：AUTO_INCREMENT（主键常用）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9B%B4%E6%96%B0%E8%A1%A8alter-table%E6%B7%BB%E5%8A%A0%E4%BF%AE%E6%94%B9%E5%88%A0%E9%99%A4%E5%AD%97%E6%AE%B5%E7%BA%A6%E6%9D%9F"><span class="nav-number">7.2.</span> <span class="nav-text">更新表：ALTER TABLE（添加&#x2F;修改&#x2F;删除字段、约束）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E8%A1%A8drop-table%E8%B0%A8%E6%85%8E%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%8F%AF%E9%80%86"><span class="nav-number">7.3.</span> <span class="nav-text">删除表：DROP TABLE（谨慎使用，不可逆）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%87%8D%E5%91%BD%E5%90%8D%E8%A1%A8rename-table"><span class="nav-number">7.4.</span> <span class="nav-text">重命名表：RENAME TABLE</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E5%9F%BA%E7%A1%80%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%85%A5%E9%97%A8"><span class="nav-number">7.5.</span> <span class="nav-text">索引基础（性能优化入门）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BD%9C%E7%94%A8%E5%8A%A0%E9%80%9F%E6%9F%A5%E8%AF%A2"><span class="nav-number">7.5.1.</span> <span class="nav-text">索引的作用（加速查询）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95create-indexcreate-unique-index"><span class="nav-number">7.5.2.</span> <span class="nav-text">创建索引：CREATE INDEX&#x2F;CREATE UNIQUE INDEX</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E7%B4%A2%E5%BC%95drop-index"><span class="nav-number">7.5.3.</span> <span class="nav-text">删除索引：DROP INDEX</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%BF%9B%E9%98%B6%E7%90%86%E8%AE%BA%E4%B8%8E%E6%8A%80%E6%9C%AF%E5%AE%9E%E6%93%8D%E6%B7%B1%E5%8C%96"><span class="nav-number">8.</span> <span class="nav-text">进阶理论与技术（实操深化）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%98%E5%82%A8"><span class="nav-number">8.1.</span> <span class="nav-text">7.1 数据库存储</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E7%AD%96%E7%95%A5%E6%95%B0%E6%8D%AE%E6%96%87%E4%BB%B6%E7%9A%84%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F"><span class="nav-number">8.1.1.</span> <span class="nav-text">7.1.1 存储策略（数据文件的存储方式）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8Einnodbmyisam"><span class="nav-number">8.1.2.</span> <span class="nav-text">7.1.2 常用存储引擎（InnoDB、MyISAM）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95%E8%BF%9B%E9%98%B6"><span class="nav-number">8.2.</span> <span class="nav-text">7.2 数据库索引进阶</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86%E5%BF%AB%E9%80%9F%E6%9F%A5%E6%89%BE%E7%9A%84%E6%A0%B8%E5%BF%83%E9%80%BB%E8%BE%91"><span class="nav-number">8.2.1.</span> <span class="nav-text">7.2.1 索引原理（快速查找的核心逻辑）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E7%B1%BB%E5%9E%8Bb%E6%A0%91%E7%B4%A2%E5%BC%95%E5%93%88%E5%B8%8C%E7%B4%A2%E5%BC%95%E5%85%A8%E6%96%87%E7%B4%A2%E5%BC%95%E7%AD%89"><span class="nav-number">8.2.2.</span> <span class="nav-text">7.2.2 索引类型（B树索引、哈希索引、全文索引等）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E7%AE%A1%E7%90%86%E6%9F%A5%E7%9C%8B%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%E7%B4%A2%E5%BC%95"><span class="nav-number">8.2.3.</span> <span class="nav-text">7.2.3 索引管理（查看索引、优化索引）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9F%A5%E8%AF%A2%E5%A4%84%E7%90%86%E4%B8%8E%E4%BC%98%E5%8C%96"><span class="nav-number">8.3.</span> <span class="nav-text">7.3 查询处理与优化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9F%A5%E8%AF%A2%E5%A4%84%E7%90%86%E8%BF%87%E7%A8%8B%E8%A7%A3%E6%9E%90%E4%BC%98%E5%8C%96%E6%89%A7%E8%A1%8C"><span class="nav-number">8.3.1.</span> <span class="nav-text">7.3.1 查询处理过程（解析→优化→执行）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80%E4%BC%98%E5%8C%96%E6%8A%80%E5%B7%A7%E9%81%BF%E5%85%8Dselect-%E5%90%88%E7%90%86%E5%BB%BA%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96where%E6%9D%A1%E4%BB%B6"><span class="nav-number">8.3.2.</span> <span class="nav-text">7.3.2 基础优化技巧（避免SELECT *、合理建索引、优化WHERE条件）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E6%95%B0%E4%BC%98%E5%8C%96%E4%B8%8E%E7%89%A9%E7%90%86%E4%BC%98%E5%8C%96%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3%E6%94%B9%E5%86%99%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E9%80%89%E6%8B%A9%E6%9C%80%E4%BC%98%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92"><span class="nav-number">8.3.3.</span> <span class="nav-text">7.3.3 代数优化与物理优化（简单理解：改写查询语句、选择最优执行计划）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E6%8A%80%E6%9C%AF%E8%BF%9B%E9%98%B6"><span class="nav-number">8.4.</span> <span class="nav-text">7.4 事务处理技术进阶</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1%E8%B0%83%E5%BA%A6%E5%8F%8A%E5%85%B6%E6%AD%A3%E7%A1%AE%E6%80%A7%E9%81%BF%E5%85%8D%E8%84%8F%E8%AF%BB%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%E5%B9%BB%E8%AF%BB"><span class="nav-number">8.4.1.</span> <span class="nav-text">7.4.1 事务调度及其正确性（避免脏读、不可重复读、幻读）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1%E8%B0%83%E5%BA%A6%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="nav-number">8.4.1.1.</span> <span class="nav-text">事务调度的类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B0%83%E5%BA%A6%E6%AD%A3%E7%A1%AE%E6%80%A7%E7%9A%84%E5%88%A4%E6%96%AD"><span class="nav-number">8.4.1.2.</span> <span class="nav-text">调度正确性的判断</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E4%BA%8B%E5%8A%A1%E4%B8%AD%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-number">8.4.1.3.</span> <span class="nav-text">并发事务中的问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B0%83%E5%BA%A6%E5%AE%9E%E4%BE%8B%E5%88%86%E6%9E%90"><span class="nav-number">8.4.1.4.</span> <span class="nav-text">调度实例分析</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6%E9%94%81%E6%9C%BA%E5%88%B6%E5%9F%BA%E7%A1%80%E8%A1%8C%E9%94%81%E8%A1%A8%E9%94%81"><span class="nav-number">8.4.2.</span> <span class="nav-text">7.4.2 并发控制（锁机制基础：行锁、表锁）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%94%81%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3"><span class="nav-number">8.4.2.1.</span> <span class="nav-text">锁机制详解</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A1%8C%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">8.4.2.2.</span> <span class="nav-text">行锁的实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%9A%E7%89%88%E6%9C%AC%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6mvcc"><span class="nav-number">8.4.2.3.</span> <span class="nav-text">多版本并发控制（MVCC）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AD%BB%E9%94%81deadlock%E5%A4%84%E7%90%86"><span class="nav-number">8.4.2.4.</span> <span class="nav-text">死锁（Deadlock）处理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%94%81%E7%AB%9E%E4%BA%89%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5"><span class="nav-number">8.4.2.5.</span> <span class="nav-text">锁竞争优化策略</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%ABread-uncommittedread-committedrepeatable-readserializable"><span class="nav-number">8.4.3.</span> <span class="nav-text">7.4.3 事务隔离级别（READ UNCOMMITTED→READ COMMITTED→REPEATABLE READ→SERIALIZABLE）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%BB%E6%9C%AA%E6%8F%90%E4%BA%A4read-uncommitted"><span class="nav-number">8.4.3.1.</span> <span class="nav-text">1. 读未提交（READ UNCOMMITTED）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%BB%E5%B7%B2%E6%8F%90%E4%BA%A4read-committed"><span class="nav-number">8.4.3.2.</span> <span class="nav-text">2. 读已提交（READ COMMITTED）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BBrepeatable-read"><span class="nav-number">8.4.3.3.</span> <span class="nav-text">3. 可重复读（REPEATABLE READ）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%B2%E8%A1%8C%E5%8C%96serializable"><span class="nav-number">8.4.3.4.</span> <span class="nav-text">4. 串行化（SERIALIZABLE）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E6%AF%94%E8%BE%83%E8%A1%A8"><span class="nav-number">8.4.3.5.</span> <span class="nav-text">隔离级别比较表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#innodb%E4%B8%AD%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E5%AE%9E%E7%8E%B0"><span class="nav-number">8.4.3.6.</span> <span class="nav-text">InnoDB中的隔离级别实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E4%B8%8E%E9%94%81%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-number">8.4.3.7.</span> <span class="nav-text">隔离级别与锁的关系</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%BE%E7%BD%AE%E5%85%A8%E5%B1%80%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="nav-number">8.4.3.8.</span> <span class="nav-text">设置全局隔离级别</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%81%A2%E5%A4%8D%E6%8A%80%E6%9C%AF%E4%BA%8B%E5%8A%A1%E6%97%A5%E5%BF%97%E7%9A%84%E4%BD%9C%E7%94%A8%E5%B4%A9%E6%BA%83%E5%90%8E%E6%95%B0%E6%8D%AE%E6%81%A2%E5%A4%8D"><span class="nav-number">8.4.4.</span> <span class="nav-text">7.4.4 恢复技术（事务日志的作用：崩溃后数据恢复）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1%E6%97%A5%E5%BF%97%E7%B1%BB%E5%9E%8B"><span class="nav-number">8.4.4.1.</span> <span class="nav-text">事务日志类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#wal%E9%A2%84%E5%86%99%E5%BC%8F%E6%97%A5%E5%BF%97%E7%AD%96%E7%95%A5"><span class="nav-number">8.4.4.2.</span> <span class="nav-text">WAL（预写式日志）策略</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%81%A2%E5%A4%8D%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3"><span class="nav-number">8.4.4.3.</span> <span class="nav-text">恢复机制详解</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B4%A9%E6%BA%83%E6%81%A2%E5%A4%8D%E8%BF%87%E7%A8%8B"><span class="nav-number">8.4.4.4.</span> <span class="nav-text">崩溃恢复过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%97%B6%E9%97%B4%E7%82%B9%E6%81%A2%E5%A4%8Dpoint-in-time-recovery"><span class="nav-number">8.4.4.5.</span> <span class="nav-text">时间点恢复（Point-in-Time Recovery）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="nav-number">8.4.4.6.</span> <span class="nav-text">日志管理最佳实践</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1%E4%BC%98%E5%8C%96%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="nav-number">8.4.5.</span> <span class="nav-text">7.4.5 事务优化与最佳实践</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99"><span class="nav-number">8.4.5.1.</span> <span class="nav-text">事务设计原则</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%8A%80%E5%B7%A7"><span class="nav-number">8.4.5.2.</span> <span class="nav-text">性能优化技巧</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="nav-number">8.4.5.3.</span> <span class="nav-text">常见问题及解决方案</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%9B%91%E6%8E%A7%E4%B8%8E%E8%AF%8A%E6%96%AD"><span class="nav-number">8.4.5.4.</span> <span class="nav-text">监控与诊断</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E7%A4%BA%E4%BE%8B"><span class="nav-number">8.4.5.5.</span> <span class="nav-text">最佳实践示例</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%8C%E6%95%B4%E6%80%A7%E8%BF%9B%E9%98%B6"><span class="nav-number">8.5.</span> <span class="nav-text">7.5 数据库完整性进阶</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93%E7%89%B9%E6%80%A7"><span class="nav-number">9.</span> <span class="nav-text">8. 高级数据库特性</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A7%86%E5%9B%BE"><span class="nav-number">9.1.</span> <span class="nav-text">8.1 视图</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E8%A7%86%E5%9B%BEcreate-view%E7%AE%80%E5%8C%96%E5%A4%8D%E6%9D%82%E6%9F%A5%E8%AF%A2"><span class="nav-number">9.1.1.</span> <span class="nav-text">8.1.1 创建视图：CREATE VIEW（简化复杂查询）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E4%B8%8E%E4%BF%AE%E6%94%B9%E8%A7%86%E5%9B%BEselect-from-%E8%A7%86%E5%9B%BEalter-view"><span class="nav-number">9.1.2.</span> <span class="nav-text">8.1.2 使用与修改视图（SELECT * FROM 视图&#x2F;ALTER VIEW）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%86%E5%9B%BE%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-number">9.1.3.</span> <span class="nav-text">8.1.3 视图的优缺点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B"><span class="nav-number">9.2.</span> <span class="nav-text">8.2 存储过程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8Bcreate-procedure%E5%B0%81%E8%A3%85%E5%A4%8D%E6%9D%82%E9%80%BB%E8%BE%91"><span class="nav-number">9.2.1.</span> <span class="nav-text">8.2.1 创建存储过程：CREATE PROCEDURE（封装复杂逻辑）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%83%E7%94%A8%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8Bcall-%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E5%90%8D"><span class="nav-number">9.2.2.</span> <span class="nav-text">8.2.2 调用存储过程：CALL 存储过程名()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E7%9A%84%E5%8F%82%E6%95%B0inoutinout"><span class="nav-number">9.2.3.</span> <span class="nav-text">8.2.3 存储过程的参数（IN&#x2F;OUT&#x2F;INOUT）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B8%B8%E6%A0%87%E9%81%8D%E5%8E%86%E6%9F%A5%E8%AF%A2%E7%BB%93%E6%9E%9C%E9%9B%86"><span class="nav-number">9.3.</span> <span class="nav-text">8.3 游标（遍历查询结果集）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A7%A6%E5%8F%91%E5%99%A8"><span class="nav-number">9.4.</span> <span class="nav-text">8.4 触发器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E8%A7%A6%E5%8F%91%E5%99%A8create-trigger%E8%87%AA%E5%8A%A8%E6%89%A7%E8%A1%8C%E9%80%BB%E8%BE%91"><span class="nav-number">9.4.1.</span> <span class="nav-text">8.4.1 创建触发器：CREATE TRIGGER（自动执行逻辑）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A6%E5%8F%91%E6%97%B6%E6%9C%BAbeforeafter%E4%B8%8E%E8%A7%A6%E5%8F%91%E7%B1%BB%E5%9E%8Binsertupdatedelete"><span class="nav-number">9.4.2.</span> <span class="nav-text">8.4.2 触发时机（BEFORE&#x2F;AFTER）与触发类型（INSERT&#x2F;UPDATE&#x2F;DELETE）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86%E4%B8%8E%E7%BB%B4%E6%8A%A4"><span class="nav-number">10.</span> <span class="nav-text">9. 数据库管理与维护</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E4%B8%8E%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86"><span class="nav-number">10.1.</span> <span class="nav-text">9.1 访问控制与用户管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E7%94%A8%E6%88%B7create-user"><span class="nav-number">10.1.1.</span> <span class="nav-text">9.1.1 创建用户：CREATE USER</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%88%E6%9D%83grant-%E6%9D%83%E9%99%90-on-%E6%95%B0%E6%8D%AE%E5%BA%93.%E8%A1%A8-to-%E7%94%A8%E6%88%B7"><span class="nav-number">10.1.2.</span> <span class="nav-text">9.1.2 授权：GRANT 权限 ON 数据库.表 TO 用户</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%92%A4%E9%94%80%E6%9D%83%E9%99%90revoke-%E6%9D%83%E9%99%90-on-%E6%95%B0%E6%8D%AE%E5%BA%93.%E8%A1%A8-from-%E7%94%A8%E6%88%B7"><span class="nav-number">10.1.3.</span> <span class="nav-text">9.1.3 撤销权限：REVOKE 权限 ON 数据库.表 FROM 用户</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E7%94%A8%E6%88%B7drop-user"><span class="nav-number">10.1.4.</span> <span class="nav-text">9.1.4 删除用户：DROP USER</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%A4%87%E4%BB%BD"><span class="nav-number">10.2.</span> <span class="nav-text">9.2 数据备份</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%BB%E8%BE%91%E5%A4%87%E4%BB%BDmysqldump%E5%91%BD%E4%BB%A4"><span class="nav-number">10.2.1.</span> <span class="nav-text">9.2.1 逻辑备份（mysqldump命令）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%81%A2%E5%A4%8D%E6%95%B0%E6%8D%AEsource%E5%91%BD%E4%BB%A4mysql--u%E7%94%A8%E6%88%B7%E5%90%8D--p-%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%A4%87%E4%BB%BD%E6%96%87%E4%BB%B6"><span class="nav-number">10.2.2.</span> <span class="nav-text">9.2.2 恢复数据（SOURCE命令&#x2F;mysql -u用户名 -p 数据库 &lt; 备份文件）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BB%B4%E6%8A%A4"><span class="nav-number">10.3.</span> <span class="nav-text">9.3 数据库维护</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%97%AE%E9%A2%98%E8%AF%8A%E6%96%AD%E4%B8%8E%E6%97%A5%E5%BF%97"><span class="nav-number">10.4.</span> <span class="nav-text">9.4 问题诊断与日志</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%8A%E6%96%AD%E5%90%AF%E5%8A%A8%E9%97%AE%E9%A2%98%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E6%A3%80%E6%9F%A5%E7%AB%AF%E5%8F%A3%E5%8D%A0%E7%94%A8%E6%8E%92%E6%9F%A5"><span class="nav-number">10.4.1.</span> <span class="nav-text">9.4.1 诊断启动问题（配置文件检查、端口占用排查）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9F%A5%E7%9C%8B%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6%E9%94%99%E8%AF%AF%E6%97%A5%E5%BF%97%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97"><span class="nav-number">10.4.2.</span> <span class="nav-text">9.4.2 查看日志文件（错误日志、查询日志、慢查询日志）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%A7%E8%83%BD%E6%94%B9%E5%96%84"><span class="nav-number">10.5.</span> <span class="nav-text">9.5 性能改善</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%B7%B1%E5%85%A5%E7%90%86%E8%AE%BA%E6%8B%93%E5%B1%95%E5%8F%AF%E9%80%89%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0%E8%80%85"><span class="nav-number">11.</span> <span class="nav-text">10. 深入理论拓展（可选，进阶学习者）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%98%BF%E5%A7%86%E6%96%AF%E7%89%B9%E6%9C%97%E5%85%AC%E7%90%86%E4%BD%93%E7%B3%BB%E5%87%BD%E6%95%B0%E4%BE%9D%E8%B5%96%E7%9A%84%E6%8E%A8%E7%90%86%E8%A7%84%E5%88%99"><span class="nav-number">11.1.</span> <span class="nav-text">10.1 阿姆斯特朗公理体系（函数依赖的推理规则）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A8%A1%E5%BC%8F%E5%88%86%E8%A7%A3%E6%97%A0%E6%8D%9F%E8%BF%9E%E6%8E%A5%E5%88%86%E8%A7%A3%E4%BF%9D%E6%8C%81%E5%87%BD%E6%95%B0%E4%BE%9D%E8%B5%96%E5%88%86%E8%A7%A3"><span class="nav-number">11.2.</span> <span class="nav-text">10.2 模式分解（无损连接分解、保持函数依赖分解）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E5%80%BC%E4%BE%9D%E8%B5%96%E4%B8%8E%E7%AC%AC%E5%9B%9B%E8%8C%83%E5%BC%8F4nf"><span class="nav-number">11.3.</span> <span class="nav-text">10.3 多值依赖与第四范式（4NF）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B6%E4%BB%96%E9%AB%98%E7%BA%A7%E8%8C%83%E5%BC%8Fbcnf%E7%AD%89"><span class="nav-number">11.4.</span> <span class="nav-text">10.4 其他高级范式（BCNF等）</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="jiejiejiang"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">jiejiejiang</p>
  <div class="site-description" itemprop="description">现在开始，还来得及</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">6</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>


<!-- CloudCalendar -->
<div class="widget-wrap" style="width: 90%;margin-left: auto;margin-right: auto; opacity: 0.97;">
	<div class="widget" id="CloudCalendar"></div>
</div>
      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">jiejiejiang</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">52k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">3:07</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
          load: ['[tex]/mhchem'],
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        displayMath: {'[+]': [['$$', '$$']]},
          packages: {'[+]': ['mhchem']},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  
<!-- calendar widget -->

<script src="https://cdn.jsdelivr.net/npm/darkmode-js@1.5.7/lib/darkmode-js.min.js"></script>

<script>
var options = {
  bottom: '64px',
  right: 'unset',
  left: '32px',
  time: '0.5s',
  mixColor: 'transparent',
  backgroundColor: 'transparent',
  buttonColorDark: '#100f2c',
  buttonColorLight: '#fff',
  saveInCookies: true,
  label: '🌓',
  autoMatchOsTheme: true
}
const darkmode = new Darkmode(options);
window.darkmode = darkmode;
darkmode.showWidget();
</script>


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'nS57E3JRn6eYspCCr9pXSVn5-gzGzoHsz',
      appKey     : 'L8rQJuf9mDfJkhZvlLa9UhPq',
      placeholder: "Just go go",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : true,
      lang       : 'zh-cn' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>


  <!-- calendar widget -->


</body>
</html>
