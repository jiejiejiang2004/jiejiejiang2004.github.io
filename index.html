<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 8.1.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">



<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"jiejiejiang2004.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":true,"preload":true},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="现在开始，还来得及">
<meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="https://jiejiejiang2004.github.io/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="现在开始，还来得及">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="jiejiejiang">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://jiejiejiang2004.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Hexo</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}.beian img{display:inline-block!important}</style></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hexo</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-schedule">

    <a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>日程表</a>

  </li>
        <li class="menu-item menu-item-sitemap">

    <a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>站点地图</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://jiejiejiang2004.github.io/2025/10/29/top/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="jiejiejiang">
      <meta itemprop="description" content="现在开始，还来得及">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/10/29/top/" class="post-title-link" itemprop="url">现在开始，还来得及</a>
        </h2>

        <div class="post-meta">

          
            <i class="fa fa-thumb-tack"></i>
            <font color=7D26CD>置顶</font>
            <span class="post-meta-divider">|</span>
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-10-29 00:00:00" itemprop="dateCreated datePublished" datetime="2025-10-29T00:00:00+08:00">2025-10-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-10-30 23:41:19" itemprop="dateModified" datetime="2025-10-30T23:41:19+08:00">2025-10-30</time>
              </span>

          
            <span id="/2025/10/29/top/" class="post-meta-item leancloud_visitors" data-flag-title="现在开始，还来得及" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2025/10/29/top/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2025/10/29/top/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>76</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>2025-10-29 23:12:17 </strong></p>
<p>今天花了一天，用hexo模板搭了个简单的博客。</p>
<p>只是做了一件，想做很久，很久以前就应该做的事情。</p>
<p>其实这个博客还有很多地方没有完善</p>
<p>能力有限，夜深了，明天再做吧</p>
<p>in queue…</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2025/10/29/top/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://jiejiejiang2004.github.io/2025/11/23/%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%88MySQL%EF%BC%89%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="jiejiejiang">
      <meta itemprop="description" content="现在开始，还来得及">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/11/23/%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%88MySQL%EF%BC%89%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/" class="post-title-link" itemprop="url">数据库（MySQL）知识整理（更新ing）</a>
        </h2>

        <div class="post-meta">

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-11-23 00:00:00" itemprop="dateCreated datePublished" datetime="2025-11-23T00:00:00+08:00">2025-11-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-11-24 18:17:11" itemprop="dateModified" datetime="2025-11-24T18:17:11+08:00">2025-11-24</time>
              </span>

          
            <span id="/2025/11/23/%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%88MySQL%EF%BC%89%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/" class="post-meta-item leancloud_visitors" data-flag-title="数据库（MySQL）知识整理（更新ing）" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2025/11/23/%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%88MySQL%EF%BC%89%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2025/11/23/%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%88MySQL%EF%BC%89%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>21k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1:17</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="学习须知warning">学习须知（Warning）</h1>
<ul>
<li>学习建议：先理解基础理论→再练实操→最后深化进阶内容</li>
<li>环境说明：MySQL版本选择、环境搭建基础要求</li>
</ul>
<h1 id="数据库基础理论">数据库基础理论</h1>
<h2 id="数据库设计核心">数据库设计核心</h2>
<h3 id="e-r模型实体-关系模型">E-R模型（实体-关系模型）</h3>
<h4 id="基本概念">基本概念</h4>
<ul>
<li><strong>实体</strong>：能独立存在、有自己属性的对象，比如 “员工”“部门”“客户”“商品”。 每个实体都有 “唯一标识”（比如员工的 “工号”、商品的 “商品 ID”），后续会变成表的 “主键”。</li>
<li><strong>属性</strong>：实体拥有的具体信息，比如 “员工” 的姓名、工号、薪资、入职时间。 属性不能再拆成更小的 “有意义单位”（比如 “地址” 如果拆成 “省 + 市 + 区”，那 “省”“市”“区” 才是属性，原 “地址” 不是）。</li>
<li><strong>关系</strong>：不同实体之间的业务联系，比如 “员工属于部门”“学生选课程”，关系也有自己的 “类型”。| 常见关系类型（用 “一方”“多方” 理解，避免复杂术语）：
<ul>
<li>一对一：两个实体 “一一对应”，比如 “员工” 和 “工牌”（一个员工只有一个工牌，一个工牌只属于一个员工）；</li>
<li>一对多：一个实体对应多个另一个实体，比如 “部门” 和 “员工”（一个部门有多个员工，一个员工只属于一个部门）—— 最常见的关系；</li>
<li>多对多：两个实体 “互相对应多个”，比如 “学生” 和 “课程”（一个学生选多门课，一门课有多个学生）。</li>
</ul></li>
</ul>
<h4 id="e-r图">E-R图</h4>
<h3 id="关系数据库规范化入门">关系数据库规范化入门</h3>
<ul>
<li>为什么需要规范化（避免数据冗余）</li>
<li>函数依赖基础（简单理解“字段间的关联关系”）</li>
<li>核心范式（重点：第一范式1NF、第二范式2NF、第三范式3NF）
<ul>
<li>1NF：原子性（字段不可拆分）</li>
<li>2NF：消除部分依赖（基于主键的完全依赖）</li>
<li>3NF：消除传递依赖（不依赖非主键的冗余字段）</li>
</ul></li>
</ul>
<h1 id="核心术语解析">核心术语解析</h1>
<ul>
<li>数据库、表、字段、记录、主键、外键、索引等基础术语</li>
<li>SQL语句分类（DQL查询、DML操作、DDL定义、DCL控制）</li>
</ul>
<h1 id="数据库基础操作">数据库基础操作</h1>
<ul>
<li>查看数据库/表：<code>SHOW DATABASES</code>/<code>SHOW TABLES</code></li>
<li>查看表结构：<code>SHOW COLUMNS FROM 表名</code>/<code>DESCRIBE 表名</code></li>
<li>查看状态/权限：<code>SHOW STATUS</code>/<code>SHOW GRANTS FOR 用户</code></li>
<li>切换数据库：<code>USE 数据库名</code></li>
</ul>
<h1 id="数据查询select语句">数据查询：SELECT语句</h1>
<h2 id="select-基本格式">SELECT 基本格式</h2>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT 数据库.列1, 数据库.列2</span><br><span class="line">FROM 数据库;</span><br></pre></td></tr></table></figure>
<p>特殊的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT *</span><br><span class="line">FROM 数据库;</span><br></pre></td></tr></table></figure>
<p>表示查询该数据库的所有列</p>
<h2 id="distinct-关键字结果去重">DISTINCT 关键字（结果去重）</h2>
<p>如果想要每个值只出现一次，可以使用 DISTINCT 关键字，使用方法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT DISTINCT 数据库.列1, 数据库.列2</span><br><span class="line">FROM 数据库;</span><br></pre></td></tr></table></figure>
<p><strong>注意！DISTINCT 关键字无法应用于部分列，只能用用于你查询的所有列！</strong></p>
<h2 id="limit关键字分页基础限制结果行数">LIMIT关键字（分页基础）（限制结果行数）</h2>
<p>如果想要限制输出的结果的行数，那么我们可以使用 LIMIT 关键字，使用方法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT 数据库.列1, 数据库.列2</span><br><span class="line">FROM 数据库</span><br><span class="line">LIMIT 5;</span><br></pre></td></tr></table></figure>
<p>以上代码表示输出行数不超过 5 行</p>
<h2 id="order-by子句结果排序升序asc降序desc">ORDER BY子句（结果排序）（升序ASC/降序DESC）</h2>
<blockquote>
<p>其实，检索出的数据并不是以纯粹的随机顺序显示的。如果不排序，数据一般将以它在底层表中出现的顺序显示。 ——《MySQL必知必会》</p>
</blockquote>
<p>因此，为了确保我们想得到的结果按顺序输出，我们可以用 ORDER BY 字句，使用方法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT 数据库.列1, 数据库.列2</span><br><span class="line">FROM 数据库</span><br><span class="line">ORDER BY 数据库.列1</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT 数据库.列1, 数据库.列2</span><br><span class="line">FROM 数据库</span><br><span class="line">ORDER BY 数据库.列1 DESC, 数据库.列2</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong></p>
<ol type="1">
<li>ORDER BY 默认升序排序（隐藏关键字：ASC）；</li>
<li>如果想在多个列上进行降序排序，必须对每个列指定 DESC 关键字。</li>
</ol>
<p><strong>注意：</strong></p>
<blockquote>
<p>在给出 ORDER BY 子句时，应该保证它位于 FROM 子句之后。如果使用 LIMIT ，它必须位于 ORDER BY 之后。使用子句的次序不对将产生错误消息。——《MySQL必知必会》</p>
</blockquote>
<h2 id="where子句数据筛选">WHERE子句（数据筛选）</h2>
<p>因为当我们查询数据的时候，我们往往只需要符合我们要求的部分数据，而不是所有数据，因此我们需要对数据进行过滤。</p>
<p>对数据进行过滤，我们一般使用 WHERE 子句，使用方法如下（例）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT 数据库.列1, 数据库.列2</span><br><span class="line">FROM 数据库</span><br><span class="line">WHERE 数据库.列1 = XXX</span><br></pre></td></tr></table></figure>
<p><em>注：这里的 XXX 指代数据内容</em></p>
<p>以上就是筛选出了 数据库.列1 的内容为 XXX 时的 数据库.列1 和 数据库.列2</p>
<h3 id="基础操作符">基础操作符</h3>
<table>
<thead>
<tr class="header">
<th>操作符</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>=</td>
<td>等于</td>
</tr>
<tr class="even">
<td>&lt;&gt;</td>
<td>不等于</td>
</tr>
<tr class="odd">
<td>!=</td>
<td>不等于</td>
</tr>
<tr class="even">
<td>&lt;</td>
<td>小于</td>
</tr>
<tr class="odd">
<td>&lt;=</td>
<td>小于等于</td>
</tr>
<tr class="even">
<td>&gt;</td>
<td>大于</td>
</tr>
<tr class="odd">
<td>&gt;=</td>
<td>大于等于</td>
</tr>
<tr class="even">
<td>BETWEEN</td>
<td>在指定的两个值之间</td>
</tr>
</tbody>
</table>
<h3 id="空值检查is-nullis-not-null">空值检查：<code>IS NULL</code>/<code>IS NOT NULL</code></h3>
<p>如果要检查某一列是否为 NULL，可以这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WHERE col IS NULL</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WHERE col IS NOT NULL</span><br></pre></td></tr></table></figure>
<h3 id="逻辑操作符andorinnot">逻辑操作符（AND/OR/IN/NOT）</h3>
<table>
<thead>
<tr class="header">
<th>操作符</th>
<th>核心逻辑</th>
<th>适用场景</th>
<th>注意事项</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>AND</td>
<td>同时满足多个条件</td>
<td>多条件必须同时成立</td>
<td>优先级高于 OR，混用需加括号</td>
</tr>
<tr class="even">
<td>OR</td>
<td>满足任意一个条件</td>
<td>多条件任选其一</td>
<td>优先级低于 AND，避免单独使用复杂逻辑</td>
</tr>
<tr class="odd">
<td>IN</td>
<td>匹配多个指定值中的任意一个</td>
<td>替代多个 OR，简化条件</td>
<td>列表值需类型一致，字符串加单引号</td>
</tr>
<tr class="even">
<td>NOT</td>
<td>否定其后的条件</td>
<td>筛选“不满足某条件”的记录</td>
<td>仅否定紧跟的条件，可与多种操作符结合</td>
</tr>
</tbody>
</table>
<h4 id="and-操作符">AND 操作符</h4>
<p>作用：筛选同时满足所有指定条件的记录（逻辑“与”），多个条件需全部成立才会被匹配。</p>
<p>用法示例：假设员工表 <code>employees</code> 新增字段 <code>department</code>（部门）、<code>salary</code>（薪资），数据如下：</p>
<table>
<thead>
<tr class="header">
<th>employee_id</th>
<th>name</th>
<th>department</th>
<th>salary</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>张三</td>
<td>技术部</td>
<td>6000</td>
</tr>
<tr class="even">
<td>2</td>
<td>李四</td>
<td>市场部</td>
<td>4500</td>
</tr>
<tr class="odd">
<td>3</td>
<td>王五</td>
<td>技术部</td>
<td>5500</td>
</tr>
<tr class="even">
<td>4</td>
<td>赵六</td>
<td>人事部</td>
<td>5000</td>
</tr>
</tbody>
</table>
<p>需求：查询“技术部且薪资大于 5000 元”的员工（同时满足两个条件）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM employees</span><br><span class="line">WHERE department = &#x27;技术部&#x27; AND salary &gt; 5000;</span><br></pre></td></tr></table></figure>
<p>结果返回 张三（6000 元）、王五（5500 元），只有同时符合“技术部”和“薪资&gt;5000”才会被筛选。</p>
<p>注意：AND 可连接任意多个条件，所有条件必须同时成立。</p>
<h4 id="or-操作符">OR 操作符</h4>
<p>作用：筛选满足任意一个指定条件的记录（逻辑“或”），只要有一个条件成立就会被匹配。</p>
<p>用法示例：查询“市场部 或 薪资大于 5500 元”的员工（满足一个条件即可）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM employees</span><br><span class="line">WHERE department = &#x27;市场部&#x27; OR salary &gt; 5500;</span><br></pre></td></tr></table></figure>
<p>结果返回 张三（薪资 6000&gt;5500）、李四（市场部），两者满足其一即匹配。</p>
<p>注意：OR 连接的条件是“任选其一”，无需全部满足；但需注意与 AND 混用的优先级问题（下文详解）。</p>
<h4 id="and-与-or-的运行顺序">AND 与 OR 的运行顺序</h4>
<p>核心规则：AND 的优先级高于 OR，数据库会先解析 AND 连接的条件，再解析 OR 连接的条件。</p>
<p>易错示例（未加括号）： 需求：查询“技术部且薪资&gt;5000” 或 “市场部且薪资&gt;4000”的员工，若直接写：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-- 错误写法：逻辑被优先级打乱</span><br><span class="line">SELECT * FROM employees</span><br><span class="line">WHERE department = &#x27;技术部&#x27; AND salary &gt; 5000 OR department = &#x27;市场部&#x27; AND salary &gt; 4000;</span><br></pre></td></tr></table></figure>
<p>数据库解析顺序：先执行两个 AND 条件（<code>技术部+薪资&gt;5000</code>、<code>市场部+薪资&gt;4000</code>），再用 OR 连接结果，这个例子恰好结果正确，但下面的情况会出错：</p>
<p>反例（未加括号导致逻辑错误）： 需求：查询“（技术部 或 市场部）且薪资&gt;5000”的员工，若漏写括号：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-- 错误写法：优先级导致逻辑偏离</span><br><span class="line">SELECT * FROM employees</span><br><span class="line">WHERE department = &#x27;技术部&#x27; OR department = &#x27;市场部&#x27; AND salary &gt; 5000;</span><br></pre></td></tr></table></figure>
<p>数据库解析为：<code>技术部</code> 或 <code>（市场部 且 薪资&gt;5000）</code>，结果会返回 张三（技术部）、王五（技术部）、无市场部员工（李四薪资 4500&lt;5000），但实际需求是“技术部/市场部中薪资&gt;5000的”，正确结果应只有张三、王五（市场部无符合薪资的），虽结果巧合一致，但逻辑是错的，换个数据就会出问题。</p>
<p>正确写法（加括号明确优先级）： 用括号 <code>()</code> 强制改变执行顺序，先解析括号内的 OR 条件，再解析 AND 条件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM employees</span><br><span class="line">WHERE (department = &#x27;技术部&#x27; OR department = &#x27;市场部&#x27;) AND salary &gt; 5000;</span><br></pre></td></tr></table></figure>
<p>解析顺序：先确定“技术部或市场部”的员工（张三、李四、王五），再筛选其中“薪资&gt;5000”的（张三、王五），完全符合需求。</p>
<p>注意：当 AND 和 OR 同时出现时，务必用括号明确逻辑分组，避免因优先级导致结果错误。</p>
<h4 id="in-操作符">IN 操作符</h4>
<p>作用：筛选“字段值匹配多个指定值中的任意一个”的记录，等价于多个 OR 条件的组合，但更简洁、可读性更高。</p>
<p>用法示例：查询“部门为技术部、市场部、人事部”的员工（匹配多个部门中的任意一个）：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 用 IN 实现（简洁）</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> department <span class="keyword">IN</span> (<span class="string">&#x27;技术部&#x27;</span>, <span class="string">&#x27;市场部&#x27;</span>, <span class="string">&#x27;人事部&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 等价于 OR 写法（繁琐，多个值时易出错）</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> department <span class="operator">=</span> <span class="string">&#x27;技术部&#x27;</span> <span class="keyword">OR</span> department <span class="operator">=</span> <span class="string">&#x27;市场部&#x27;</span> <span class="keyword">OR</span> department <span class="operator">=</span> <span class="string">&#x27;人事部&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>两种写法结果一致，均返回所有员工（因示例中只有这三个部门）。</p>
<p>IN 操作符的优势在于：</p>
<ul>
<li>比多个 OR 更高效（数据库优化器对 IN 的处理更优）。</li>
<li>实际在项目场景下， 我们要筛选的字段值往往从另一个查询中得到，而 IN 操作符支持子查询；</li>
</ul>
<p><strong>注意</strong>：IN 列表中的值需用逗号分隔，字符串需加单引号（<code>' '</code>）。</p>
<h4 id="not-操作符">NOT 操作符</h4>
<p>作用：否定其后的条件（逻辑“非”），筛选不满足指定条件的记录，可与 IN、BETWEEN、IS NULL 等结合使用。</p>
<p>用法示例：</p>
<ol type="1">
<li>与 IN 结合：查询“部门不在技术部、市场部”的员工：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM employees</span><br><span class="line">WHERE department NOT IN (&#x27;技术部&#x27;, &#x27;市场部&#x27;);</span><br></pre></td></tr></table></figure>
<p>结果返回 赵六（人事部）。</p>
<ol start="2" type="1">
<li>与 BETWEEN 结合：查询“薪资不在 4000-5500 元之间”的员工：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM employees</span><br><span class="line">WHERE salary NOT BETWEEN 4000 AND 5500;</span><br></pre></td></tr></table></figure>
<p>结果返回 张三（6000 元，高于 5500）。</p>
<ol start="3" type="1">
<li>与 IS NULL 结合：查询“邮箱不为空（IS NOT NULL）”的员工（补充之前的空值检查）：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM employees</span><br><span class="line">WHERE email NOT IS NULL; -- 等价于 WHERE email IS NOT NULL，两种写法均可</span><br></pre></td></tr></table></figure>
<p>结果返回邮箱字段有明确值的员工。</p>
<p>注意：</p>
<ul>
<li>NOT 仅否定紧跟其后的一个条件（若需否定多个条件，需结合括号）；</li>
<li>与 IN 结合时，<code>NOT IN</code> 会排除所有匹配 IN 列表的值，包括 NULL（若 IN 列表中有 NULL，<code>NOT IN</code> 可能返回空结果，需避免）。</li>
</ul>
<h3 id="like与通配符_模糊查询">LIKE与通配符（%\\_）(模糊查询)</h3>
<h4 id="like-操作符">LIKE 操作符</h4>
<p>作用：结合通配符实现<strong>模糊查询</strong>，筛选“部分符合字符串格式”的记录（无需精准匹配完整字符串），适用于字符串类型字段（如姓名、邮箱、部门名等），支持 <code>%</code> 和 <code>_</code> 两种核心通配符，且可通过转义符匹配实际存在的通配符字符。 <strong>具体使用方法如下 ↓</strong></p>
<table>
<thead>
<tr class="header">
<th>通配符</th>
<th>核心作用</th>
<th>适用场景</th>
<th>注意事项</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>%</code></td>
<td>匹配任意数量的任意字符（含 0 个）</td>
<td>开头/结尾/包含匹配、长度不固定场景</td>
<td>开头使用可能影响索引效率</td>
</tr>
<tr class="even">
<td><code>_</code></td>
<td>匹配单个任意字符</td>
<td>固定长度、特定位置字符匹配</td>
<td>严格匹配 1 个字符，不能多也不能少</td>
</tr>
<tr class="odd">
<td>转义符</td>
<td>匹配实际的 <code>%</code> 或 <code>_</code></td>
<td>字符串中包含通配符字符的场景</td>
<td>默认用 <code>\</code>，可通过 <code>ESCAPE</code> 自定义</td>
</tr>
</tbody>
</table>
<h4 id="百分号通配符">百分号（%）通配符</h4>
<p>作用：匹配<strong>任意数量的任意字符</strong>（包括 <span class="math inline">0</span> 个字符，即空字符串），是 <code>LIKE</code> 中最常用的通配符，可放在字符串开头、中间或结尾。</p>
<p>用法示例（基于 <code>employees</code> 表的 <code>name</code>（姓名）、<code>email</code>（邮箱）字段）：</p>
<ol type="1">
<li>开头匹配：查询“名字以‘张’开头”的员工</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM employees</span><br><span class="line">WHERE name LIKE &#x27;张%&#x27;;</span><br></pre></td></tr></table></figure>
<p>结果返回 张三（姓名为“张三”），若存在“张伟明”“张丽”等名字以“张”开头的员工，也会被匹配。</p>
<ol start="2" type="1">
<li>结尾匹配：查询“邮箱以‘<span class="citation" data-cites="qq.com">@qq.com</span>’结尾”的员工</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM employees</span><br><span class="line">WHERE email LIKE &#x27;%@qq.com&#x27;;</span><br></pre></td></tr></table></figure>
<p>结果返回所有邮箱后缀为“<span class="citation" data-cites="qq.com">@qq.com</span>”的员工，无论邮箱前缀长度如何。</p>
<ol start="3" type="1">
<li>包含匹配：查询“姓名中包含‘三’字”的员工</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM employees</span><br><span class="line">WHERE name LIKE &#x27;%三%&#x27;;</span><br></pre></td></tr></table></figure>
<p>结果返回 张三（姓名含“三”），若存在“李三丰”“王三”等员工，也会被匹配。</p>
<ol start="4" type="1">
<li>匹配空字符串：查询“部门字段为空字符串”的员工（<strong>注意</strong>：空字符串 <code>''</code> 不同于 NULL）</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM employees</span><br><span class="line">WHERE department LIKE &#x27;&#x27;;</span><br></pre></td></tr></table></figure>
<p>结果返回部门字段填写为空字符串的员工，NULL 不会被匹配（NULL 需用 <code>IS NULL</code> 判断）。</p>
<p>注意事项：</p>
<ul>
<li><code>%</code> 放在字符串<strong>开头</strong>时（如 <code>'%三%'</code>），MySQL 无法使用字段索引，大表查询时效率较低，尽量将 <code>%</code> 放在结尾（如 <code>'张%'</code>）以利用索引；</li>
<li><code>%</code> 可匹配任意字符，包括数字、字母、符号、空格等，无字符类型限制；</li>
<li><strong>!!!!!</strong> 若需匹配“字段值为空”，需区分“空字符串”（<code>LIKE ''</code>）和“NULL”（<code>IS NULL</code>），<code>%</code> 无法匹配 NULL。</li>
</ul>
<h4 id="下划线_通配符">下划线（_）通配符</h4>
<p>作用：匹配<strong>单个任意字符</strong>（严格占 1 个字符位置，不能多也不能少），适用于明确字符串长度或特定位置字符的匹配场景。</p>
<p>用法示例：</p>
<ol type="1">
<li>固定长度匹配：查询“姓名为 2 个字符且以‘张’开头”的员工</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM employees</span><br><span class="line">WHERE name LIKE &#x27;张_&#x27;;</span><br></pre></td></tr></table></figure>
<p>结果返回 张三（姓名为 2 字符，以“张”开头），若存在“张丽”“张涛”等 2 字符姓名员工也会被匹配，但“张伟明”（3 字符）不会被匹配。</p>
<ol start="2" type="1">
<li>特定位置匹配：查询“手机号为 11 位数字且第 4-5 位为‘86’”的员工（假设 <code>phone</code> 为字符串类型）</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM employees</span><br><span class="line">WHERE phone LIKE &#x27;___86______&#x27;;</span><br></pre></td></tr></table></figure>
<p>解析：<code>___</code> 匹配前 3 位任意数字，<code>86</code> 是固定字符，<code>______</code> 匹配后 6 位任意数字，整体严格匹配 11 位手机号，且第 4-5 位为“86”。</p>
<ol start="3" type="1">
<li>组合匹配：查询“邮箱前缀为 3 个字符，且后缀为‘<span class="citation" data-cites="qq.com">@qq.com</span>’”的员工</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM employees</span><br><span class="line">WHERE email LIKE &#x27;___@qq.com&#x27;;</span><br></pre></td></tr></table></figure>
<p>结果返回邮箱格式为“aaa@qq.com”“abc@qq.com”等前缀为 3 字符的员工。</p>
<p>注意事项：</p>
<ul>
<li><code>_</code> 仅匹配<strong>1 个字符</strong>，若需匹配 n 个字符，需写 n 个 <code>_</code>（如匹配 3 个字符需 <code>___</code>）；</li>
<li>无法匹配 0 个字符（空字符串），也无法匹配超过 1 个字符的内容，匹配长度严格限制；</li>
<li>与 <code>%</code> 不同，<code>_</code> 即使放在字符串开头，也可能利用索引（若字段有前缀索引），但效率仍低于精准匹配。</li>
</ul>
<h4 id="转义通配符">转义通配符</h4>
<p>默认情况下，<code>%</code> 和 <code>_</code> 是通配符，若需匹配字符串中<strong>实际存在的 <code>%</code> 或 <code>_</code> 字符</strong>（而非作为通配符使用），需用「转义符」处理，避免 MySQL 将其解析为通配符。</p>
<p>核心用法：</p>
<ol type="1">
<li>默认转义符（<code>\</code>）：在需匹配的 <code>%</code> 或 <code>_</code> 前加 <code>\</code>，表示该字符是普通字符而非通配符。</li>
<li>自定义转义符（<code>ESCAPE</code>）：若默认转义符 <code>\</code> 与业务字符冲突，可通过 <code>ESCAPE</code> 指定自定义转义符（如 <code>#</code>、<code>$</code> 等）。</li>
</ol>
<p>用法示例：</p>
<ol type="1">
<li>匹配含 <code>%</code> 的字符串：查询“备注字段包含‘5%’（如‘折扣 5%’）”的员工</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-- 默认转义符 \</span><br><span class="line">SELECT * FROM employees</span><br><span class="line">WHERE remark LIKE &#x27;%5\%&#x27;;</span><br></pre></td></tr></table></figure>
<p>结果返回备注中包含“5%”的员工，<code>\%</code> 表示匹配实际的 <code>%</code> 字符，而非通配符。</p>
<ol start="2" type="1">
<li>匹配含 <code>_</code> 的字符串：查询“用户名包含‘a_b’（如‘user_a_b’）”的员工</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-- 默认转义符 \</span><br><span class="line">SELECT * FROM employees</span><br><span class="line">WHERE username LIKE &#x27;%a\_b%&#x27;;</span><br></pre></td></tr></table></figure>
<p>结果返回用户名中包含“a_b”的员工，<code>\_</code> 表示匹配实际的 <code>_</code> 字符，而非通配符。</p>
<ol start="3" type="1">
<li>自定义转义符：查询“备注包含‘8%’”的员工，用 <code>#</code> 作为转义符</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM employees</span><br><span class="line">WHERE remark LIKE &#x27;%8#%&#x27; ESCAPE &#x27;#&#x27;;</span><br></pre></td></tr></table></figure>
<p>解析：<code>ESCAPE '#'</code> 声明 <code>#</code> 为转义符，<code>#%</code> 表示匹配实际的 <code>%</code> 字符，效果与 <code>\%</code> 一致。</p>
<p>注意事项：</p>
<ul>
<li>转义符仅对紧跟其后的 1 个字符生效，若需匹配多个 <code>%</code> 或 <code>_</code>，需逐个转义（如匹配“5%_”需写 <code>5\%\_</code>）；</li>
<li>自定义转义符需选择业务中不常用的字符（如 <code>#</code>、<code>&amp;</code>），避免与字符串中的普通字符冲突；</li>
<li>若未转义直接写 <code>LIKE '%5%%'</code>，MySQL 会将第二个 <code>%</code> 解析为通配符，导致匹配“包含‘5’且后面任意字符”的结果，而非“包含‘5%’”。</li>
</ul>
<h3 id="regexp正则表达式复杂匹配">REGEXP（正则表达式）(复杂匹配)</h3>
<p>REGEXP（或 RLIKE，两者完全等价）用于<strong>复杂模糊匹配</strong>，功能比 LIKE 更灵活，支持按“模式”筛选字符串，其作用是匹配文本，将一个模式（正则表达式）与一个文本串进行比较。需配合 WHERE 子句使用，只要该字段里包含这一段内容，就会被匹配到。</p>
<p><strong>注意！！！</strong></p>
<ul>
<li>MySQL中的正则表达式匹配不区分大小写（即，大写和小写都匹配）。为区分大小写，可使用BINARY关键字，如<code>WHERE prod_name REGEXP BINARY 'JetPack .000'</code>。</li>
</ul>
<h4 id="使用-.-匹配单个任意字符">使用 . 匹配单个任意字符</h4>
<p>作用：匹配<strong>1个任意字符</strong>（包括字母、数字、符号、空格），等价于 LIKE 操作符的 <code>_</code>，但可与其他正则规则组合使用。</p>
<p>用法示例（基于 <code>employees</code> 表 <code>name</code> 字段）： 需求：查询“姓名为2个字符且以‘张’开头”的员工：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM employees</span><br><span class="line">WHERE name REGEXP &#x27;^张.$&#x27;;</span><br></pre></td></tr></table></figure>
<p>结果返回 张三（姓名为“张三”，<code>张</code> 后紧跟1个字符）；若存在“张丽”“张涛”等2字姓名员工，也会被匹配（`.’ 匹配第2个任意字符）。</p>
<p>补充示例：查询“邮箱前缀为任意字符，中间包含‘xxx’”的员工：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM employees</span><br><span class="line">WHERE email REGEXP &#x27;.xxx.&#x27;;</span><br></pre></td></tr></table></figure>
<p>解析：<code>.' 匹配前缀任意1个字符，</code>xxx<code>是固定字符，最后一个</code>.’ 匹配后缀任意1个字符，整体匹配“包含‘xxx’且前后至少各有1个字符”的邮箱。</p>
<h4 id="使用-匹配多个模式逻辑或">使用 | 匹配多个模式（逻辑“或”）</h4>
<p>作用：匹配<strong>多个指定模式中的任意一个</strong>，等价于 OR 条件，适合同时筛选多种符合规则的结果，比多个 OR 更简洁。</p>
<p>用法示例（基于 <code>employees</code> 表 <code>department</code> 字段）： 需求：查询“部门为技术部或市场部”的员工：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM employees</span><br><span class="line">WHERE department REGEXP &#x27;技术部|市场部&#x27;;</span><br></pre></td></tr></table></figure>
<p>结果返回 张三（技术部）、李四（市场部），匹配两个模式中的任意一个即可。</p>
<p>补充示例：查询“姓名包含‘张’或‘李’”的员工：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM employees</span><br><span class="line">WHERE name REGEXP &#x27;张|李&#x27;;</span><br></pre></td></tr></table></figure>
<p>结果返回 张三（含“张”）、若存在“李四”“李白”等含“李”的员工，也会被匹配。</p>
<p>注意：<code>|</code> 匹配的是“整个模式”，若需匹配“某字段开头为A或B”，需结合括号（如 <code>^(张|李)</code>），避免匹配错误。</p>
<h4 id="使用-匹配指定字符集中的任意一个">使用 [] 匹配指定字符集中的任意一个</h4>
<p>作用：匹配<strong>方括号内的任意一个字符</strong>（仅匹配 <span class="math inline">1</span> 个），可替代多个 <code>|</code>，简化字符匹配规则。</p>
<p>用法示例（基于 <code>employees</code> 表 <code>name</code> 字段）： 需求：查询“姓名首字为‘张’或‘李’”的员工：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM employees</span><br><span class="line">WHERE name REGEXP &#x27;^[张李]&#x27;;</span><br></pre></td></tr></table></figure>
<p>解析：<code>^</code> 是定位符（后文详解），表示“字符串开头”，<code>[张李]</code> 匹配开头为“张”或“李”的任意一个字符，结果返回 张三（首字“张”）、若存在“李四”（首字“李”）也会被匹配。</p>
<p>补充示例：查询“手机号第2位为3或5”的员工（假设 <code>phone</code> 为字符串类型）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM employees</span><br><span class="line">WHERE phone REGEXP &#x27;^1[35]&#x27;;</span><br></pre></td></tr></table></figure>
<p>解析：<code>^1</code> 表示手机号以1开头，<code>[35]</code> 匹配第2位为3或5，比如“138xxxx”“159xxxx”都会被匹配。</p>
<h4 id="使用---在-内定义字符范围">使用 - 在 [] 内定义字符范围</h4>
<p>作用：在 <code>[]</code> 内用 <code>-</code> 定义<strong>连续的字符范围</strong>，简化多个连续字符的匹配（如字母、数字范围），无需逐个列出字符。</p>
<p>用法示例：</p>
<ol type="1">
<li>匹配数字范围（基于 <code>employees</code> 表 <code>salary</code> 字段）： 需求：查询“薪资开头为5或6”的员工（薪资为数字类型，REGEXP 会自动转为字符串匹配）：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM employees</span><br><span class="line">WHERE salary REGEXP &#x27;^[5-6]&#x27;;</span><br></pre></td></tr></table></figure>
<p>结果返回 张三（6000）、王五（5500）、赵六（5000），<code>[5-6]</code> 匹配开头为5或6的数字。</p>
<ol start="2" type="1">
<li>匹配字母范围（基于 <code>employees</code> 表 <code>email</code> 字段）： 需求：查询“邮箱前缀包含小写字母a-f”的员工：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM employees</span><br><span class="line">WHERE email REGEXP &#x27;[a-f]&#x27;;</span><br></pre></td></tr></table></figure>
<p>结果返回邮箱中包含a、b、c、d、e、f任意一个小写字母的员工，<code>[a-f]</code> 表示a到f的连续小写字母。</p>
<ol start="3" type="1">
<li>组合范围：查询“姓名包含大写字母A-F或数字0-5”的员工：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM employees</span><br><span class="line">WHERE name REGEXP &#x27;[A-F0-5]&#x27;;</span><br></pre></td></tr></table></figure>
<p>解析：<code>[A-F0-5]</code> 同时匹配A-F的大写字母和0-5的数字，无需分开写 <code>[A-F]|[0-5]</code>。</p>
<h4 id="使用-匹配特殊字符转义">使用 <code>\\</code> 匹配特殊字符（转义）</h4>
<p>作用：正则表达式中部分字符（如 <code>.</code>、<code>*</code>、<code>+</code>、<code>?</code> 等）是“特殊元字符”，若需匹配这些字符本身（如邮箱中的 <code>.</code>、网址中的 <code>?</code>），需用 <code>\\</code> 转义（MySQL 中需双重反斜杠，第一层转义 MySQL 本身，第二层转义正则表达式）。</p>
<p>用法示例（基于 <code>employees</code> 表 <code>email</code> 字段）： 需求：查询“邮箱后缀为‘.com’”的员工（匹配实际的 <code>.</code> 字符）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM employees</span><br><span class="line">WHERE email REGEXP &#x27;\\.com$&#x27;;</span><br></pre></td></tr></table></figure>
<p>解析：<code>\\.</code> 转义后匹配实际的 <code>.</code> 字符（若直接写 <code>.</code>，会被解析为“匹配任意字符”），<code>$</code> 是定位符，表示“字符串结尾”，结果返回所有邮箱以 <code>.com</code> 结尾的员工。</p>
<p>补充示例：匹配包含 <code>*</code> 字符的备注（基于 <code>remark</code> 字段）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM employees</span><br><span class="line">WHERE remark REGEXP &#x27;\\*&#x27;;</span><br></pre></td></tr></table></figure>
<p>结果返回备注中包含 <code>*</code> 字符的员工（如“折扣*8折”），<code>\\*</code> 转义后匹配实际的 <code>*</code> 字符。</p>
<h4 id="匹配字符类预设常用字符集">匹配字符类（预设常用字符集）</h4>
<p>作用：正则提供预设的“字符类”（以 <code>[:xxx:]</code> 形式），简化常用字符集的书写（如数字、字母、空白字符等），需放在 <code>[]</code> 内使用。</p>
<p>用法示例（基于 <code>employees</code> 表相关字段）：</p>
<table>
<colgroup>
<col style="width: 9%" />
<col style="width: 45%" />
<col style="width: 45%" />
</colgroup>
<thead>
<tr class="header">
<th>字符类</th>
<th>示例SQL</th>
<th>结果说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>[:digit:]</code></td>
<td><code>SELECT * FROM employees WHERE phone REGEXP '^[:digit:]{11}$';</code></td>
<td><code>[:digit:]</code> 匹配任意数字，<code>{11}</code> 限制11位，仅返回11位纯数字手机号</td>
</tr>
<tr class="even">
<td><code>[:lower:]</code></td>
<td><code>SELECT * FROM employees WHERE name REGEXP '[:lower:]';</code></td>
<td>返回姓名中包含a-z任意小写字母的员工（如“Zhang三”）</td>
</tr>
<tr class="odd">
<td><code>[:upper:]</code></td>
<td><code>SELECT * FROM employees WHERE email REGEXP '[:upper:]';</code></td>
<td>返回邮箱中包含A-Z任意大写字母的员工（如“ZHANG@xxx.com”）</td>
</tr>
<tr class="even">
<td><code>[:space:]</code></td>
<td><code>SELECT * FROM employees WHERE remark REGEXP '[:space:]';</code></td>
<td>返回备注中包含空格、制表符等空白字符的员工（如“技术部 核心员工”）</td>
</tr>
<tr class="odd">
<td><code>[:alnum:]</code></td>
<td><code>SELECT * FROM employees WHERE username REGEXP '^[:alnum:]+$';</code></td>
<td><code>[:alnum:]</code> 匹配字母+数字，<code>+</code> 表示至少1个，仅返回纯字母数字的用户名</td>
</tr>
<tr class="even">
<td><code>[:alpha:]</code></td>
<td><code>SELECT * FROM employees WHERE username REGEXP '^[:alpha:]+$';</code></td>
<td><code>[:alpha:]</code> 匹配任意大小写字母（同<code>[a-zA-Z]</code>），仅返回纯字母用户名（如“Zhang”“Li”“WANG”），不匹配含数字/符号的用户名</td>
</tr>
<tr class="odd">
<td><code>[:blank:]</code></td>
<td><code>SELECT * FROM employees WHERE remark REGEXP '[:blank:]';</code></td>
<td><code>[:blank:]</code> 仅匹配空格（<code></code>）和制表符（<code>\t</code>），返回备注中含这两种字符的员工</td>
</tr>
<tr class="even">
<td><code>[:cntrl:]</code></td>
<td><code>SELECT * FROM employees WHERE remark REGEXP '[:cntrl:]';</code></td>
<td><code>[:cntrl:]</code> 匹配ASCII 0-31（如<code>\n</code>、<code>\r</code>）和127的控制字符（不可见），返回备注中含这类字符的员工</td>
</tr>
<tr class="odd">
<td><code>[:graph:]</code></td>
<td><code>SELECT * FROM employees WHERE username REGEXP '^[:graph:]+$';</code></td>
<td><code>[:graph:]</code> 匹配字母、数字、符号（无空格），仅返回无空格的可见字符用户名（如“Zhang123!”“Li_456”）</td>
</tr>
<tr class="even">
<td><code>[:print:]</code></td>
<td><code>SELECT * FROM employees WHERE remark REGEXP '^[:print:]*$';</code></td>
<td><code>[:print:]</code> 匹配所有可打印字符（字母、数字、符号、空格），不含控制字符，返回备注中无隐藏控制字符的员工</td>
</tr>
<tr class="odd">
<td><code>[:punct:]</code></td>
<td><code>SELECT * FROM employees WHERE username REGEXP '[:punct:]';</code></td>
<td><code>[:punct:]</code> 匹配标点符号（如<code>_</code>、<code>-</code>、<code>!</code>、<code>@</code>），返回用户名含这类符号的员工（如“Zhang_123”“Li-Min”）</td>
</tr>
<tr class="even">
<td><code>[:xdigit:]</code></td>
<td><code>SELECT * FROM employees WHERE device_no REGEXP '^[:xdigit:]{8}$';</code></td>
<td><code>[:xdigit:]</code> 匹配十六进制数字（0-9、a-f、A-F），<code>{8}</code> 限制8位，仅返回8位纯十六进制设备编号</td>
</tr>
</tbody>
</table>
<p>注意：字符类必须放在 <code>[]</code> 内（如 <code>[:digit:]</code> 等价于 <code>[0-9]</code>），单独使用无效。</p>
<h4 id="使用重复元字符匹配多个字符">使用重复元字符匹配多个字符</h4>
<p>作用：控制前一个字符/模式的匹配次数（如0次、1次、多次），无需重复书写相同规则，简化复杂匹配。</p>
<p>用法示例（基于 <code>employees</code> 表相关字段）：</p>
<table>
<colgroup>
<col style="width: 7%" />
<col style="width: 46%" />
<col style="width: 46%" />
</colgroup>
<thead>
<tr class="header">
<th>重复元字符</th>
<th>示例SQL（需求）</th>
<th>结果说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>*</code></td>
<td>查询姓名以“张”开头，后面可跟0个或多个字符的员工：<br><code>SELECT * FROM employees WHERE name REGEXP '^张.*';</code></td>
<td>返回“张”“张三”“张伟明”等（包括仅“张”的姓名）</td>
</tr>
<tr class="even">
<td><code>+</code></td>
<td>查询姓名以“张”开头，后面至少跟1个字符的员工：<br><code>SELECT * FROM employees WHERE name REGEXP '^张+';</code></td>
<td>返回“张三”“张伟明”（排除仅“张”的姓名），<code>+</code> 表示至少1次匹配</td>
</tr>
<tr class="odd">
<td><code>?</code></td>
<td>查询姓名为“张”或“张三”的员工：<br><code>SELECT * FROM employees WHERE name REGEXP '^张三?';</code></td>
<td><code>?</code> 匹配前一个字符“三”0次或1次，即匹配“张”或“张三”</td>
</tr>
<tr class="even">
<td><code>{n}</code></td>
<td>查询手机号为11位数字的员工：<br><code>SELECT * FROM employees WHERE phone REGEXP '^[0-9]{11}$';</code></td>
<td><code>{11}</code> 表示匹配前一个模式（数字）恰好11次，仅返回11位手机号</td>
</tr>
<tr class="odd">
<td><code>{n,}</code></td>
<td>查询姓名至少3个字符的员工：<br><code>SELECT * FROM employees WHERE name REGEXP '^.{3,}$';</code></td>
<td><code>{3,}</code> 表示匹配任意字符至少3次，返回3字及以上姓名（如“张伟明”）</td>
</tr>
<tr class="even">
<td><code>{n,m}</code></td>
<td>查询姓名为2-4个字符的员工：<br><code>SELECT * FROM employees WHERE name REGEXP '^.{2,4}$';</code></td>
<td><code>{2,4}</code> 表示匹配任意字符2-4次，返回2-4字姓名（如“张三”“张伟明”）</td>
</tr>
</tbody>
</table>
<h4 id="使用定位符匹配位置">使用定位符匹配位置</h4>
<p>作用：匹配“字符串的位置”（而非具体字符），如开头、结尾、单词边界，用于精准控制匹配的位置范围。</p>
<p>用法示例（基于 <code>employees</code> 表相关字段）：</p>
<table>
<colgroup>
<col style="width: 13%" />
<col style="width: 43%" />
<col style="width: 43%" />
</colgroup>
<thead>
<tr class="header">
<th>定位符</th>
<th>示例SQL（需求）</th>
<th>结果说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>^</code>（文本开头）</td>
<td>查询部门以“技术”开头的员工：<br><code>SELECT * FROM employees WHERE department REGEXP '^技术';</code></td>
<td>返回“技术部”（以“技术”开头），若存在“技术支持部”也会被匹配</td>
</tr>
<tr class="even">
<td><code>$</code>（文本结尾）</td>
<td>查询邮箱以“<span class="citation" data-cites="163.com">@163.com</span>”结尾的员工：<br><code>SELECT * FROM employees WHERE email REGEXP '@163.com$';</code></td>
<td>仅返回邮箱后缀为“<span class="citation" data-cites="163.com">@163.com</span>”的员工，避免匹配“xxx@163.com.cn”</td>
</tr>
<tr class="odd">
<td><code>[[:&lt;:]]</code>（词开头）</td>
<td>查询备注中包含“核心”单词（独立单词）的员工：<br><code>SELECT * FROM employees WHERE remark REGEXP '[[:&lt;:]]核心[[:&gt;:]]';</code></td>
<td>仅匹配“核心”作为独立单词（如“核心员工”），不匹配“非核心员工”“核心技术”（“核心”非独立单词）</td>
</tr>
<tr class="even">
<td><code>[[:&gt;:]]</code>（词结尾）</td>
<td>同上，配合 <code>[[:&lt;:]]</code> 实现独立单词匹配</td>
<td>-</td>
</tr>
</tbody>
</table>
<p>注意：<code>^</code> 和 <code>$</code> 匹配整个字符串的开头/结尾，<code>[[:&lt;:]]</code> 和 <code>[[:&gt;:]]</code> 匹配单词的开头/结尾（单词以空白字符或特殊符号分隔）。</p>
<h4 id="的双重用途">^ 的双重用途</h4>
<p>说明：<code>^</code> 是正则中唯一具有“双重含义”的元字符，含义由其位置决定：</p>
<ol type="1">
<li>当 <code>^</code> 在 <strong><code>[]</code> 外部</strong>时：作为定位符，匹配“整个字符串的开头”（如 3.5.5.8 中的示例）；</li>
<li>当 <code>^</code> 在 <strong><code>[]</code> 内部</strong>时：表示“否定字符集”，匹配“不在括号内的任意一个字符”。</li>
</ol>
<p>用法示例：</p>
<ol type="1">
<li><code>^</code> 在 <code>[]</code> 外部（定位符）： 需求：查询姓名以“王”开头的员工：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM employees</span><br><span class="line">WHERE name REGEXP &#x27;^王&#x27;;</span><br></pre></td></tr></table></figure>
<p>结果返回姓名以“王”开头的员工（如“王五”）。</p>
<ol start="2" type="1">
<li><code>^</code> 在 <code>[]</code> 内部（否定字符集）： 需求：查询姓名首字<strong>不是</strong>“张”“李”“王”的员工：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM employees</span><br><span class="line">WHERE name REGEXP &#x27;^[^张李王]&#x27;;</span><br></pre></td></tr></table></figure>
<p>解析：<code>^</code> 表示字符串开头，<code>[^张李王]</code> 表示“首字不在张、李、王中的任意一个字符”，结果返回 赵六（首字“赵”）。</p>
<p>补充示例：查询手机号<strong>不含</strong>数字3的员工：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM employees</span><br><span class="line">WHERE phone REGEXP &#x27;[^3]&#x27;;</span><br></pre></td></tr></table></figure>
<p>结果返回手机号中没有数字3的员工，<code>[^3]</code> 匹配任意不是3的字符。</p>
<p>注意：<code>[^...]</code> 仅否定括号内的字符集，仍匹配1个任意字符，并非“不包含该字符集”（若需“不包含某字符”，需结合重复元字符，如 <code>^[^3]*$</code> 表示整个字符串不含3）。</p>
<h2 id="创建计算字段">创建计算字段</h2>
<ul>
<li>概念： 计算字段：是<strong>查询时通过函数运算、字符串拼接等方式动态生成的字段</strong>。 这些字段不存在于原表中，仅在查询结果中临时显示，不会修改数据库的原始数据。核心作用是 “按需加工数据”，让查询结果更贴合实际需求（比如拼接名称、计算数值、清理无效空格）。</li>
</ul>
<h3 id="concat函数拼接字段"><code>CONCAT()</code>函数（拼接字段）</h3>
<p>将<strong>多个字符串、字段值拼接成一个完整字符串</strong>，支持同时拼接 “字段 + 固定文本”“字段 + 字段”，灵活组合数据。</p>
<p><strong>注意</strong>：若拼接的字段 / 值中包含 <code>NULL</code>，整个拼接结果会返回 <code>NULL</code>（可改用 <code>CONCAT_WS()</code> 函数避免，下文补充）。</p>
<h4 id="语法格式">语法格式</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CONCAT(字段1/字符串1, 字段2/字符串2, ...)</span><br></pre></td></tr></table></figure>
<h4 id="实操示例基于-employees-表">实操示例（基于 <code>employees</code> 表）</h4>
<h5 id="示例-1拼接-姓名-部门字段-固定文本-字段">示例 1：拼接 “姓名 + 部门”（字段 + 固定文本 + 字段）</h5>
<p>需求：查询员工的 “姓名 - 所属部门” 组合信息，比如 “张三 - 技术部”：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT </span><br><span class="line">  name,</span><br><span class="line">  department,</span><br><span class="line">  CONCAT(name, &#x27;-&#x27;, department) AS 员工部门信息  -- 拼接姓名、固定字符“-”、部门</span><br><span class="line">FROM employees;</span><br></pre></td></tr></table></figure>
<p>结果说明：返回 3 列 —— 原有的<code>name</code>（姓名）、<code>department</code>（部门），以及动态生成的<code>员工部门信息</code>（拼接结果）。</p>
<h5 id="示例-2拼接-姓名-邮箱后缀字段-固定文本">示例 2：拼接 “姓名 + 邮箱后缀”（字段 + 固定文本）</h5>
<p>需求：给没有邮箱的员工生成默认邮箱（姓名小写 +@<a target="_blank" rel="noopener" href="https://company.com/">company.com</a>）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT </span><br><span class="line">  name,</span><br><span class="line">  CONCAT(LOWER(name), &#x27;@company.com&#x27;) AS default_email  -- 结合LOWER()函数转小写</span><br><span class="line">FROM employees;</span><br></pre></td></tr></table></figure>
<p>结果说明：若姓名为 “张三”，则生成默认邮箱 “zhangsan@company.com”（需配合文本函数使用，更灵活）。</p>
<h4 id="补充concat_ws-避免-null-问题">补充：<code>CONCAT_WS()</code> 避免 <code>NULL</code> 问题</h4>
<p>若拼接字段可能为 <code>NULL</code>（比如部分员工没有备注），用 <code>CONCAT_WS(分隔符, 字段1, 字段2...)</code> 会自动忽略 <code>NULL</code>，仅拼接非空内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 拼接“姓名-部门-备注”，备注为NULL时仅显示“姓名-部门”</span><br><span class="line">SELECT </span><br><span class="line">  CONCAT_WS(&#x27;-&#x27;, name, department, remark) AS 员工完整信息</span><br><span class="line">FROM employees;</span><br></pre></td></tr></table></figure>
<h3 id="ltrim-rtrim-trim函数去除空格"><code>LTRIM()</code>/ <code>RTRIM()</code>/ <code>TRIM()</code>函数（去除空格）</h3>
<p>实际业务中，字段可能因用户输入错误、数据导入问题包含<strong>多余空格</strong>（比如姓名前的空格、备注后的空格），这些函数用于清理空格，让数据更规范：</p>
<ul>
<li><code>LTRIM(字段)</code>：去除字段值<strong>左侧（开头）</strong> 的空格；</li>
<li><code>RTRIM(字段)</code>：去除字段值<strong>右侧（结尾）</strong> 的空格；</li>
<li><code>TRIM(字段)</code>：去除字段值<strong>左右两侧</strong>的空格（最常用）。</li>
</ul>
<h4 id="语法格式-1">语法格式</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LTRIM(需要清理的字段)</span><br><span class="line">RTRIM(需要清理的字段)</span><br><span class="line">TRIM(需要清理的字段)</span><br></pre></td></tr></table></figure>
<h4 id="实操示例基于-employees-表-1">实操示例（基于 <code>employees</code> 表）</h4>
<p>需求：清理 <code>remark</code>（备注）字段的前后空格，避免查询时因空格导致匹配失败：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT </span><br><span class="line">  remark AS 清理前备注,</span><br><span class="line">  TRIM(remark) AS 清理后备注,</span><br><span class="line">  LTRIM(remark) AS 仅清左空格,</span><br><span class="line">  RTRIM(remark) AS 仅清右空格</span><br><span class="line">FROM employees;</span><br></pre></td></tr></table></figure>
<p>结果说明：若原备注为 “ 核心员工 ”（前后各 1 个空格），则：</p>
<ul>
<li>清理后备注：“核心员工”（无空格）；</li>
<li>仅清左空格：“核心员工”（右侧仍有空格）；</li>
<li>仅清右空格：“ 核心员工”（左侧仍有空格）。</li>
</ul>
<h4 id="实际应用场景">实际应用场景</h4>
<p>比如模糊查询时，若用户输入 “核心员工”，而字段存 “ 核心员工 ”，直接查询会匹配失败，用 <code>TRIM()</code> 预处理即可：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 清理空格后再匹配，避免漏查</span><br><span class="line">SELECT * FROM employees WHERE TRIM(remark) LIKE &#x27;%核心员工%&#x27;;</span><br></pre></td></tr></table></figure>
<h3 id="as-关键字字段别名">AS 关键字（字段别名）</h3>
<p>计算字段的结果列名默认是 “函数 / 运算表达式”（比如 <code>CONCAT(name, '-', department)</code>），可读性差。<code>AS</code> 关键字用于给字段、计算结果起<strong>简洁易懂的别名</strong>，有助于：</p>
<ul>
<li>简化列名：避免查询结果中出现冗长的表达式；</li>
<li>提升可读性：让他人（或自己后续查看）快速理解列含义；</li>
<li>支持后续操作：比如对计算结果排序、筛选（用别名更简洁）。</li>
</ul>
<h4 id="语法格式-2">语法格式</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">字段名/计算表达式 AS 别名  -- AS可省略，推荐保留（更规范）</span><br></pre></td></tr></table></figure>
<h4 id="实操示例基于-employees-表-2">实操示例（基于 <code>employees</code> 表）</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT </span><br><span class="line">  name AS 员工姓名,  -- 给原有字段起别名（简化列名）</span><br><span class="line">  salary AS 月薪,</span><br><span class="line">  salary * 12 AS 年薪,  -- 给算术计算结果起别名</span><br><span class="line">  CONCAT(name, &#x27;-&#x27;, department) AS 员工部门信息  -- 给拼接结果起别名</span><br><span class="line">FROM employees;</span><br></pre></td></tr></table></figure>
<p>结果说明：查询结果的列名会显示为 “员工姓名”“月薪”“年薪”“员工部门信息”，而非原始字段名或复杂表达式。</p>
<h4 id="实操示例别名含特殊字符用引号包裹">实操示例：别名含特殊字符（用引号包裹）</h4>
<p>若别名需要包含空格、中文符号，用单引号 / 双引号包裹：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT </span><br><span class="line">  salary * 1.1 AS &#x27;涨薪10%后薪资&#x27;,  -- 别名含空格和百分号，用引号包裹</span><br><span class="line">  CONCAT(name, &#x27;（&#x27;, department, &#x27;）&#x27;) AS &#x27;员工（部门）&#x27;</span><br><span class="line">FROM employees;</span><br></pre></td></tr></table></figure>
<h3 id="算术计算加减乘除取模">算术计算（加减乘除、取模%）</h3>
<p>对表中的<strong>数值类型字段</strong>（如薪资、年龄、数量等）执行算术运算，动态生成计算结果（如年薪、折扣价、总和等）。</p>
<h4 id="支持的运算类型">支持的运算类型</h4>
<table>
<thead>
<tr class="header">
<th>运算符号</th>
<th>功能</th>
<th>适用场景</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>+</code></td>
<td>加法</td>
<td>计算总和（薪资 + 奖金）</td>
</tr>
<tr class="even">
<td><code>-</code></td>
<td>减法</td>
<td>计算差值（原价 - 优惠价）</td>
</tr>
<tr class="odd">
<td><code>*</code></td>
<td>乘法</td>
<td>计算年薪（月薪 ×12）</td>
</tr>
<tr class="even">
<td><code>/</code></td>
<td>除法</td>
<td>计算平均值、折扣</td>
</tr>
<tr class="odd">
<td><code>%</code></td>
<td>取模（余数）</td>
<td>判断奇偶、循环编号</td>
</tr>
</tbody>
</table>
<h4 id="实操示例基于-employees-表-3">实操示例（基于 <code>employees</code> 表）</h4>
<h5 id="示例-1计算年薪乘法">示例 1：计算年薪（乘法）</h5>
<p>需求：查询员工月薪、年终奖（月薪 ×2）、年薪（月薪 ×12 + 年终奖）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT </span><br><span class="line">  name AS 员工姓名,</span><br><span class="line">  salary AS 月薪,</span><br><span class="line">  salary * 2 AS 年终奖,</span><br><span class="line">  salary * 12 + (salary * 2) AS 税前年薪</span><br><span class="line">FROM employees;</span><br></pre></td></tr></table></figure>
<h5 id="示例-2计算薪资差值减法">示例 2：计算薪资差值（减法）</h5>
<p>需求：查询员工薪资与公司平均薪资的差值（假设平均薪资为 6000）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT </span><br><span class="line">  name AS 员工姓名,</span><br><span class="line">  salary AS 月薪,</span><br><span class="line">  salary - 6000 AS 与平均薪资差值  -- 差值可为正（高于平均）或负（低于平均）</span><br><span class="line">FROM employees;</span><br></pre></td></tr></table></figure>
<h5 id="示例-3取模判断奇偶">示例 3：取模判断奇偶（%）</h5>
<p>需求：查询员工工号（假设为数值类型），并判断奇偶（奇数为 1，偶数为 0）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT </span><br><span class="line">  emp_id AS 工号,</span><br><span class="line">  name AS 员工姓名,</span><br><span class="line">  emp_id % 2 AS 工号奇偶  -- 结果为0→偶数，1→奇数</span><br><span class="line">FROM employees;</span><br></pre></td></tr></table></figure>
<h4 id="注意事项">注意事项</h4>
<ol type="1">
<li>仅支持数值类型：若对字符串字段做算术运算，会返回 <code>0</code> 或错误（需确保字段是 <code>INT</code>/<code>DECIMAL</code> 等数值类型）；</li>
<li>除法精度：MySQL 中整数除法会自动取整（比如 <code>7/2=3</code>），若需保留小数，可加 <code>1.0</code> 转为浮点运算（<code>7/2.0=3.5</code>）；</li>
<li>避免除以 0：若除法的分母是字段，需用 <code>WHERE</code> 筛选排除 <code>0</code>（比如 <code>WHERE bonus != 0</code>），否则会返回 <code>NULL</code>。</li>
</ol>
<h2 id="数据处理函数">数据处理函数</h2>
<p>MySQL提供了丰富的数据处理函数，用于对查询结果进行各种转换、计算和格式化操作。这些函数可以在SELECT、WHERE等子句中使用，大大增强了数据查询和处理的灵活性。</p>
<h3 id="文本函数upperlowerlength等">文本函数（<code>UPPER()</code>/<code>LOWER()</code>/<code>LENGTH()</code>等）</h3>
<p>文本函数主要用于处理字符串类型的数据，如大小写转换、长度计算、截取等。</p>
<h4 id="常用文本函数表">常用文本函数表</h4>
<table>
<colgroup>
<col style="width: 25%" />
<col style="width: 32%" />
<col style="width: 21%" />
<col style="width: 21%" />
</colgroup>
<thead>
<tr class="header">
<th>函数名</th>
<th>功能说明</th>
<th>示例</th>
<th>结果</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>UPPER(str)</code></td>
<td>将字符串转换为大写</td>
<td><code>UPPER('hello')</code></td>
<td><code>'HELLO'</code></td>
</tr>
<tr class="even">
<td><code>LOWER(str)</code></td>
<td>将字符串转换为小写</td>
<td><code>LOWER('HELLO')</code></td>
<td><code>'hello'</code></td>
</tr>
<tr class="odd">
<td><code>LENGTH(str)</code></td>
<td>返回字符串的字节长度</td>
<td><code>LENGTH('你好')</code></td>
<td><code>6</code> (UTF-8编码下一个中文占3字节)</td>
</tr>
<tr class="even">
<td><code>CHAR_LENGTH(str)</code></td>
<td>返回字符串的字符个数</td>
<td><code>CHAR_LENGTH('你好')</code></td>
<td><code>2</code></td>
</tr>
<tr class="odd">
<td><code>SUBSTRING(str, pos, len)</code></td>
<td>截取字符串（从pos位置开始，截取len个字符）</td>
<td><code>SUBSTRING('HelloWorld', 1, 5)</code></td>
<td><code>'Hello'</code></td>
</tr>
<tr class="even">
<td><code>LEFT(str, len)</code></td>
<td>截取字符串左侧的len个字符</td>
<td><code>LEFT('HelloWorld', 5)</code></td>
<td><code>'Hello'</code></td>
</tr>
<tr class="odd">
<td><code>RIGHT(str, len)</code></td>
<td>截取字符串右侧的len个字符</td>
<td><code>RIGHT('HelloWorld', 5)</code></td>
<td><code>'World'</code></td>
</tr>
<tr class="even">
<td><code>INSTR(str, substr)</code></td>
<td>返回子串在字符串中第一次出现的位置</td>
<td><code>INSTR('HelloWorld', 'o')</code></td>
<td><code>5</code></td>
</tr>
<tr class="odd">
<td><code>REPLACE(str, from_s, to_s)</code></td>
<td>替换字符串中的子串</td>
<td><code>REPLACE('HelloWorld', 'o', '*')</code></td>
<td><code>'Hell*W*rld'</code></td>
</tr>
<tr class="even">
<td><code>CONCAT(str1, str2, ...)</code></td>
<td>拼接多个字符串</td>
<td><code>CONCAT('Hello', ' ', 'World')</code></td>
<td><code>'Hello World'</code></td>
</tr>
<tr class="odd">
<td><code>CONCAT_WS(sep, str1, str2, ...)</code></td>
<td>使用分隔符拼接字符串，忽略NULL值</td>
<td><code>CONCAT_WS('-', '2023', '10', '25')</code></td>
<td><code>'2023-10-25'</code></td>
</tr>
<tr class="even">
<td><code>TRIM([BOTH/LEADING/TRAILING] str FROM str1)</code></td>
<td>去除字符串前后空格或指定字符</td>
<td><code>TRIM('  Hello  ')</code></td>
<td><code>'Hello'</code></td>
</tr>
<tr class="odd">
<td><code>LPAD(str, len, padstr)</code></td>
<td>用指定字符左填充字符串到指定长度</td>
<td><code>LPAD('123', 5, '0')</code></td>
<td><code>'00123'</code></td>
</tr>
<tr class="even">
<td><code>RPAD(str, len, padstr)</code></td>
<td>用指定字符右填充字符串到指定长度</td>
<td><code>RPAD('123', 5, '0')</code></td>
<td><code>'12300'</code></td>
</tr>
</tbody>
</table>
<h4 id="语法格式与示例">语法格式与示例</h4>
<h5 id="upperlower---大小写转换">1. <code>UPPER()</code>/<code>LOWER()</code> - 大小写转换</h5>
<p><strong>语法</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UPPER(字符串/字段名)</span><br><span class="line">LOWER(字符串/字段名)</span><br></pre></td></tr></table></figure></p>
<p><strong>示例</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-- 转换员工姓名为大写和小写</span><br><span class="line">SELECT </span><br><span class="line">  name AS 原始姓名,</span><br><span class="line">  UPPER(name) AS 大写姓名,</span><br><span class="line">  LOWER(name) AS 小写姓名</span><br><span class="line">FROM employees;</span><br></pre></td></tr></table></figure></p>
<h5 id="lengthchar_length---长度计算">2. <code>LENGTH()</code>/<code>CHAR_LENGTH()</code> - 长度计算</h5>
<p><strong>语法</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LENGTH(字符串/字段名)</span><br><span class="line">CHAR_LENGTH(字符串/字段名)</span><br></pre></td></tr></table></figure></p>
<p><strong>示例</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-- 计算员工姓名的字节长度和字符个数</span><br><span class="line">SELECT </span><br><span class="line">  name AS 姓名,</span><br><span class="line">  LENGTH(name) AS 字节长度,</span><br><span class="line">  CHAR_LENGTH(name) AS 字符个数</span><br><span class="line">FROM employees;</span><br></pre></td></tr></table></figure></p>
<p><strong>注意</strong>： - 在UTF-8编码下，一个中文字符通常占用3个字节 - 对于多字节字符集，<code>LENGTH()</code>和<code>CHAR_LENGTH()</code>结果可能不同</p>
<h5 id="substring---字符串截取">3. <code>SUBSTRING()</code> - 字符串截取</h5>
<p><strong>语法</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SUBSTRING(字符串/字段名, 起始位置, 截取长度)</span><br><span class="line">-- 或使用别名</span><br><span class="line">SUBSTR(字符串/字段名, 起始位置, 截取长度)</span><br></pre></td></tr></table></figure></p>
<p><strong>示例</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-- 截取邮箱的前5个字符</span><br><span class="line">SELECT </span><br><span class="line">  email AS 完整邮箱,</span><br><span class="line">  SUBSTRING(email, 1, 5) AS 邮箱前缀</span><br><span class="line">FROM employees;</span><br><span class="line"></span><br><span class="line">-- 截取从第6个字符开始到结尾的部分（省略长度参数）</span><br><span class="line">SELECT SUBSTRING(email, 6) AS 邮箱后缀</span><br><span class="line">FROM employees;</span><br></pre></td></tr></table></figure></p>
<h5 id="replace---字符串替换">4. <code>REPLACE()</code> - 字符串替换</h5>
<p><strong>语法</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">REPLACE(原始字符串/字段名, 被替换子串, 替换为的子串)</span><br></pre></td></tr></table></figure></p>
<p><strong>示例</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-- 将邮箱中的&#x27;@company.com&#x27;替换为&#x27;@newcompany.com&#x27;</span><br><span class="line">SELECT </span><br><span class="line">  email AS 原邮箱,</span><br><span class="line">  REPLACE(email, &#x27;@company.com&#x27;, &#x27;@newcompany.com&#x27;) AS 新邮箱</span><br><span class="line">FROM employees</span><br><span class="line">WHERE email LIKE &#x27;%@company.com&#x27;;</span><br></pre></td></tr></table></figure></p>
<h5 id="instr---查找子串位置">5. <code>INSTR()</code> - 查找子串位置</h5>
<p><strong>语法</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSTR(原始字符串/字段名, 要查找的子串)</span><br></pre></td></tr></table></figure></p>
<p><strong>示例</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-- 查找邮箱中&#x27;@&#x27;符号的位置</span><br><span class="line">SELECT </span><br><span class="line">  email,</span><br><span class="line">  INSTR(email, &#x27;@&#x27;) AS at_position</span><br><span class="line">FROM employees;</span><br></pre></td></tr></table></figure></p>
<h3 id="数值函数roundabsfloor等">数值函数（<code>ROUND()</code>/<code>ABS()</code>/<code>FLOOR()</code>等）</h3>
<p>数值函数用于对数值类型的数据进行各种数学运算和处理，如四舍五入、取整、绝对值等。</p>
<h4 id="常用数值函数表">常用数值函数表</h4>
<table>
<thead>
<tr class="header">
<th>函数名</th>
<th>功能说明</th>
<th>示例</th>
<th>结果</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>ROUND(x, d)</code></td>
<td>四舍五入到指定小数位</td>
<td><code>ROUND(123.456, 2)</code></td>
<td><code>123.46</code></td>
</tr>
<tr class="even">
<td><code>FLOOR(x)</code></td>
<td>向下取整（返回不大于x的最大整数）</td>
<td><code>FLOOR(123.99)</code></td>
<td><code>123</code></td>
</tr>
<tr class="odd">
<td><code>CEIL(x)</code>/<code>CEILING(x)</code></td>
<td>向上取整（返回不小于x的最小整数）</td>
<td><code>CEIL(123.01)</code></td>
<td><code>124</code></td>
</tr>
<tr class="even">
<td><code>ABS(x)</code></td>
<td>返回x的绝对值</td>
<td><code>ABS(-123)</code></td>
<td><code>123</code></td>
</tr>
<tr class="odd">
<td><code>MOD(x, y)</code></td>
<td>返回x除以y的余数</td>
<td><code>MOD(10, 3)</code></td>
<td><code>1</code></td>
</tr>
<tr class="even">
<td><code>POW(x, y)</code>/<code>POWER(x, y)</code></td>
<td>返回x的y次方</td>
<td><code>POW(2, 3)</code></td>
<td><code>8</code></td>
</tr>
<tr class="odd">
<td><code>SQRT(x)</code></td>
<td>返回x的平方根</td>
<td><code>SQRT(16)</code></td>
<td><code>4</code></td>
</tr>
<tr class="even">
<td><code>RAND()</code></td>
<td>返回0到1之间的随机数</td>
<td><code>RAND()</code></td>
<td>如<code>0.732456...</code></td>
</tr>
<tr class="odd">
<td><code>SIGN(x)</code></td>
<td>返回x的符号（-1、0或1）</td>
<td><code>SIGN(-5)</code></td>
<td><code>-1</code></td>
</tr>
<tr class="even">
<td><code>EXP(x)</code></td>
<td>返回e的x次方</td>
<td><code>EXP(1)</code></td>
<td><code>2.71828...</code></td>
</tr>
<tr class="odd">
<td><code>LOG(x)</code></td>
<td>返回x的自然对数</td>
<td><code>LOG(2.71828)</code></td>
<td><code>1</code></td>
</tr>
<tr class="even">
<td><code>LOG10(x)</code></td>
<td>返回x的以10为底的对数</td>
<td><code>LOG10(100)</code></td>
<td><code>2</code></td>
</tr>
</tbody>
</table>
<h4 id="语法格式与示例-1">语法格式与示例</h4>
<h5 id="round---四舍五入">1. <code>ROUND()</code> - 四舍五入</h5>
<p><strong>语法</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ROUND(数值/字段名 [, 小数位数])</span><br></pre></td></tr></table></figure></p>
<p><strong>示例</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-- 对员工薪资进行四舍五入</span><br><span class="line">SELECT </span><br><span class="line">  name AS 员工姓名,</span><br><span class="line">  salary AS 原始薪资,</span><br><span class="line">  ROUND(salary) AS 整数薪资,</span><br><span class="line">  ROUND(salary, 1) AS 一位小数薪资</span><br><span class="line">FROM employees;</span><br></pre></td></tr></table></figure></p>
<p><strong>注意</strong>： - 小数位数参数可选，默认为0（即四舍五入到整数） - 小数位数为负数时，表示四舍五入到十位、百位等位置</p>
<h5 id="floorceil---取整">2. <code>FLOOR()</code>/<code>CEIL()</code> - 取整</h5>
<p><strong>语法</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FLOOR(数值/字段名)</span><br><span class="line">CEIL(数值/字段名) 或 CEILING(数值/字段名)</span><br></pre></td></tr></table></figure></p>
<p><strong>示例</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-- 计算员工薪资的向下取整和向上取整值</span><br><span class="line">SELECT </span><br><span class="line">  name AS 员工姓名,</span><br><span class="line">  salary AS 原始薪资,</span><br><span class="line">  FLOOR(salary) AS 向下取整,</span><br><span class="line">  CEIL(salary) AS 向上取整</span><br><span class="line">FROM employees;</span><br></pre></td></tr></table></figure></p>
<h5 id="abs---绝对值">3. <code>ABS()</code> - 绝对值</h5>
<p><strong>语法</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ABS(数值/字段名)</span><br></pre></td></tr></table></figure></p>
<p><strong>示例</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-- 计算员工薪资与平均薪资的差值绝对值</span><br><span class="line">SELECT </span><br><span class="line">  name AS 员工姓名,</span><br><span class="line">  salary AS 原始薪资,</span><br><span class="line">  salary - 6000 AS 薪资差值,</span><br><span class="line">  ABS(salary - 6000) AS 绝对差值</span><br><span class="line">FROM employees;</span><br></pre></td></tr></table></figure></p>
<h5 id="rand---随机数生成">4. <code>RAND()</code> - 随机数生成</h5>
<p><strong>语法</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RAND([种子值])</span><br></pre></td></tr></table></figure></p>
<p><strong>示例</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-- 生成随机数（无种子值，每次调用结果不同）</span><br><span class="line">SELECT RAND() AS 随机数;</span><br><span class="line"></span><br><span class="line">-- 生成随机排序的员工列表</span><br><span class="line">SELECT * FROM employees ORDER BY RAND();</span><br><span class="line"></span><br><span class="line">-- 随机选择5名员工</span><br><span class="line">SELECT * FROM employees ORDER BY RAND() LIMIT 5;</span><br></pre></td></tr></table></figure></p>
<h3 id="日期时间函数nowdate_formatdatediff等">日期时间函数（<code>NOW()</code>/<code>DATE_FORMAT()</code>/<code>DATEDIFF()</code>等）</h3>
<p>日期时间函数用于处理日期和时间类型的数据，如获取当前时间、格式化日期、计算日期差值等。</p>
<h4 id="常用日期时间函数表">常用日期时间函数表</h4>
<table>
<colgroup>
<col style="width: 25%" />
<col style="width: 32%" />
<col style="width: 21%" />
<col style="width: 21%" />
</colgroup>
<thead>
<tr class="header">
<th>函数名</th>
<th>功能说明</th>
<th>示例</th>
<th>结果</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>NOW()</code></td>
<td>返回当前日期和时间</td>
<td><code>NOW()</code></td>
<td><code>2023-10-25 15:30:45</code></td>
</tr>
<tr class="even">
<td><code>CURDATE()</code></td>
<td>返回当前日期（不含时间）</td>
<td><code>CURDATE()</code></td>
<td><code>2023-10-25</code></td>
</tr>
<tr class="odd">
<td><code>CURTIME()</code></td>
<td>返回当前时间（不含日期）</td>
<td><code>CURTIME()</code></td>
<td><code>15:30:45</code></td>
</tr>
<tr class="even">
<td><code>DATE_FORMAT(date, format)</code></td>
<td>按指定格式格式化日期</td>
<td><code>DATE_FORMAT(NOW(), '%Y-%m-%d')</code></td>
<td><code>'2023-10-25'</code></td>
</tr>
<tr class="odd">
<td><code>DATEDIFF(date1, date2)</code></td>
<td>计算两个日期的差值（天数）</td>
<td><code>DATEDIFF('2023-10-25', '2023-10-01')</code></td>
<td><code>24</code></td>
</tr>
<tr class="even">
<td><code>TIMESTAMPDIFF(unit, start, end)</code></td>
<td>计算时间差值（指定单位）</td>
<td><code>TIMESTAMPDIFF(MONTH, '2023-01-01', '2023-10-25')</code></td>
<td><code>9</code></td>
</tr>
<tr class="odd">
<td><code>DATE_ADD(date, INTERVAL expr unit)</code></td>
<td>日期增加指定时间间隔</td>
<td><code>DATE_ADD(CURDATE(), INTERVAL 1 DAY)</code></td>
<td>明天的日期</td>
</tr>
<tr class="even">
<td><code>DATE_SUB(date, INTERVAL expr unit)</code></td>
<td>日期减少指定时间间隔</td>
<td><code>DATE_SUB(CURDATE(), INTERVAL 1 MONTH)</code></td>
<td>上个月的今天</td>
</tr>
<tr class="odd">
<td><code>YEAR(date)</code></td>
<td>提取日期的年份</td>
<td><code>YEAR('2023-10-25')</code></td>
<td><code>2023</code></td>
</tr>
<tr class="even">
<td><code>MONTH(date)</code></td>
<td>提取日期的月份</td>
<td><code>MONTH('2023-10-25')</code></td>
<td><code>10</code></td>
</tr>
<tr class="odd">
<td><code>DAY(date)</code></td>
<td>提取日期的日</td>
<td><code>DAY('2023-10-25')</code></td>
<td><code>25</code></td>
</tr>
<tr class="even">
<td><code>HOUR(time)</code></td>
<td>提取时间的小时</td>
<td><code>HOUR('15:30:45')</code></td>
<td><code>15</code></td>
</tr>
<tr class="odd">
<td><code>MINUTE(time)</code></td>
<td>提取时间的分钟</td>
<td><code>MINUTE('15:30:45')</code></td>
<td><code>30</code></td>
</tr>
<tr class="even">
<td><code>SECOND(time)</code></td>
<td>提取时间的秒</td>
<td><code>SECOND('15:30:45')</code></td>
<td><code>45</code></td>
</tr>
<tr class="odd">
<td><code>DAYNAME(date)</code></td>
<td>返回星期几的名称</td>
<td><code>DAYNAME('2023-10-25')</code></td>
<td><code>'Wednesday'</code></td>
</tr>
<tr class="even">
<td><code>MONTHNAME(date)</code></td>
<td>返回月份的名称</td>
<td><code>MONTHNAME('2023-10-25')</code></td>
<td><code>'October'</code></td>
</tr>
<tr class="odd">
<td><code>LAST_DAY(date)</code></td>
<td>返回指定日期所在月的最后一天</td>
<td><code>LAST_DAY('2023-10-25')</code></td>
<td><code>'2023-10-31'</code></td>
</tr>
<tr class="even">
<td><code>EXTRACT(unit FROM date)</code></td>
<td>提取日期的指定部分</td>
<td><code>EXTRACT(YEAR FROM '2023-10-25')</code></td>
<td><code>2023</code></td>
</tr>
</tbody>
</table>
<h4 id="常用日期时间格式化符号">常用日期时间格式化符号</h4>
<p>在<code>DATE_FORMAT()</code>函数中，常用的格式化符号如下：</p>
<table>
<thead>
<tr class="header">
<th>符号</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>%Y</code></td>
<td>四位年份（如：2023）</td>
</tr>
<tr class="even">
<td><code>%y</code></td>
<td>两位年份（如：23）</td>
</tr>
<tr class="odd">
<td><code>%m</code></td>
<td>两位月份（01-12）</td>
</tr>
<tr class="even">
<td><code>%c</code></td>
<td>月份（1-12）</td>
</tr>
<tr class="odd">
<td><code>%d</code></td>
<td>两位日期（01-31）</td>
</tr>
<tr class="even">
<td><code>%e</code></td>
<td>日期（1-31）</td>
</tr>
<tr class="odd">
<td><code>%H</code></td>
<td>24小时制（00-23）</td>
</tr>
<tr class="even">
<td><code>%h</code></td>
<td>12小时制（01-12）</td>
</tr>
<tr class="odd">
<td><code>%i</code></td>
<td>分钟（00-59）</td>
</tr>
<tr class="even">
<td><code>%s</code></td>
<td>秒（00-59）</td>
</tr>
<tr class="odd">
<td><code>%p</code></td>
<td>AM或PM</td>
</tr>
<tr class="even">
<td><code>%W</code></td>
<td>星期几全名（Sunday-Saturday）</td>
</tr>
<tr class="odd">
<td><code>%w</code></td>
<td>星期几数字（0=Sunday, 6=Saturday）</td>
</tr>
<tr class="even">
<td><code>%M</code></td>
<td>月份全名（January-December）</td>
</tr>
</tbody>
</table>
<h4 id="语法格式与示例-2">语法格式与示例</h4>
<h5 id="获取当前日期时间">1. 获取当前日期时间</h5>
<p><strong>语法</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NOW() -- 返回当前日期和时间</span><br><span class="line">CURDATE() -- 返回当前日期</span><br><span class="line">CURTIME() -- 返回当前时间</span><br></pre></td></tr></table></figure></p>
<p><strong>示例</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-- 获取当前时间信息</span><br><span class="line">SELECT </span><br><span class="line">  NOW() AS 当前完整时间,</span><br><span class="line">  CURDATE() AS 当前日期,</span><br><span class="line">  CURTIME() AS 当前时间;</span><br></pre></td></tr></table></figure></p>
<h5 id="date_format---日期格式化">2. <code>DATE_FORMAT()</code> - 日期格式化</h5>
<p><strong>语法</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DATE_FORMAT(日期/时间/字段名, 格式字符串)</span><br></pre></td></tr></table></figure></p>
<p><strong>示例</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-- 格式化员工入职日期</span><br><span class="line">SELECT </span><br><span class="line">  name AS 员工姓名,</span><br><span class="line">  hire_date AS 原始入职日期,</span><br><span class="line">  DATE_FORMAT(hire_date, &#x27;%Y年%m月%d日&#x27;) AS 格式化日期,</span><br><span class="line">  DATE_FORMAT(hire_date, &#x27;%Y-%m-%d %H:%i:%s&#x27;) AS 带时间的格式化</span><br><span class="line">FROM employees;</span><br></pre></td></tr></table></figure></p>
<h5 id="datedifftimestampdiff---日期差值计算">3. <code>DATEDIFF()</code>/<code>TIMESTAMPDIFF()</code> - 日期差值计算</h5>
<p><strong>语法</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DATEDIFF(日期1, 日期2) -- 返回日期1 - 日期2的天数差</span><br><span class="line">TIMESTAMPDIFF(单位, 开始时间, 结束时间) -- 返回两个时间的差值（指定单位）</span><br></pre></td></tr></table></figure></p>
<p><strong>示例</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-- 计算员工入职天数</span><br><span class="line">SELECT </span><br><span class="line">  name AS 员工姓名,</span><br><span class="line">  hire_date AS 入职日期,</span><br><span class="line">  DATEDIFF(CURDATE(), hire_date) AS 入职天数,</span><br><span class="line">  TIMESTAMPDIFF(MONTH, hire_date, CURDATE()) AS 入职月数,</span><br><span class="line">  TIMESTAMPDIFF(YEAR, hire_date, CURDATE()) AS 入职年数</span><br><span class="line">FROM employees;</span><br></pre></td></tr></table></figure></p>
<p><strong>注意</strong>： - <code>DATEDIFF()</code> 只考虑日期部分，忽略时间部分 - <code>TIMESTAMPDIFF()</code> 的时间单位可以是：YEAR, MONTH, DAY, HOUR, MINUTE, SECOND等</p>
<h5 id="date_adddate_sub---日期增减">4. <code>DATE_ADD()</code>/<code>DATE_SUB()</code> - 日期增减</h5>
<p><strong>语法</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DATE_ADD(日期/字段名, INTERVAL 数值 单位) -- 日期增加</span><br><span class="line">DATE_SUB(日期/字段名, INTERVAL 数值 单位) -- 日期减少</span><br></pre></td></tr></table></figure></p>
<p><strong>示例</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-- 计算员工试用期结束日期（假设试用期为3个月）</span><br><span class="line">SELECT </span><br><span class="line">  name AS 员工姓名,</span><br><span class="line">  hire_date AS 入职日期,</span><br><span class="line">  DATE_ADD(hire_date, INTERVAL 3 MONTH) AS 试用期结束日期,</span><br><span class="line">  DATE_SUB(hire_date, INTERVAL 1 DAY) AS 入职前一天</span><br><span class="line">FROM employees;</span><br></pre></td></tr></table></figure></p>
<h5 id="提取日期时间部分">5. 提取日期时间部分</h5>
<p><strong>语法</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">YEAR(date) -- 提取年份</span><br><span class="line">MONTH(date) -- 提取月份</span><br><span class="line">DAY(date) -- 提取日</span><br><span class="line">HOUR(time) -- 提取小时</span><br><span class="line">MINUTE(time) -- 提取分钟</span><br><span class="line">SECOND(time) -- 提取秒</span><br></pre></td></tr></table></figure></p>
<p><strong>示例</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-- 分析员工入职时间分布</span><br><span class="line">SELECT </span><br><span class="line">  name AS 员工姓名,</span><br><span class="line">  hire_date AS 入职日期,</span><br><span class="line">  YEAR(hire_date) AS 入职年份,</span><br><span class="line">  MONTH(hire_date) AS 入职月份,</span><br><span class="line">  DAY(hire_date) AS 入职日,</span><br><span class="line">  MONTHNAME(hire_date) AS 入职月份名称,</span><br><span class="line">  DAYNAME(hire_date) AS 入职星期几</span><br><span class="line">FROM employees;</span><br></pre></td></tr></table></figure></p>
<h2 id="聚集函数统计计算">聚集函数（统计计算）</h2>
<p>聚集函数又称为聚合函数或统计函数，主要用于对一组数据进行统计计算并返回单一结果。这些函数通常与GROUP BY子句结合使用，用于数据分组统计分析。</p>
<h3 id="常用函数countsumavgmaxmin">常用函数：<code>COUNT()</code>/<code>SUM()</code>/<code>AVG()</code>/<code>MAX()</code>/<code>MIN()</code></h3>
<h4 id="常用聚集函数表">常用聚集函数表</h4>
<table>
<colgroup>
<col style="width: 25%" />
<col style="width: 32%" />
<col style="width: 21%" />
<col style="width: 21%" />
</colgroup>
<thead>
<tr class="header">
<th>函数名</th>
<th>功能说明</th>
<th>示例</th>
<th>结果</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>COUNT(*)</code></td>
<td>统计表中所有行数（包括NULL值行）</td>
<td><code>COUNT(*)</code></td>
<td>返回表中总记录数</td>
</tr>
<tr class="even">
<td><code>COUNT(列名)</code></td>
<td>统计表中指定列非NULL值的行数</td>
<td><code>COUNT(email)</code></td>
<td>返回非NULL邮箱数量</td>
</tr>
<tr class="odd">
<td><code>COUNT(DISTINCT 列名)</code></td>
<td>统计表中指定列非NULL且不重复值的数量</td>
<td><code>COUNT(DISTINCT department)</code></td>
<td>返回不重复部门数量</td>
</tr>
<tr class="even">
<td><code>SUM(列名)</code></td>
<td>计算指定列数值的总和</td>
<td><code>SUM(salary)</code></td>
<td>返回薪资总和</td>
</tr>
<tr class="odd">
<td><code>AVG(列名)</code></td>
<td>计算指定列数值的平均值</td>
<td><code>AVG(salary)</code></td>
<td>返回平均薪资</td>
</tr>
<tr class="even">
<td><code>MAX(列名)</code></td>
<td>返回指定列的最大值</td>
<td><code>MAX(salary)</code></td>
<td>返回最高薪资</td>
</tr>
<tr class="odd">
<td><code>MIN(列名)</code></td>
<td>返回指定列的最小值</td>
<td><code>MIN(salary)</code></td>
<td>返回最低薪资</td>
</tr>
<tr class="even">
<td><code>GROUP_CONCAT(列名)</code></td>
<td>将分组后的结果连接成字符串</td>
<td><code>GROUP_CONCAT(name)</code></td>
<td>返回用逗号分隔的员工姓名</td>
</tr>
<tr class="odd">
<td><code>VARIANCE(列名)</code></td>
<td>计算指定列数值的方差</td>
<td><code>VARIANCE(salary)</code></td>
<td>返回薪资方差</td>
</tr>
<tr class="even">
<td><code>STDDEV(列名)</code></td>
<td>计算指定列数值的标准差</td>
<td><code>STDDEV(salary)</code></td>
<td>返回薪资标准差</td>
</tr>
</tbody>
</table>
<h4 id="语法格式与示例-3">语法格式与示例</h4>
<h5 id="count---计数函数">1. <code>COUNT()</code> - 计数函数</h5>
<p><strong>语法</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">COUNT(*) -- 统计所有行数</span><br><span class="line">COUNT(列名) -- 统计指定列非NULL值行数</span><br><span class="line">COUNT(DISTINCT 列名) -- 统计指定列非NULL且不重复值行数</span><br></pre></td></tr></table></figure></p>
<p><strong>示例</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-- 统计员工总数</span><br><span class="line">SELECT COUNT(*) AS 员工总数 FROM employees;</span><br><span class="line"></span><br><span class="line">-- 统计有邮箱的员工数量（忽略NULL值）</span><br><span class="line">SELECT COUNT(email) AS 有邮箱员工数 FROM employees;</span><br><span class="line"></span><br><span class="line">-- 统计不同部门的数量</span><br><span class="line">SELECT COUNT(DISTINCT department) AS 部门数量 FROM employees;</span><br></pre></td></tr></table></figure></p>
<p><strong>注意</strong>： - <code>COUNT(*)</code>包含NULL值行，而<code>COUNT(列名)</code>忽略NULL值行 - <code>COUNT(DISTINCT)</code>同时去除NULL值和重复值</p>
<h5 id="sum---求和函数">2. <code>SUM()</code> - 求和函数</h5>
<p><strong>语法</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SUM(数值列名)</span><br></pre></td></tr></table></figure></p>
<p><strong>示例</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-- 计算所有员工薪资总和</span><br><span class="line">SELECT SUM(salary) AS 薪资总和 FROM employees;</span><br><span class="line"></span><br><span class="line">-- 计算技术部门的薪资总和</span><br><span class="line">SELECT SUM(salary) AS 技术部薪资总和 </span><br><span class="line">FROM employees </span><br><span class="line">WHERE department = &#x27;技术部&#x27;;</span><br></pre></td></tr></table></figure></p>
<p><strong>注意</strong>： - <code>SUM()</code>函数只适用于数值类型的列 - 如果所有行都为NULL，结果将为NULL</p>
<h5 id="avg---平均值函数">3. <code>AVG()</code> - 平均值函数</h5>
<p><strong>语法</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AVG(数值列名)</span><br></pre></td></tr></table></figure></p>
<p><strong>示例</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-- 计算所有员工平均薪资</span><br><span class="line">SELECT AVG(salary) AS 平均薪资 FROM employees;</span><br><span class="line"></span><br><span class="line">-- 计算销售部员工平均薪资（保留两位小数）</span><br><span class="line">SELECT ROUND(AVG(salary), 2) AS 销售部平均薪资 </span><br><span class="line">FROM employees </span><br><span class="line">WHERE department = &#x27;销售部&#x27;;</span><br></pre></td></tr></table></figure></p>
<p><strong>注意</strong>： - <code>AVG()</code>函数会自动忽略NULL值 - 可以与<code>ROUND()</code>函数结合使用以控制小数位数</p>
<h5 id="maxmin---最大最小值函数">4. <code>MAX()</code>/<code>MIN()</code> - 最大/最小值函数</h5>
<p><strong>语法</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MAX(列名) -- 返回最大值</span><br><span class="line">MIN(列名) -- 返回最小值</span><br></pre></td></tr></table></figure></p>
<p><strong>示例</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">-- 找出最高和最低薪资</span><br><span class="line">SELECT </span><br><span class="line">  MAX(salary) AS 最高薪资,</span><br><span class="line">  MIN(salary) AS 最低薪资</span><br><span class="line">FROM employees;</span><br><span class="line"></span><br><span class="line">-- 找出最早和最晚入职的员工</span><br><span class="line">SELECT </span><br><span class="line">  MAX(hire_date) AS 最晚入职日期,</span><br><span class="line">  MIN(hire_date) AS 最早入职日期</span><br><span class="line">FROM employees;</span><br></pre></td></tr></table></figure></p>
<p><strong>注意</strong>： - <code>MAX()</code>/<code>MIN()</code>可以用于数值、日期、字符串等多种数据类型 - 对于字符串，按字典顺序比较</p>
<h5 id="group_concat---分组连接函数">5. <code>GROUP_CONCAT()</code> - 分组连接函数</h5>
<p><strong>语法</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GROUP_CONCAT([DISTINCT] 列名 [ORDER BY 排序字段] [SEPARATOR &#x27;分隔符&#x27;])</span><br></pre></td></tr></table></figure></p>
<p><strong>示例</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">-- 按部门分组，列出每个部门的所有员工姓名</span><br><span class="line">SELECT </span><br><span class="line">  department AS 部门,</span><br><span class="line">  GROUP_CONCAT(name) AS 员工列表</span><br><span class="line">FROM employees</span><br><span class="line">GROUP BY department;</span><br><span class="line"></span><br><span class="line">-- 按部门分组，列出每个部门不重复的职位（用分号分隔）</span><br><span class="line">SELECT </span><br><span class="line">  department AS 部门,</span><br><span class="line">  GROUP_CONCAT(DISTINCT position SEPARATOR &#x27;; &#x27;) AS 职位列表</span><br><span class="line">FROM employees</span><br><span class="line">GROUP BY department;</span><br><span class="line"></span><br><span class="line">-- 按部门分组，列出每个部门的员工姓名（按薪资降序排列）</span><br><span class="line">SELECT </span><br><span class="line">  department AS 部门,</span><br><span class="line">  GROUP_CONCAT(name ORDER BY salary DESC) AS 员工列表</span><br><span class="line">FROM employees</span><br><span class="line">GROUP BY department;</span><br></pre></td></tr></table></figure></p>
<h4 id="聚集函数与where子句结合">聚集函数与WHERE子句结合</h4>
<p><strong>注意</strong>：聚集函数不能直接用在WHERE子句中，但可以用在HAVING子句中（与GROUP BY配合使用）或子查询中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-- 错误示例（不能在WHERE中直接使用聚集函数）</span><br><span class="line">-- SELECT * FROM employees WHERE COUNT(*) &gt; 10;</span><br><span class="line"></span><br><span class="line">-- 正确示例1：使用HAVING过滤分组结果</span><br><span class="line">SELECT department FROM employees GROUP BY department HAVING COUNT(*) &gt; 10;</span><br><span class="line"></span><br><span class="line">-- 正确示例2：使用子查询</span><br><span class="line">SELECT * FROM employees WHERE salary &gt; (SELECT AVG(salary) FROM employees);</span><br></pre></td></tr></table></figure>
<h2 id="group-by-子句分组数据">GROUP BY 子句（分组数据）</h2>
<h3 id="基本用法按指定字段分组">基本用法（按指定字段分组）</h3>
<p>GROUP BY 子句用于将查询结果集按照一个或多个字段进行分组，然后对每个组应用聚集函数（如COUNT、SUM、AVG等）。分组操作可以帮助我们对数据进行分类汇总分析。</p>
<h4 id="语法格式-3">语法格式</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT 字段名1, 字段名2, 聚集函数(字段名)</span><br><span class="line">FROM 表名</span><br><span class="line">WHERE 条件</span><br><span class="line">GROUP BY 分组字段1, 分组字段2</span><br><span class="line">ORDER BY 排序字段;</span><br></pre></td></tr></table></figure>
<h4 id="基本示例">基本示例</h4>
<p><strong>按单个字段分组</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-- 按部门分组统计员工数量</span><br><span class="line">SELECT </span><br><span class="line">  department AS 部门,</span><br><span class="line">  COUNT(*) AS 员工数量</span><br><span class="line">FROM employees</span><br><span class="line">GROUP BY department;</span><br></pre></td></tr></table></figure>
<p><strong>按多个字段分组</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-- 按部门和性别分组统计员工数量和平均薪资</span><br><span class="line">SELECT </span><br><span class="line">  department AS 部门,</span><br><span class="line">  gender AS 性别,</span><br><span class="line">  COUNT(*) AS 员工数量,</span><br><span class="line">  ROUND(AVG(salary), 2) AS 平均薪资</span><br><span class="line">FROM employees</span><br><span class="line">GROUP BY department, gender</span><br><span class="line">ORDER BY department, 平均薪资 DESC;</span><br></pre></td></tr></table></figure>
<h4 id="group-by-与聚集函数结合">GROUP BY 与聚集函数结合</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">-- 按部门分组统计员工数量、平均薪资、最高薪资、最低薪资</span><br><span class="line">SELECT </span><br><span class="line">  department AS 部门,</span><br><span class="line">  COUNT(*) AS 员工数量,</span><br><span class="line">  ROUND(AVG(salary), 2) AS 平均薪资,</span><br><span class="line">  MAX(salary) AS 最高薪资,</span><br><span class="line">  MIN(salary) AS 最低薪资,</span><br><span class="line">  SUM(salary) AS 薪资总额</span><br><span class="line">FROM employees</span><br><span class="line">GROUP BY department</span><br><span class="line">ORDER BY 员工数量 DESC;</span><br></pre></td></tr></table></figure>
<h4 id="使用注意事项">使用注意事项</h4>
<ol type="1">
<li><p><strong>非聚集字段必须出现在GROUP BY子句中</strong> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-- 错误示例：name字段没有出现在GROUP BY中</span><br><span class="line">SELECT department, name, COUNT(*) </span><br><span class="line">FROM employees </span><br><span class="line">GROUP BY department;</span><br><span class="line"></span><br><span class="line">-- 正确示例</span><br><span class="line">SELECT department, COUNT(*) </span><br><span class="line">FROM employees </span><br><span class="line">GROUP BY department;</span><br></pre></td></tr></table></figure></p></li>
<li><p><strong>NULL值处理</strong></p>
<ul>
<li>NULL值会被视为一组进行分组 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">-- NULL值分组示例：GROUP BY会将所有NULL值的行分为一组</span><br><span class="line">-- 下面的查询会返回所有部门（包括NULL部门）及其员工数量</span><br><span class="line">SELECT department, COUNT(*) AS 员工数量</span><br><span class="line">FROM employees </span><br><span class="line">GROUP BY department;</span><br><span class="line">-- 结果中会有一行显示department为NULL，对应的COUNT为NULL部门的员工数量</span><br><span class="line"></span><br><span class="line">-- 如果只想统计NULL部门的员工数量，可以使用WHERE条件</span><br><span class="line">SELECT COUNT(*) AS NULL部门员工数量</span><br><span class="line">FROM employees </span><br><span class="line">WHERE department IS NULL;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p><strong>表达式分组</strong></p>
<ul>
<li>可以使用表达式作为分组依据 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-- 按年份分组统计订单数量</span><br><span class="line">SELECT </span><br><span class="line">  YEAR(order_date) AS 订单年份,</span><br><span class="line">  COUNT(*) AS 订单数量</span><br><span class="line">FROM orders</span><br><span class="line">GROUP BY YEAR(order_date);</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p><strong>GROUP BY 与 ORDER BY 结合</strong></p>
<ul>
<li>通常在GROUP BY之后使用ORDER BY对分组结果进行排序 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT </span><br><span class="line">  department, COUNT(*) AS count</span><br><span class="line">FROM employees</span><br><span class="line">GROUP BY department</span><br><span class="line">ORDER BY count DESC;</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ol>
<h3 id="筛选分组having子句与where的区别筛选分组结果-vs-筛选行">筛选分组：HAVING子句（与WHERE的区别：筛选分组结果 vs 筛选行）</h3>
<p>HAVING子句用于筛选分组后的结果集，类似于WHERE子句，但WHERE筛选的是行，而HAVING筛选的是分组。HAVING子句通常与GROUP BY一起使用。</p>
<h4 id="having-语法格式">HAVING 语法格式</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT 字段名1, 聚集函数(字段名)</span><br><span class="line">FROM 表名</span><br><span class="line">WHERE 行条件</span><br><span class="line">GROUP BY 分组字段</span><br><span class="line">HAVING 分组条件</span><br><span class="line">ORDER BY 排序字段;</span><br></pre></td></tr></table></figure>
<h4 id="having-与-where-的区别">HAVING 与 WHERE 的区别</h4>
<table>
<thead>
<tr class="header">
<th>特性</th>
<th>WHERE 子句</th>
<th>HAVING 子句</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>作用对象</td>
<td>筛选行数据</td>
<td>筛选分组结果</td>
</tr>
<tr class="even">
<td>使用位置</td>
<td>GROUP BY 之前</td>
<td>GROUP BY 之后</td>
</tr>
<tr class="odd">
<td>能否使用聚集函数</td>
<td>不能</td>
<td>可以</td>
</tr>
<tr class="even">
<td>执行顺序</td>
<td>先执行，再分组</td>
<td>先分组，再执行</td>
</tr>
</tbody>
</table>
<h4 id="having-基本示例">HAVING 基本示例</h4>
<p><strong>筛选员工数量大于10的部门</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-- 查找员工数量超过10人的部门</span><br><span class="line">SELECT </span><br><span class="line">  department AS 部门,</span><br><span class="line">  COUNT(*) AS 员工数量</span><br><span class="line">FROM employees</span><br><span class="line">GROUP BY department</span><br><span class="line">HAVING COUNT(*) &gt; 10;</span><br></pre></td></tr></table></figure>
<p><strong>筛选平均薪资大于8000的部门</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-- 查找平均薪资超过8000的部门</span><br><span class="line">SELECT </span><br><span class="line">  department AS 部门,</span><br><span class="line">  ROUND(AVG(salary), 2) AS 平均薪资</span><br><span class="line">FROM employees</span><br><span class="line">GROUP BY department</span><br><span class="line">HAVING AVG(salary) &gt; 8000;</span><br></pre></td></tr></table></figure>
<h4 id="where-与-having-结合使用">WHERE 与 HAVING 结合使用</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-- 筛选2023年入职且员工数量超过5人的部门</span><br><span class="line">SELECT </span><br><span class="line">  department AS 部门,</span><br><span class="line">  COUNT(*) AS 员工数量</span><br><span class="line">FROM employees</span><br><span class="line">WHERE YEAR(hire_date) = 2023  -- 先筛选行</span><br><span class="line">GROUP BY department</span><br><span class="line">HAVING COUNT(*) &gt; 5;  -- 再筛选分组</span><br></pre></td></tr></table></figure>
<h4 id="having-使用注意事项">HAVING 使用注意事项</h4>
<ol type="1">
<li><strong>性能考虑</strong>
<ul>
<li>对于行级筛选，优先使用WHERE子句以减少分组前的数据量</li>
<li>避免在HAVING中使用非分组字段的条件</li>
</ul></li>
<li><strong>聚集函数的使用</strong>
<ul>
<li>HAVING子句中可以使用聚集函数 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-- 查找总销售额超过10000的产品类别</span><br><span class="line">SELECT </span><br><span class="line">  category AS 产品类别,</span><br><span class="line">  SUM(sales_amount) AS 总销售额</span><br><span class="line">FROM products</span><br><span class="line">GROUP BY category</span><br><span class="line">HAVING SUM(sales_amount) &gt; 10000;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><strong>复杂条件组合</strong>
<ul>
<li>可以在HAVING中使用AND、OR等逻辑运算符组合多个条件 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-- 查找员工数量在5到20之间且平均薪资超过6000的部门</span><br><span class="line">SELECT </span><br><span class="line">  department,</span><br><span class="line">  COUNT(*) AS 员工数量,</span><br><span class="line">  ROUND(AVG(salary), 2) AS 平均薪资</span><br><span class="line">FROM employees</span><br><span class="line">GROUP BY department</span><br><span class="line">HAVING COUNT(*) BETWEEN 5 AND 20</span><br><span class="line">AND AVG(salary) &gt; 6000;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><strong>与ORDER BY结合</strong></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-- 查找销售额最高的前3个产品类别</span><br><span class="line">SELECT </span><br><span class="line">  category AS 产品类别,</span><br><span class="line">  SUM(sales_amount) AS 总销售额</span><br><span class="line">FROM products</span><br><span class="line">GROUP BY category</span><br><span class="line">HAVING SUM(sales_amount) &gt; 0</span><br><span class="line">ORDER BY 总销售额 DESC</span><br><span class="line">LIMIT 3;</span><br></pre></td></tr></table></figure>
<h2 id="子查询">子查询</h2>
<p>子查询（Subquery）是指嵌套在其他SQL语句中的SELECT语句，也称为内部查询或嵌套查询。子查询通常用于过滤数据、比较值或创建派生表，是SQL中强大而灵活的特性。</p>
<h4 id="子查询的分类">子查询的分类</h4>
<table>
<thead>
<tr class="header">
<th>分类方式</th>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>按返回结果行数</strong></td>
<td>单行子查询</td>
<td>返回单行单列结果</td>
</tr>
<tr class="even">
<td></td>
<td>多行子查询</td>
<td>返回多行结果</td>
</tr>
<tr class="odd">
<td><strong>按使用位置</strong></td>
<td>WHERE子句中的子查询</td>
<td>用于过滤数据</td>
</tr>
<tr class="even">
<td></td>
<td>FROM子句中的子查询</td>
<td>作为派生表使用</td>
</tr>
<tr class="odd">
<td></td>
<td>SELECT子句中的子查询</td>
<td>作为列值返回</td>
</tr>
<tr class="even">
<td></td>
<td>HAVING子句中的子查询</td>
<td>用于筛选分组</td>
</tr>
</tbody>
</table>
<h3 id="where中的子查询单行子查询多行子查询in">WHERE中的子查询（单行子查询/多行子查询<code>IN</code>）</h3>
<p>WHERE子句中的子查询用于过滤主查询的结果集，根据子查询返回的值来确定主查询中哪些行应该被包含。</p>
<h4 id="单行子查询">单行子查询</h4>
<p>单行子查询返回单个值（单行单列），通常与比较运算符（=, &gt;, &lt;, &gt;=, &lt;=, !=）一起使用。</p>
<p><strong>语法格式</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT 字段名</span><br><span class="line">FROM 表名</span><br><span class="line">WHERE 字段名 比较运算符 (SELECT 字段名 FROM 表名 WHERE 条件);</span><br></pre></td></tr></table></figure></p>
<p><strong>示例1：查找薪资高于平均薪资的员工</strong> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-- 查找薪资高于公司平均薪资的员工信息</span><br><span class="line">SELECT </span><br><span class="line">  employee_id AS 员工ID,</span><br><span class="line">  name AS 姓名,</span><br><span class="line">  department AS 部门,</span><br><span class="line">  salary AS 薪资</span><br><span class="line">FROM employees</span><br><span class="line">WHERE salary &gt; (SELECT AVG(salary) FROM employees);</span><br></pre></td></tr></table></figure></p>
<p><strong>示例2：查找与特定员工同部门的其他员工</strong> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-- 查找与张三同部门的其他员工</span><br><span class="line">SELECT </span><br><span class="line">  employee_id AS 员工ID,</span><br><span class="line">  name AS 姓名,</span><br><span class="line">  department AS 部门</span><br><span class="line">FROM employees</span><br><span class="line">WHERE department = (SELECT department FROM employees WHERE name = &#x27;张三&#x27;)</span><br><span class="line">AND name != &#x27;张三&#x27;;</span><br></pre></td></tr></table></figure></p>
<h4 id="多行子查询">多行子查询</h4>
<p>多行子查询返回多行结果，通常与IN、ALL、ANY、EXISTS等操作符一起使用。</p>
<p><strong>语法格式</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT 字段名</span><br><span class="line">FROM 表名</span><br><span class="line">WHERE 字段名 IN (SELECT 字段名 FROM 表名 WHERE 条件);</span><br></pre></td></tr></table></figure></p>
<p><strong>示例1：使用IN操作符</strong> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-- 查找销售部门和市场部门的所有员工</span><br><span class="line">SELECT </span><br><span class="line">  employee_id AS 员工ID,</span><br><span class="line">  name AS 姓名,</span><br><span class="line">  department AS 部门</span><br><span class="line">FROM employees</span><br><span class="line">WHERE department IN (SELECT department_name FROM departments WHERE department_name IN (&#x27;销售部&#x27;, &#x27;市场部&#x27;));</span><br></pre></td></tr></table></figure></p>
<p><strong>示例2：使用ALL操作符</strong> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-- 查找薪资高于所有实习生的正式员工</span><br><span class="line">SELECT </span><br><span class="line">  employee_id AS 员工ID,</span><br><span class="line">  name AS 姓名,</span><br><span class="line">  salary AS 薪资</span><br><span class="line">FROM employees</span><br><span class="line">WHERE position = &#x27;正式员工&#x27;</span><br><span class="line">AND salary &gt; ALL (SELECT salary FROM employees WHERE position = &#x27;实习生&#x27;);</span><br></pre></td></tr></table></figure></p>
<p><strong>示例3：使用ANY操作符</strong> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-- 查找薪资高于任一实习生的正式员工</span><br><span class="line">SELECT </span><br><span class="line">  employee_id AS 员工ID,</span><br><span class="line">  name AS 姓名,</span><br><span class="line">  salary AS 薪资</span><br><span class="line">FROM employees</span><br><span class="line">WHERE position = &#x27;正式员工&#x27;</span><br><span class="line">AND salary &gt; ANY (SELECT salary FROM employees WHERE position = &#x27;实习生&#x27;);</span><br></pre></td></tr></table></figure></p>
<p><strong>示例4：使用EXISTS操作符</strong> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-- 查找至少有一个下属的管理者</span><br><span class="line">SELECT </span><br><span class="line">  employee_id AS 管理者ID,</span><br><span class="line">  name AS 管理者姓名</span><br><span class="line">FROM employees e1</span><br><span class="line">WHERE EXISTS (SELECT 1 FROM employees e2 WHERE e2.manager_id = e1.employee_id);</span><br></pre></td></tr></table></figure></p>
<h4 id="where子查询使用注意事项">WHERE子查询使用注意事项</h4>
<ol type="1">
<li><strong>子查询必须用括号括起来</strong></li>
<li><strong>单行子查询只能返回一个值</strong>，与单行比较运算符配合使用</li>
<li><strong>多行子查询需要使用多行操作符</strong>（IN、ALL、ANY、EXISTS）</li>
<li><strong>性能考虑</strong>：子查询可能会影响性能，特别是在大型表上，考虑使用JOIN替代某些子查询</li>
<li><strong>NULL值处理</strong>：当子查询可能返回NULL值时，注意使用正确的操作符</li>
</ol>
<h3 id="from中的子查询派生表需指定别名">FROM中的子查询（派生表，需指定别名）</h3>
<p>FROM子句中的子查询作为一个临时表（称为派生表或内联视图），在主查询中被使用。派生表必须指定别名。</p>
<h4 id="基本语法">基本语法</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT 字段名</span><br><span class="line">FROM (SELECT 字段名 FROM 表名 WHERE 条件) AS 派生表别名</span><br><span class="line">WHERE 条件;</span><br></pre></td></tr></table></figure>
<h4 id="示例1使用派生表统计部门平均薪资">示例1：使用派生表统计部门平均薪资</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">-- 使用派生表查找平均薪资高于公司总平均薪资的部门</span><br><span class="line">SELECT </span><br><span class="line">  dept_stats.department AS 部门,</span><br><span class="line">  dept_stats.avg_salary AS 部门平均薪资</span><br><span class="line">FROM (</span><br><span class="line">  SELECT </span><br><span class="line">    department,</span><br><span class="line">    AVG(salary) AS avg_salary</span><br><span class="line">  FROM employees</span><br><span class="line">  GROUP BY department</span><br><span class="line">) AS dept_stats</span><br><span class="line">WHERE dept_stats.avg_salary &gt; (SELECT AVG(salary) FROM employees)</span><br><span class="line">ORDER BY dept_stats.avg_salary DESC;</span><br></pre></td></tr></table></figure>
<h4 id="示例2复杂派生表与联结">示例2：复杂派生表与联结</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">-- 使用派生表统计每个员工的订单数量和总销售额</span><br><span class="line">SELECT </span><br><span class="line">  e.employee_id AS 员工ID,</span><br><span class="line">  e.name AS 员工姓名,</span><br><span class="line">  e.department AS 部门,</span><br><span class="line">  o.order_count AS 订单数量,</span><br><span class="line">  o.total_amount AS 总销售额</span><br><span class="line">FROM employees e</span><br><span class="line">LEFT JOIN (</span><br><span class="line">  SELECT </span><br><span class="line">    salesperson_id,</span><br><span class="line">    COUNT(*) AS order_count,</span><br><span class="line">    SUM(order_amount) AS total_amount</span><br><span class="line">  FROM orders</span><br><span class="line">  GROUP BY salesperson_id</span><br><span class="line">) AS o ON e.employee_id = o.salesperson_id</span><br><span class="line">ORDER BY o.total_amount DESC NULLS LAST;</span><br></pre></td></tr></table></figure>
<h4 id="示例3嵌套派生表">示例3：嵌套派生表</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">-- 使用嵌套派生表进行多层统计分析</span><br><span class="line">SELECT </span><br><span class="line">  yearly_stats.year AS 年份,</span><br><span class="line">  yearly_stats.avg_department_salary AS 部门平均薪资</span><br><span class="line">FROM (</span><br><span class="line">  SELECT </span><br><span class="line">    YEAR(hire_date) AS year,</span><br><span class="line">    AVG(dept_avg.salary_avg) AS avg_department_salary</span><br><span class="line">  FROM employees</span><br><span class="line">  JOIN (</span><br><span class="line">    SELECT </span><br><span class="line">      department,</span><br><span class="line">      AVG(salary) AS salary_avg</span><br><span class="line">    FROM employees</span><br><span class="line">    GROUP BY department</span><br><span class="line">  ) AS dept_avg ON employees.department = dept_avg.department</span><br><span class="line">  GROUP BY YEAR(hire_date)</span><br><span class="line">) AS yearly_stats</span><br><span class="line">ORDER BY yearly_stats.year;</span><br></pre></td></tr></table></figure>
<h4 id="from子查询使用注意事项">FROM子查询使用注意事项</h4>
<ol type="1">
<li><strong>必须指定别名</strong>：派生表必须有别名，否则SQL语句会出错</li>
<li><strong>作用域限制</strong>：派生表只在当前查询中可见，不能在其他查询或子查询中引用</li>
<li><strong>性能考虑</strong>：复杂的派生表可能会影响查询性能，特别是嵌套派生表</li>
<li><strong>列名处理</strong>：派生表中的列必须有唯一的名称，可使用AS关键字指定别名</li>
<li><strong>ORDER BY限制</strong>：在派生表中使用ORDER BY通常需要配合LIMIT，否则可能被优化器忽略</li>
</ol>
<h3 id="其他类型的子查询">其他类型的子查询</h3>
<h4 id="select子句中的子查询">SELECT子句中的子查询</h4>
<p>子查询可以出现在SELECT子句中，作为表达式返回单个值。</p>
<p><strong>示例</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-- 查询每个员工的薪资与部门平均薪资的差额</span><br><span class="line">SELECT </span><br><span class="line">  employee_id AS 员工ID,</span><br><span class="line">  name AS 姓名,</span><br><span class="line">  department AS 部门,</span><br><span class="line">  salary AS 当前薪资,</span><br><span class="line">  (SELECT AVG(salary) FROM employees e2 WHERE e2.department = e1.department) AS 部门平均薪资,</span><br><span class="line">  salary - (SELECT AVG(salary) FROM employees e2 WHERE e2.department = e1.department) AS 薪资差额</span><br><span class="line">FROM employees e1</span><br><span class="line">ORDER BY 薪资差额 DESC;</span><br></pre></td></tr></table></figure></p>
<h4 id="having子句中的子查询">HAVING子句中的子查询</h4>
<p>子查询可以在HAVING子句中使用，用于筛选分组结果。</p>
<p><strong>示例</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-- 查找平均薪资高于公司总平均薪资的部门</span><br><span class="line">SELECT </span><br><span class="line">  department AS 部门,</span><br><span class="line">  COUNT(*) AS 员工数量,</span><br><span class="line">  AVG(salary) AS 平均薪资</span><br><span class="line">FROM employees</span><br><span class="line">GROUP BY department</span><br><span class="line">HAVING AVG(salary) &gt; (SELECT AVG(salary) FROM employees)</span><br><span class="line">ORDER BY 平均薪资 DESC;</span><br></pre></td></tr></table></figure></p>
<h4 id="相关子查询correlated-subquery">相关子查询（Correlated Subquery）</h4>
<p>相关子查询是引用外部查询中表的子查询，它为外部查询的每一行执行一次。</p>
<p><strong>示例</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-- 查找每个部门薪资最高的员工</span><br><span class="line">SELECT </span><br><span class="line">  e1.employee_id AS 员工ID,</span><br><span class="line">  e1.name AS 姓名,</span><br><span class="line">  e1.department AS 部门,</span><br><span class="line">  e1.salary AS 薪资</span><br><span class="line">FROM employees e1</span><br><span class="line">WHERE e1.salary = (SELECT MAX(salary) FROM employees e2 WHERE e2.department = e1.department)</span><br><span class="line">ORDER BY e1.department;</span><br></pre></td></tr></table></figure></p>
<h3 id="子查询的性能优化">子查询的性能优化</h3>
<ol type="1">
<li><strong>使用EXISTS替代IN</strong>：当子查询结果集较大时，EXISTS通常比IN更高效</li>
<li><strong>考虑使用JOIN</strong>：某些子查询可以转换为JOIN操作，提高性能</li>
<li><strong>限制子查询结果集</strong>：使用LIMIT或适当的WHERE条件减少子查询返回的数据量</li>
<li><strong>避免SELECT * </strong>：在子查询中只选择必要的列</li>
<li><strong>使用索引</strong>：确保子查询中使用的列上有适当的索引</li>
<li><strong>避免过于复杂的嵌套</strong>：过度嵌套的子查询可能导致性能问题</li>
</ol>
<p><strong>优化示例</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">-- 优化前：使用IN子查询</span><br><span class="line">SELECT * FROM employees WHERE department_id IN (SELECT department_id FROM departments WHERE location = &#x27;北京&#x27;);</span><br><span class="line"></span><br><span class="line">-- 优化后：使用JOIN</span><br><span class="line">SELECT e.* FROM employees e JOIN departments d ON e.department_id = d.department_id WHERE d.location = &#x27;北京&#x27;;</span><br><span class="line"></span><br><span class="line">-- 优化前：使用IN和子查询</span><br><span class="line">SELECT * FROM orders WHERE customer_id IN (SELECT customer_id FROM customers WHERE last_purchase_date &gt; &#x27;2023-01-01&#x27;);</span><br><span class="line"></span><br><span class="line">-- 优化后：使用EXISTS</span><br><span class="line">SELECT * FROM orders o WHERE EXISTS (SELECT 1 FROM customers c WHERE c.customer_id = o.customer_id AND c.last_purchase_date &gt; &#x27;2023-01-01&#x27;);</span><br></pre></td></tr></table></figure></p>
<h2 id="联结表多表查询">联结表（多表查询）</h2>
<p>在实际数据库应用中，数据通常分布在多个相关联的表中。联结表（Join）是SQL中用于从多个表中检索数据的强大机制，它通过表之间的关联条件将数据组合在一起。</p>
<h3 id="笛卡尔积无关联条件的联结需避免">笛卡尔积（无关联条件的联结，需避免）</h3>
<p>笛卡尔积（Cartesian Product）是当联结表时不指定关联条件时产生的结果，它会将第一个表的每一行与第二个表的每一行组合，生成所有可能的行组合。</p>
<p><strong>语法</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM 表1, 表2;</span><br></pre></td></tr></table></figure></p>
<p><strong>示例</strong>： 假设有employees表（3行）和departments表（2行），不使用WHERE条件的查询将返回3×2=6行数据：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-- 笛卡尔积查询示例（通常应避免）</span><br><span class="line">SELECT e.employee_id, e.name, d.department_id, d.department_name</span><br><span class="line">FROM employees e, departments d;</span><br></pre></td></tr></table></figure>
<p><strong>注意事项</strong>： 1. 笛卡尔积通常会产生大量不必要的数据行，消耗系统资源 2. 在实际开发中，应始终为联结操作指定适当的关联条件 3. 笛卡尔积有时用于特定的数据生成场景，但一般查询中应避免使用</p>
<h3 id="内部联结inner-join匹配两表关联数据">内部联结（INNER JOIN，匹配两表关联数据）</h3>
<p>内部联结是最常用的联结类型，它只返回满足关联条件的行。</p>
<p><strong>语法</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-- 标准ANSI JOIN语法（推荐）</span><br><span class="line">SELECT 列名</span><br><span class="line">FROM 表1</span><br><span class="line">INNER JOIN 表2 ON 表1.列 = 表2.列;</span><br><span class="line"></span><br><span class="line">-- 传统JOIN语法（WHERE子句指定关联条件）</span><br><span class="line">SELECT 列名</span><br><span class="line">FROM 表1, 表2</span><br><span class="line">WHERE 表1.列 = 表2.列;</span><br></pre></td></tr></table></figure></p>
<p><strong>示例</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-- 使用INNER JOIN查询员工及其部门信息</span><br><span class="line">SELECT </span><br><span class="line">  e.employee_id AS 员工ID,</span><br><span class="line">  e.name AS 员工姓名,</span><br><span class="line">  e.position AS 职位,</span><br><span class="line">  d.department_id AS 部门ID,</span><br><span class="line">  d.department_name AS 部门名称</span><br><span class="line">FROM employees e</span><br><span class="line">INNER JOIN departments d ON e.department_id = d.department_id;</span><br></pre></td></tr></table></figure></p>
<p><strong>注意事项</strong>： 1. 内部联结只返回两表中匹配的数据，不匹配的行不会出现在结果集中 2. 推荐使用ANSI JOIN语法（INNER JOIN…ON），可读性更好 3. 确保在ON子句中指定正确的关联字段，通常是主键和外键的关系</p>
<h3 id="表字段别名简化多表查询语法">表/字段别名（简化多表查询语法）</h3>
<p>当进行多表查询时，使用别名可以简化SQL语句并避免列名冲突。</p>
<p><strong>语法</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT </span><br><span class="line">  表1别名.列名1 AS 别名1,</span><br><span class="line">  表2别名.列名2 AS 别名2</span><br><span class="line">FROM 表1 表1别名</span><br><span class="line">JOIN 表2 表2别名 ON 表1别名.关联列 = 表2别名.关联列;</span><br></pre></td></tr></table></figure></p>
<p><strong>示例</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-- 使用表别名和列别名简化多表查询</span><br><span class="line">SELECT </span><br><span class="line">  e.employee_id AS 员工ID,</span><br><span class="line">  e.name AS 员工姓名,</span><br><span class="line">  d.department_name AS 部门名称,</span><br><span class="line">  p.project_name AS 项目名称</span><br><span class="line">FROM employees e</span><br><span class="line">JOIN departments d ON e.department_id = d.department_id</span><br><span class="line">JOIN employee_projects ep ON e.employee_id = ep.employee_id</span><br><span class="line">JOIN projects p ON ep.project_id = p.project_id;</span><br></pre></td></tr></table></figure></p>
<p><strong>注意事项</strong>： 1. 表别名通常使用简短的字母或单词（如e表示employees） 2. 别名可以使用AS关键字指定，也可以直接在表名后空格跟别名 3. 一旦定义了表别名，在查询中必须使用别名引用该表的列 4. 当不同表中有相同名称的列时，必须使用表名或表别名限定列名</p>
<h3 id="自然联结natural-join自动匹配同名同类型字段">自然联结（NATURAL JOIN，自动匹配同名同类型字段）</h3>
<p>自然联结会自动基于两个表中名称相同且数据类型兼容的列创建关联条件。</p>
<p><strong>语法</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT 列名</span><br><span class="line">FROM 表1</span><br><span class="line">NATURAL JOIN 表2;</span><br></pre></td></tr></table></figure></p>
<p><strong>示例</strong>： 如果employees表和departments表都有一个名为department_id的列，自然联结会自动基于这个列进行关联：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 自然联结示例</span><br><span class="line">SELECT employee_id, name, department_name</span><br><span class="line">FROM employees</span><br><span class="line">NATURAL JOIN departments;</span><br></pre></td></tr></table></figure>
<p><strong>注意事项</strong>： 1. 自然联结依赖于列名的匹配，可能导致意外的结果 2. 不推荐在生产环境中使用自然联结，因为它隐藏了具体的关联条件 3. 如果表结构发生变化（如添加新的同名列），可能会破坏现有查询 4. 使用显式的INNER JOIN和ON子句可以提供更好的可读性和控制</p>
<h3 id="外部联结leftrightfull-join保留左右全表数据">外部联结（LEFT/RIGHT/FULL JOIN，保留左/右/全表数据）</h3>
<p>外部联结不仅返回满足关联条件的行，还会保留一个表或两个表中不匹配的行。</p>
<p><strong>类型与语法</strong>：</p>
<table style="width:100%;">
<colgroup>
<col style="width: 42%" />
<col style="width: 28%" />
<col style="width: 28%" />
</colgroup>
<thead>
<tr class="header">
<th>联结类型</th>
<th>语法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>LEFT JOIN<br>（左联结）</td>
<td>SELECT * FROM 左表 LEFT JOIN 右表 ON 条件</td>
<td>返回左表所有行，右表匹配行，不匹配部分为NULL</td>
</tr>
<tr class="even">
<td>RIGHT JOIN<br>（右联结）</td>
<td>SELECT * FROM 左表 RIGHT JOIN 右表 ON 条件</td>
<td>返回右表所有行，左表匹配行，不匹配部分为NULL</td>
</tr>
<tr class="odd">
<td>FULL JOIN<br>（全联结）</td>
<td>SELECT * FROM 左表 FULL JOIN 右表 ON 条件</td>
<td>返回两表所有行，不匹配部分为NULL（MySQL不直接支持）</td>
</tr>
</tbody>
</table>
<p><strong>示例1：左联结（LEFT JOIN）</strong> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-- 查询所有员工及其所属部门，包括未分配部门的员工</span><br><span class="line">SELECT </span><br><span class="line">  e.employee_id AS 员工ID,</span><br><span class="line">  e.name AS 员工姓名,</span><br><span class="line">  d.department_name AS 部门名称</span><br><span class="line">FROM employees e</span><br><span class="line">LEFT JOIN departments d ON e.department_id = d.department_id;</span><br></pre></td></tr></table></figure></p>
<p><strong>示例2：右联结（RIGHT JOIN）</strong> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-- 查询所有部门及其员工，包括没有员工的部门</span><br><span class="line">SELECT </span><br><span class="line">  d.department_id AS 部门ID,</span><br><span class="line">  d.department_name AS 部门名称,</span><br><span class="line">  e.employee_id AS 员工ID,</span><br><span class="line">  e.name AS 员工姓名</span><br><span class="line">FROM employees e</span><br><span class="line">RIGHT JOIN departments d ON e.department_id = d.department_id;</span><br></pre></td></tr></table></figure></p>
<p><strong>示例3：模拟全联结（MySQL不直接支持FULL JOIN）</strong> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">-- 使用UNION模拟全联结</span><br><span class="line">SELECT </span><br><span class="line">  d.department_id AS 部门ID,</span><br><span class="line">  d.department_name AS 部门名称,</span><br><span class="line">  e.employee_id AS 员工ID,</span><br><span class="line">  e.name AS 员工姓名</span><br><span class="line">FROM employees e</span><br><span class="line">LEFT JOIN departments d ON e.department_id = d.department_id</span><br><span class="line">UNION</span><br><span class="line">SELECT </span><br><span class="line">  d.department_id AS 部门ID,</span><br><span class="line">  d.department_name AS 部门名称,</span><br><span class="line">  e.employee_id AS 员工ID,</span><br><span class="line">  e.name AS 员工姓名</span><br><span class="line">FROM employees e</span><br><span class="line">RIGHT JOIN departments d ON e.department_id = d.department_id</span><br><span class="line">WHERE e.employee_id IS NULL;</span><br></pre></td></tr></table></figure></p>
<p><strong>注意事项</strong>： 1. LEFT JOIN和RIGHT JOIN是互补的，可以根据需要选择合适的主表 2. MySQL不直接支持FULL JOIN，需要使用UNION和LEFT/RIGHT JOIN组合实现 3. 外部联结常用于查找“缺失”数据，如未分配任务的员工、没有员工的部门等 4. 在WHERE子句中过滤外部联结的结果时要特别小心，避免意外将外部联结转换为内部联结</p>
<h3 id="高级联结多表联结自联结">高级联结（多表联结、自联结）</h3>
<h4 id="多表联结">多表联结</h4>
<p>在一个查询中可以联结三个或更多的表，按照业务需求组合多个数据源。</p>
<p><strong>示例</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">-- 三表联结查询：员工、部门和项目信息</span><br><span class="line">SELECT </span><br><span class="line">  e.employee_id AS 员工ID,</span><br><span class="line">  e.name AS 员工姓名,</span><br><span class="line">  d.department_name AS 部门名称,</span><br><span class="line">  p.project_name AS 项目名称,</span><br><span class="line">  ep.role AS 在项目中的角色</span><br><span class="line">FROM employees e</span><br><span class="line">JOIN departments d ON e.department_id = d.department_id</span><br><span class="line">JOIN employee_projects ep ON e.employee_id = ep.employee_id</span><br><span class="line">JOIN projects p ON ep.project_id = p.project_id</span><br><span class="line">WHERE p.start_date &gt; &#x27;2023-01-01&#x27;</span><br><span class="line">ORDER BY e.department_id, e.employee_id;</span><br></pre></td></tr></table></figure></p>
<h4 id="自联结self-join">自联结（Self-Join）</h4>
<p>自联结是将一个表与自身联结，通常用于处理表中的层级关系或比较表中的行。</p>
<p><strong>示例1：查询员工及其经理信息</strong> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-- 自联结查询：找出每个员工及其经理</span><br><span class="line">SELECT </span><br><span class="line">  e.employee_id AS 员工ID,</span><br><span class="line">  e.name AS 员工姓名,</span><br><span class="line">  m.employee_id AS 经理ID,</span><br><span class="line">  m.name AS 经理姓名</span><br><span class="line">FROM employees e</span><br><span class="line">LEFT JOIN employees m ON e.manager_id = m.employee_id;</span><br></pre></td></tr></table></figure></p>
<p><strong>示例2：查找薪资高于同部门平均水平的员工</strong> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">-- 自联结结合子查询：找出薪资高于部门平均的员工</span><br><span class="line">SELECT </span><br><span class="line">  e.employee_id AS 员工ID,</span><br><span class="line">  e.name AS 员工姓名,</span><br><span class="line">  e.department_id AS 部门ID,</span><br><span class="line">  e.salary AS 员工薪资,</span><br><span class="line">  d.avg_salary AS 部门平均薪资</span><br><span class="line">FROM employees e</span><br><span class="line">JOIN (</span><br><span class="line">  SELECT department_id, AVG(salary) AS avg_salary</span><br><span class="line">  FROM employees</span><br><span class="line">  GROUP BY department_id</span><br><span class="line">) d ON e.department_id = d.department_id</span><br><span class="line">WHERE e.salary &gt; d.avg_salary</span><br><span class="line">ORDER BY e.department_id, e.salary DESC;</span><br></pre></td></tr></table></figure></p>
<p><strong>高级联结注意事项</strong>： 1. 多表联结时，注意联结顺序可能影响查询性能 2. 使用适当的索引可以显著提高联结操作的性能 3. 自联结时必须使用表别名来区分同一表的不同实例 4. 复杂的多表联结可能导致性能问题，应考虑使用子查询或视图优化 5. 联结多个大表时，应评估查询的复杂度和执行计划</p>
<h2 id="组合查询union">组合查询：UNION</h2>
<p>组合查询（UNION）是SQL中用于合并两个或多个SELECT语句结果集的操作符。它允许将多个查询的结果作为一个组合结果集返回，常用于从不同表或同一表的不同条件下获取相关数据并合并展示。</p>
<h3 id="union基本用法合并多个查询结果集">UNION基本用法（合并多个查询结果集）</h3>
<p>UNION操作符用于合并两个或多个SELECT语句的结果集，并自动去除重复的行。</p>
<p><strong>语法</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT 列1, 列2, ... FROM 表1 [WHERE 条件]</span><br><span class="line">UNION</span><br><span class="line">SELECT 列1, 列2, ... FROM 表2 [WHERE 条件];</span><br></pre></td></tr></table></figure></p>
<p><strong>使用条件</strong>： 1. 每个SELECT语句必须具有相同数量的列 2. 对应列的数据类型必须兼容 3. 通常结果集中的列名由第一个SELECT语句决定</p>
<p><strong>示例1：合并两个表的查询结果</strong> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">-- 查询所有员工和客户的联系信息</span><br><span class="line">SELECT </span><br><span class="line">  &#x27;employee&#x27; AS 类型,</span><br><span class="line">  employee_id AS ID,</span><br><span class="line">  name AS 姓名,</span><br><span class="line">  email AS 邮箱,</span><br><span class="line">  phone AS 电话</span><br><span class="line">FROM employees</span><br><span class="line">WHERE department = &#x27;销售&#x27;</span><br><span class="line">UNION</span><br><span class="line">SELECT </span><br><span class="line">  &#x27;customer&#x27; AS 类型,</span><br><span class="line">  customer_id AS ID,</span><br><span class="line">  customer_name AS 姓名,</span><br><span class="line">  customer_email AS 邮箱,</span><br><span class="line">  customer_phone AS 电话</span><br><span class="line">FROM customers</span><br><span class="line">WHERE region = &#x27;华东&#x27;;</span><br></pre></td></tr></table></figure></p>
<p><strong>示例2：同一表中不同条件的结果合并</strong> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">-- 查询薪资高于8000的员工和工作年限超过5年的员工</span><br><span class="line">SELECT </span><br><span class="line">  employee_id,</span><br><span class="line">  name,</span><br><span class="line">  salary,</span><br><span class="line">  hire_date,</span><br><span class="line">  &#x27;高薪员工&#x27; AS 类型</span><br><span class="line">FROM employees</span><br><span class="line">WHERE salary &gt; 8000</span><br><span class="line">UNION</span><br><span class="line">SELECT </span><br><span class="line">  employee_id,</span><br><span class="line">  name,</span><br><span class="line">  salary,</span><br><span class="line">  hire_date,</span><br><span class="line">  &#x27;资深员工&#x27; AS 类型</span><br><span class="line">FROM employees</span><br><span class="line">WHERE DATEDIFF(CURDATE(), hire_date) / 365 &gt; 5;</span><br></pre></td></tr></table></figure></p>
<p><strong>UNION使用注意事项</strong>： 1. UNION默认会去除重复行，这会增加额外的处理开销 2. 每个SELECT语句必须返回相同数量的列，且对应列的数据类型必须兼容 3. 列名可以不同，但结果集将使用第一个SELECT语句的列名 4. 可以使用ORDER BY子句对最终结果进行排序，但必须放在最后一个SELECT语句之后 5. ORDER BY影响的是整个组合后的结果集，而不是单个SELECT语句的结果</p>
<h3 id="union与union-all的区别去重-vs-保留重复">UNION与UNION ALL的区别（去重 vs 保留重复）</h3>
<p><strong>UNION ALL</strong> 是UNION的一个变种，它不会去除结果集中的重复行，直接合并所有行。</p>
<p><strong>语法</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT 列1, 列2, ... FROM 表1 [WHERE 条件]</span><br><span class="line">UNION ALL</span><br><span class="line">SELECT 列1, 列2, ... FROM 表2 [WHERE 条件];</span><br></pre></td></tr></table></figure></p>
<p><strong>UNION与UNION ALL的区别对比表</strong>：</p>
<table>
<thead>
<tr class="header">
<th>特性</th>
<th>UNION</th>
<th>UNION ALL</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>重复行处理</td>
<td>自动去除重复行</td>
<td>保留所有行（包括重复行）</td>
</tr>
<tr class="even">
<td>性能</td>
<td>较低（需要额外的去重操作）</td>
<td>较高（不需要去重）</td>
</tr>
<tr class="odd">
<td>适用场景</td>
<td>需要唯一结果集</td>
<td>需要包含所有结果，包括重复</td>
</tr>
<tr class="even">
<td>执行速度</td>
<td>较慢</td>
<td>较快</td>
</tr>
<tr class="odd">
<td>结果集大小</td>
<td>可能小于各SELECT语句结果集之和</td>
<td>等于各SELECT语句结果集之和</td>
</tr>
</tbody>
</table>
<p><strong>示例1：UNION ALL示例</strong> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 保留所有重复行的合并查询</span><br><span class="line">SELECT product_name, category, price FROM products WHERE category = &#x27;电子产品&#x27;</span><br><span class="line">UNION ALL</span><br><span class="line">SELECT product_name, category, price FROM products WHERE price &gt; 1000;</span><br></pre></td></tr></table></figure></p>
<p><strong>示例2：对比UNION和UNION ALL的结果差异</strong> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">-- 创建一个示例表</span><br><span class="line">CREATE TABLE test_union (id INT, name VARCHAR(50));</span><br><span class="line">INSERT INTO test_union VALUES (1, &#x27;A&#x27;), (2, &#x27;B&#x27;), (3, &#x27;C&#x27;);</span><br><span class="line"></span><br><span class="line">-- UNION示例（去重）</span><br><span class="line">SELECT id, name FROM test_union</span><br><span class="line">UNION</span><br><span class="line">SELECT id, name FROM test_union;</span><br><span class="line">-- 结果：3行（去重后）</span><br><span class="line"></span><br><span class="line">-- UNION ALL示例（保留重复）</span><br><span class="line">SELECT id, name FROM test_union</span><br><span class="line">UNION ALL</span><br><span class="line">SELECT id, name FROM test_union;</span><br><span class="line">-- 结果：6行（保留所有重复）</span><br></pre></td></tr></table></figure></p>
<p><strong>使用建议</strong>： 1. 如果确认查询结果不会有重复，或需要保留所有重复行，应使用UNION ALL以提高性能 2. 对于大数据集的合并操作，UNION ALL的性能优势更为明显 3. 当需要唯一结果集时才使用UNION 4. 无论使用哪种方式，都应确保各个SELECT语句返回兼容的列结构</p>
<p><strong>高级用法示例</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">-- 使用UNION ALL和子查询进行复杂数据合并和统计</span><br><span class="line">SELECT </span><br><span class="line">  month, </span><br><span class="line">  SUM(sales) AS total_sales,</span><br><span class="line">  SUM(CASE WHEN region = &#x27;北区&#x27; THEN sales ELSE 0 END) AS north_sales,</span><br><span class="line">  SUM(CASE WHEN region = &#x27;南区&#x27; THEN sales ELSE 0 END) AS south_sales</span><br><span class="line">FROM (</span><br><span class="line">  -- 北区销售数据</span><br><span class="line">  SELECT </span><br><span class="line">    DATE_FORMAT(order_date, &#x27;%Y-%m&#x27;) AS month,</span><br><span class="line">    &#x27;北区&#x27; AS region,</span><br><span class="line">    SUM(order_amount) AS sales</span><br><span class="line">  FROM orders</span><br><span class="line">  WHERE region = &#x27;北区&#x27; AND order_date BETWEEN &#x27;2023-01-01&#x27; AND &#x27;2023-12-31&#x27;</span><br><span class="line">  GROUP BY DATE_FORMAT(order_date, &#x27;%Y-%m&#x27;)</span><br><span class="line">  </span><br><span class="line">  UNION ALL</span><br><span class="line">  </span><br><span class="line">  -- 南区销售数据</span><br><span class="line">  SELECT </span><br><span class="line">    DATE_FORMAT(order_date, &#x27;%Y-%m&#x27;) AS month,</span><br><span class="line">    &#x27;南区&#x27; AS region,</span><br><span class="line">    SUM(order_amount) AS sales</span><br><span class="line">  FROM orders</span><br><span class="line">  WHERE region = &#x27;南区&#x27; AND order_date BETWEEN &#x27;2023-01-01&#x27; AND &#x27;2023-12-31&#x27;</span><br><span class="line">  GROUP BY DATE_FORMAT(order_date, &#x27;%Y-%m&#x27;)</span><br><span class="line">) AS regional_sales</span><br><span class="line">GROUP BY month</span><br><span class="line">ORDER BY month;</span><br><span class="line"></span><br><span class="line">### UNION的性能优化建议</span><br><span class="line"></span><br><span class="line">1. **优先使用UNION ALL**：如果不需要去重，UNION ALL比UNION效率高很多</span><br><span class="line">2. **限制结果集大小**：在每个SELECT语句中使用WHERE条件过滤不必要的数据</span><br><span class="line">3. **合理索引**：为各个SELECT语句中的WHERE条件字段创建适当的索引</span><br><span class="line">4. **避免在UNION中使用复杂函数**：尽量在UNION之前处理数据转换和计算</span><br><span class="line">5. **考虑使用临时表**：对于非常复杂的UNION查询，可以考虑使用临时表存储中间结果</span><br><span class="line">6. **列数精简**：只选择必要的列，减少数据传输量</span><br><span class="line"></span><br><span class="line">## 全文本搜索（基础用法）</span><br><span class="line"></span><br><span class="line">全文本搜索是MySQL提供的一种高级搜索功能，用于在文本数据中进行复杂的关键词搜索，比简单的LIKE查询更强大、更高效。</span><br><span class="line"></span><br><span class="line">### 全文本搜索的基本概念与作用</span><br><span class="line"></span><br><span class="line">**全文本搜索的概念**：</span><br><span class="line">全文本搜索是一种基于文本内容的搜索技术，它能够在文本数据中查找包含指定关键词的记录，并根据相关性对结果进行排序。</span><br><span class="line"></span><br><span class="line">**全文本搜索的主要作用**：</span><br><span class="line">1. 实现复杂的文本内容检索</span><br><span class="line">2. 支持关键词、短语和布尔逻辑搜索</span><br><span class="line">3. 根据相关性对结果排序</span><br><span class="line">4. 比LIKE查询（特别是使用通配符的查询）效率更高</span><br><span class="line">5. 支持自然语言搜索模式</span><br><span class="line"></span><br><span class="line">**适用场景**：</span><br><span class="line">- 文章内容搜索</span><br><span class="line">- 产品描述搜索</span><br><span class="line">- 用户评论搜索</span><br><span class="line">- 日志分析</span><br><span class="line">- 文档管理系统</span><br><span class="line"></span><br><span class="line">### 创建全文本索引</span><br><span class="line"></span><br><span class="line">在使用全文本搜索之前，需要先为目标表创建全文本索引。</span><br><span class="line"></span><br><span class="line">**语法**：</span><br><span class="line">```mysql</span><br><span class="line">CREATE FULLTEXT INDEX 索引名 ON 表名(列名1, 列名2, ...);</span><br></pre></td></tr></table></figure></p>
<p><strong>示例</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-- 为文章表创建全文本索引</span><br><span class="line">CREATE TABLE articles (</span><br><span class="line">  id INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">  title VARCHAR(200),</span><br><span class="line">  content TEXT,</span><br><span class="line">  publish_date DATE</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">-- 在title和content列上创建全文本索引</span><br><span class="line">CREATE FULLTEXT INDEX idx_article_search ON articles(title, content);</span><br></pre></td></tr></table></figure></p>
<p><strong>注意事项</strong>： 1. 全文本索引只能用于MyISAM和InnoDB存储引擎 2. 仅适用于CHAR、VARCHAR和TEXT类型的列 3. 一个表可以有多个全文本索引，但通常在需要搜索的列上创建一个复合索引 4. 索引会占用额外的存储空间，但能显著提高搜索性能</p>
<h3 id="使用match-against进行全文本搜索">使用MATCH AGAINST进行全文本搜索</h3>
<p>全文本搜索主要通过MATCH()和AGAINST()函数实现。</p>
<p><strong>基本语法</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT 列名</span><br><span class="line">FROM 表名</span><br><span class="line">WHERE MATCH(列名1, 列名2, ...) AGAINST(&#x27;搜索关键词&#x27; [搜索模式]);</span><br></pre></td></tr></table></figure></p>
<p><strong>搜索模式</strong>： 1. <strong>自然语言模式（默认）</strong>：理解搜索短语的自然语言含义 2. <strong>布尔模式</strong>：使用布尔操作符组合关键词进行精确搜索 3. <strong>查询扩展模式</strong>：基于初始结果扩展搜索范围</p>
<h3 id="自然语言模式搜索默认">1. 自然语言模式搜索（默认）</h3>
<p><strong>语法</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT 列名</span><br><span class="line">FROM 表名</span><br><span class="line">WHERE MATCH(列名1, 列名2, ...) AGAINST(&#x27;搜索关键词&#x27;);</span><br></pre></td></tr></table></figure></p>
<p><strong>示例</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-- 在文章表中搜索包含&quot;数据库&quot;关键词的文章</span><br><span class="line">SELECT id, title, content</span><br><span class="line">FROM articles</span><br><span class="line">WHERE MATCH(title, content) AGAINST(&#x27;数据库&#x27;);</span><br><span class="line"></span><br><span class="line">-- 搜索包含多个关键词的文章（或关系）</span><br><span class="line">SELECT id, title, content</span><br><span class="line">FROM articles</span><br><span class="line">WHERE MATCH(title, content) AGAINST(&#x27;数据库 MySQL&#x27;);</span><br></pre></td></tr></table></figure></p>
<p><strong>自然语言模式特点</strong>： 1. 默认按相关性排序结果 2. 忽略常见词（停用词）如“a”、“the”、“and”等 3. 忽略出现频率过高的词（超过50%的行） 4. 不区分大小写（取决于字符集和排序规则）</p>
<h3 id="布尔模式搜索">2. 布尔模式搜索</h3>
<p>布尔模式支持更精确的控制，使用布尔操作符组合关键词。</p>
<p><strong>语法</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT 列名</span><br><span class="line">FROM 表名</span><br><span class="line">WHERE MATCH(列名1, 列名2, ...) AGAINST(&#x27;搜索条件&#x27; IN BOOLEAN MODE);</span><br></pre></td></tr></table></figure></p>
<p><strong>常用布尔操作符</strong>：</p>
<table>
<thead>
<tr class="header">
<th>操作符</th>
<th>作用</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>+</td>
<td>必须包含该词</td>
<td>+数据库 +MySQL</td>
</tr>
<tr class="even">
<td>-</td>
<td>必须不包含该词</td>
<td>+数据库 -Oracle</td>
</tr>
<tr class="odd">
<td>&gt;</td>
<td>提高该词的相关性</td>
<td>+数据库 &gt;MySQL</td>
</tr>
<tr class="even">
<td>&lt;</td>
<td>降低该词的相关性</td>
<td>+数据库 &lt;MySQL</td>
</tr>
<tr class="odd">
<td>*</td>
<td>词尾通配符</td>
<td>data* 匹配 data、database、databases等</td>
</tr>
<tr class="even">
<td>""</td>
<td>精确短语匹配</td>
<td>“数据库管理系统”</td>
</tr>
<tr class="odd">
<td>()</td>
<td>分组</td>
<td>+(数据库 OR MySQL) +优化</td>
</tr>
</tbody>
</table>
<p><strong>示例</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">-- 搜索必须包含&quot;数据库&quot;且不包含&quot;Oracle&quot;的文章</span><br><span class="line">SELECT id, title, content</span><br><span class="line">FROM articles</span><br><span class="line">WHERE MATCH(title, content) AGAINST(&#x27;+数据库 -Oracle&#x27; IN BOOLEAN MODE);</span><br><span class="line"></span><br><span class="line">-- 搜索必须包含&quot;MySQL优化&quot;这个短语的文章</span><br><span class="line">SELECT id, title, content</span><br><span class="line">FROM articles</span><br><span class="line">WHERE MATCH(title, content) AGAINST(&#x27;&quot;MySQL优化&quot;&#x27; IN BOOLEAN MODE);</span><br><span class="line"></span><br><span class="line">-- 搜索包含以&quot;数据&quot;开头的词和&quot;性能&quot;的文章</span><br><span class="line">SELECT id, title, content</span><br><span class="line">FROM articles</span><br><span class="line">WHERE MATCH(title, content) AGAINST(&#x27;+数据* +性能&#x27; IN BOOLEAN MODE);</span><br></pre></td></tr></table></figure></p>
<h3 id="查询扩展模式搜索">3. 查询扩展模式搜索</h3>
<p>查询扩展模式首先执行自然语言搜索，然后基于初始结果中的关键词进行二次搜索，以扩展搜索范围。</p>
<p><strong>语法</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT 列名</span><br><span class="line">FROM 表名</span><br><span class="line">WHERE MATCH(列名1, 列名2, ...) AGAINST(&#x27;搜索关键词&#x27; WITH QUERY EXPANSION);</span><br></pre></td></tr></table></figure></p>
<p><strong>示例</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 使用查询扩展模式搜索与&quot;数据库优化&quot;相关的文章</span><br><span class="line">SELECT id, title, content</span><br><span class="line">FROM articles</span><br><span class="line">WHERE MATCH(title, content) AGAINST(&#x27;数据库优化&#x27; WITH QUERY EXPANSION);</span><br></pre></td></tr></table></figure></p>
<p><strong>查询扩展模式特点</strong>： 1. 可能返回更多相关但不完全匹配的结果 2. 适用于需要扩大搜索范围的场景 3. 可能降低搜索精度，但提高召回率</p>
<h3 id="获取相关性得分">获取相关性得分</h3>
<p>可以通过在SELECT子句中包含MATCH() AGAINST()函数来获取结果的相关性得分。</p>
<p><strong>语法</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT 列名, MATCH(列名1, 列名2, ...) AGAINST(&#x27;搜索关键词&#x27;) AS relevance_score</span><br><span class="line">FROM 表名</span><br><span class="line">WHERE MATCH(列名1, 列名2, ...) AGAINST(&#x27;搜索关键词&#x27;);</span><br></pre></td></tr></table></figure></p>
<p><strong>示例</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-- 获取搜索结果及其相关性得分</span><br><span class="line">SELECT </span><br><span class="line">  id, </span><br><span class="line">  title, </span><br><span class="line">  MATCH(title, content) AGAINST(&#x27;MySQL优化&#x27; IN BOOLEAN MODE) AS relevance_score</span><br><span class="line">FROM articles</span><br><span class="line">WHERE MATCH(title, content) AGAINST(&#x27;MySQL优化&#x27; IN BOOLEAN MODE)</span><br><span class="line">ORDER BY relevance_score DESC;</span><br></pre></td></tr></table></figure></p>
<h3 id="全文本搜索的注意事项">全文本搜索的注意事项</h3>
<ol type="1">
<li><strong>索引更新</strong>：
<ul>
<li>当表中数据发生变化时，全文本索引会自动更新</li>
<li>对于大数据量插入，考虑先禁用索引，插入数据后再重建索引</li>
</ul></li>
<li><strong>性能优化</strong>：
<ul>
<li>只对需要搜索的列创建全文本索引</li>
<li>避免在小表上使用全文本搜索（直接使用LIKE可能更简单）</li>
<li>对于非常大的表，考虑使用专门的搜索引擎如Elasticsearch</li>
</ul></li>
<li><strong>配置参数</strong>：
<ul>
<li>MySQL默认有一些配置参数控制全文本搜索的行为</li>
<li>可以调整ft_min_word_len参数设置最小搜索词长度（默认4个字符）</li>
<li>可以自定义停用词列表</li>
</ul></li>
<li><strong>限制</strong>：
<ul>
<li>全文本索引有大小限制</li>
<li>搜索结果可能受到MySQL停用词列表的影响</li>
<li>对于不支持全文本索引的存储引擎，需要使用其他方法</li>
</ul></li>
</ol>
<h3 id="全文本搜索与like查询的对比">全文本搜索与LIKE查询的对比</h3>
<table>
<thead>
<tr class="header">
<th>特性</th>
<th>全文本搜索</th>
<th>LIKE查询</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>搜索效率</td>
<td>高（使用索引）</td>
<td>低（尤其是以通配符开头的查询）</td>
</tr>
<tr class="even">
<td>搜索功能</td>
<td>强大（支持自然语言、布尔逻辑）</td>
<td>简单（仅支持通配符匹配）</td>
</tr>
<tr class="odd">
<td>相关性排序</td>
<td>支持</td>
<td>不支持</td>
</tr>
<tr class="even">
<td>适用场景</td>
<td>大型文本搜索</td>
<td>简单模式匹配</td>
</tr>
<tr class="odd">
<td>索引支持</td>
<td>需要全文本索引</td>
<td>可使用普通索引（有限）</td>
</tr>
<tr class="even">
<td>资源消耗</td>
<td>索引创建时较高，搜索时较低</td>
<td>搜索时较高</td>
</tr>
</tbody>
</table>
<p><strong>示例对比</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-- 使用全文本搜索</span><br><span class="line">SELECT id, title FROM articles </span><br><span class="line">WHERE MATCH(title, content) AGAINST(&#x27;MySQL性能优化&#x27;);</span><br><span class="line"></span><br><span class="line">-- 等效的LIKE查询</span><br><span class="line">SELECT id, title FROM articles </span><br><span class="line">WHERE title LIKE &#x27;%MySQL%&#x27; OR content LIKE &#x27;%MySQL%&#x27;</span><br><span class="line">   OR title LIKE &#x27;%性能优化%&#x27; OR content LIKE &#x27;%性能优化%&#x27;;</span><br></pre></td></tr></table></figure></p>
<h1 id="数据操作增删改">数据操作（增删改）</h1>
<h2 id="插入数据insert">插入数据：INSERT</h2>
<h3 id="插入单行数据insert-into-表列1-values值1">插入单行数据（<code>INSERT INTO 表(列1) VALUES(值1)</code>）</h3>
<h3 id="插入多行数据insert-into-表-values值1值2">插入多行数据（<code>INSERT INTO 表 VALUES(值1),(值2)</code>）</h3>
<h3 id="插入查询结果insert-...-select批量复制数据">插入查询结果（<code>INSERT ... SELECT</code>，批量复制数据）</h3>
<h2 id="更新数据update">更新数据：UPDATE</h2>
<ul>
<li>基本用法：<code>UPDATE 表 SET 列=值 WHERE 条件</code></li>
<li>注意事项：必须加WHERE条件（避免全表更新）</li>
</ul>
<h2 id="删除数据delete">删除数据：DELETE</h2>
<ul>
<li>基本用法：<code>DELETE FROM 表 WHERE 条件</code></li>
<li>注意事项：加WHERE条件（避免全表删除）、与<code>TRUNCATE</code>的区别</li>
</ul>
<h2 id="事务处理基础">事务处理基础</h2>
<h3 id="事务的acid特性原子性一致性隔离性持久性">事务的ACID特性（原子性、一致性、隔离性、持久性）</h3>
<h3 id="事务操作start-transactioncommit提交rollback回滚">事务操作：<code>START TRANSACTION</code>/<code>COMMIT</code>（提交）/<code>ROLLBACK</code>（回滚）</h3>
<h1 id="表操作创建修改删除">表操作（创建、修改、删除）</h1>
<h2 id="创建表create-table">创建表：CREATE TABLE</h2>
<h3 id="基本语法指定字段名数据类型约束">基本语法（指定字段名、数据类型、约束）</h3>
<h3 id="表约束保证数据完整性">表约束（保证数据完整性）</h3>
<ul>
<li>实体完整性：PRIMARY KEY（主键，唯一标识记录）</li>
<li>参照完整性：FOREIGN KEY（外键，关联其他表主键）</li>
<li>域完整性：NOT NULL（非空）、UNIQUE（唯一）、DEFAULT（默认值）</li>
</ul>
<h3 id="自增字段auto_increment主键常用">自增字段：AUTO_INCREMENT（主键常用）</h3>
<h2 id="更新表alter-table添加修改删除字段约束">更新表：ALTER TABLE（添加/修改/删除字段、约束）</h2>
<h2 id="删除表drop-table谨慎使用不可逆">删除表：DROP TABLE（谨慎使用，不可逆）</h2>
<h2 id="重命名表rename-table">重命名表：RENAME TABLE</h2>
<h2 id="索引基础性能优化入门">索引基础（性能优化入门）</h2>
<h3 id="索引的作用加速查询">索引的作用（加速查询）</h3>
<h3 id="创建索引create-indexcreate-unique-index">创建索引：<code>CREATE INDEX</code>/<code>CREATE UNIQUE INDEX</code></h3>
<h3 id="删除索引drop-index">删除索引：<code>DROP INDEX</code></h3>
<h1 id="进阶理论与技术实操深化">进阶理论与技术（实操深化）</h1>
<h2 id="数据库存储">7.1 数据库存储</h2>
<h3 id="存储策略数据文件的存储方式">7.1.1 存储策略（数据文件的存储方式）</h3>
<h3 id="常用存储引擎innodbmyisam">7.1.2 常用存储引擎（InnoDB、MyISAM）</h3>
<ul>
<li>核心区别（事务支持、索引类型、锁机制）</li>
<li>适用场景选择</li>
</ul>
<h2 id="数据库索引进阶">7.2 数据库索引进阶</h2>
<h3 id="索引原理快速查找的核心逻辑">7.2.1 索引原理（快速查找的核心逻辑）</h3>
<h3 id="索引类型b树索引哈希索引全文索引等">7.2.2 索引类型（B树索引、哈希索引、全文索引等）</h3>
<ul>
<li>B树/B+树索引（MySQL默认，适用于范围查询）</li>
<li>哈希索引（适用于等值查询，局限性说明）</li>
</ul>
<h3 id="索引管理查看索引优化索引">7.2.3 索引管理（查看索引、优化索引）</h3>
<h2 id="查询处理与优化">7.3 查询处理与优化</h2>
<h3 id="查询处理过程解析优化执行">7.3.1 查询处理过程（解析→优化→执行）</h3>
<h3 id="基础优化技巧避免select-合理建索引优化where条件">7.3.2 基础优化技巧（避免<code>SELECT *</code>、合理建索引、优化WHERE条件）</h3>
<h3 id="代数优化与物理优化简单理解改写查询语句选择最优执行计划">7.3.3 代数优化与物理优化（简单理解：改写查询语句、选择最优执行计划）</h3>
<h2 id="事务处理技术进阶">7.4 事务处理技术进阶</h2>
<h3 id="事务调度及其正确性避免脏读不可重复读幻读">7.4.1 事务调度及其正确性（避免脏读、不可重复读、幻读）</h3>
<h3 id="并发控制锁机制基础行锁表锁">7.4.2 并发控制（锁机制基础：行锁、表锁）</h3>
<h3 id="事务隔离级别read-uncommittedread-committedrepeatable-readserializable">7.4.3 事务隔离级别（READ UNCOMMITTED→READ COMMITTED→REPEATABLE READ→SERIALIZABLE）</h3>
<h3 id="恢复技术事务日志的作用崩溃后数据恢复">7.4.4 恢复技术（事务日志的作用：崩溃后数据恢复）</h3>
<h2 id="数据库完整性进阶">7.5 数据库完整性进阶</h2>
<ul>
<li>实体完整性（主键约束强化）</li>
<li>参照完整性（外键约束的级联操作：ON DELETE/UPDATE）</li>
<li>其他完整性约束（CHECK约束、自定义约束）</li>
</ul>
<h1 id="高级数据库特性">8. 高级数据库特性</h1>
<h2 id="视图">8.1 视图</h2>
<h3 id="创建视图create-view简化复杂查询">8.1.1 创建视图：<code>CREATE VIEW</code>（简化复杂查询）</h3>
<h3 id="使用与修改视图select-from-视图alter-view">8.1.2 使用与修改视图（<code>SELECT * FROM 视图</code>/<code>ALTER VIEW</code>）</h3>
<h3 id="视图的优缺点">8.1.3 视图的优缺点</h3>
<h2 id="存储过程">8.2 存储过程</h2>
<h3 id="创建存储过程create-procedure封装复杂逻辑">8.2.1 创建存储过程：<code>CREATE PROCEDURE</code>（封装复杂逻辑）</h3>
<h3 id="调用存储过程call-存储过程名">8.2.2 调用存储过程：<code>CALL 存储过程名()</code></h3>
<h3 id="存储过程的参数inoutinout">8.2.3 存储过程的参数（IN/OUT/INOUT）</h3>
<h2 id="游标遍历查询结果集">8.3 游标（遍历查询结果集）</h2>
<h2 id="触发器">8.4 触发器</h2>
<h3 id="创建触发器create-trigger自动执行逻辑">8.4.1 创建触发器：<code>CREATE TRIGGER</code>（自动执行逻辑）</h3>
<h3 id="触发时机beforeafter与触发类型insertupdatedelete">8.4.2 触发时机（BEFORE/AFTER）与触发类型（INSERT/UPDATE/DELETE）</h3>
<h1 id="数据库管理与维护">9. 数据库管理与维护</h1>
<h2 id="访问控制与用户管理">9.1 访问控制与用户管理</h2>
<h3 id="创建用户create-user">9.1.1 创建用户：<code>CREATE USER</code></h3>
<h3 id="授权grant-权限-on-数据库.表-to-用户">9.1.2 授权：<code>GRANT 权限 ON 数据库.表 TO 用户</code></h3>
<h3 id="撤销权限revoke-权限-on-数据库.表-from-用户">9.1.3 撤销权限：<code>REVOKE 权限 ON 数据库.表 FROM 用户</code></h3>
<h3 id="删除用户drop-user">9.1.4 删除用户：<code>DROP USER</code></h3>
<h2 id="数据备份">9.2 数据备份</h2>
<h3 id="逻辑备份mysqldump命令">9.2.1 逻辑备份（<code>mysqldump</code>命令）</h3>
<h3 id="恢复数据source命令mysql--u用户名--p-数据库-备份文件">9.2.2 恢复数据（<code>SOURCE</code>命令/<code>mysql -u用户名 -p 数据库 &lt; 备份文件</code>）</h3>
<h2 id="数据库维护">9.3 数据库维护</h2>
<ul>
<li>优化表：<code>OPTIMIZE TABLE</code></li>
<li>检查表：<code>CHECK TABLE</code></li>
</ul>
<h2 id="问题诊断与日志">9.4 问题诊断与日志</h2>
<h3 id="诊断启动问题配置文件检查端口占用排查">9.4.1 诊断启动问题（配置文件检查、端口占用排查）</h3>
<h3 id="查看日志文件错误日志查询日志慢查询日志">9.4.2 查看日志文件（错误日志、查询日志、慢查询日志）</h3>
<h2 id="性能改善">9.5 性能改善</h2>
<ul>
<li>慢查询优化（分析慢查询日志）</li>
<li>索引优化（避免无效索引、覆盖索引使用）</li>
<li>配置参数调整（基础参数：连接数、缓存大小）</li>
</ul>
<h1 id="深入理论拓展可选进阶学习者">10. 深入理论拓展（可选，进阶学习者）</h1>
<h2 id="阿姆斯特朗公理体系函数依赖的推理规则">10.1 阿姆斯特朗公理体系（函数依赖的推理规则）</h2>
<h2 id="模式分解无损连接分解保持函数依赖分解">10.2 模式分解（无损连接分解、保持函数依赖分解）</h2>
<h2 id="多值依赖与第四范式4nf">10.3 多值依赖与第四范式（4NF）</h2>
<h2 id="其他高级范式bcnf等">10.4 其他高级范式（BCNF等）</h2>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://jiejiejiang2004.github.io/2025/10/29/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84Fenwick/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="jiejiejiang">
      <meta itemprop="description" content="现在开始，还来得及">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/10/29/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84Fenwick/" class="post-title-link" itemprop="url">Fenwick 树状数组</a>
        </h2>

        <div class="post-meta">

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-10-29 00:00:00 / 修改时间：23:27:32" itemprop="dateCreated datePublished" datetime="2025-10-29T00:00:00+08:00">2025-10-29</time>
            </span>

          
            <span id="/2025/10/29/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84Fenwick/" class="post-meta-item leancloud_visitors" data-flag-title="Fenwick 树状数组" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2025/10/29/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84Fenwick/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2025/10/29/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84Fenwick/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4.8k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>17 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="fenwick-树状数组">Fenwick 树状数组</h1>
<p><strong>原理</strong></p>
<p><strong>1.</strong> <strong>简单题</strong></p>
<p><a href="#1"><strong>洛谷 P3374 【模板】树状数组 1</strong></a></p>
<p><a href="#2"><strong>洛谷 P3368 【模板】树状数组 2</strong></a></p>
<p><a href="#3"><strong>洛谷 P5057 [CQOI2006] 简单题</strong></a></p>
<p><a href="#4"><strong>洛谷 P2068 统计和</strong></a></p>
<p><a href="#5"><strong>洛谷 P4939 Agent2</strong></a></p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2025/10/29/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84Fenwick/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://jiejiejiang2004.github.io/2024/11/11/SCAU%20%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80%20%E6%95%99%E6%9D%90%E4%B9%A0%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="jiejiejiang">
      <meta itemprop="description" content="现在开始，还来得及">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/11/11/SCAU%20%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80%20%E6%95%99%E6%9D%90%E4%B9%A0%E9%A2%98/" class="post-title-link" itemprop="url">SCAU 高级程序设计语言 教材习题</a>
        </h2>

        <div class="post-meta">

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-11-11 00:00:00" itemprop="dateCreated datePublished" datetime="2024-11-11T00:00:00+08:00">2024-11-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-10-30 10:11:28" itemprop="dateModified" datetime="2025-10-30T10:11:28+08:00">2025-10-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">学习</span></a>
                </span>
            </span>

          
            <span id="/2024/11/11/SCAU%20%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80%20%E6%95%99%E6%9D%90%E4%B9%A0%E9%A2%98/" class="post-meta-item leancloud_visitors" data-flag-title="SCAU 高级程序设计语言 教材习题" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2024/11/11/SCAU%20%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80%20%E6%95%99%E6%9D%90%E4%B9%A0%E9%A2%98/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2024/11/11/SCAU%20%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80%20%E6%95%99%E6%9D%90%E4%B9%A0%E9%A2%98/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>9.3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>34 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="scau-高级程序设计语言-教材习题">SCAU 高级程序设计语言 教材习题</h1>
<h2 id="第三章">第三章</h2>
<h3 id="分期还款加强版">18041 分期还款(加强版)</h3>
<p><strong>Description</strong></p>
<p>从银行贷款金额为 <span class="math inline"><em>d</em></span>，准备每月还款额为 <span class="math inline"><em>p</em></span>，月利率为 <span class="math inline"><em>r</em></span> 。请编写程序输入这三个数值，计算并输出多少个月能够还清贷款，输出时保留 <span class="math inline">1</span> 位小数。 如果无法还清，请输出 “God” 计算公式如下：</p>
<p><span class="math display">$$
m = \frac{\log{\frac{p}{p - d \times r}}}{\log{(1+r)}}
$$</span></p>
<p><strong>输入格式</strong></p>
<p>三个数，分别为货款金额、每月还款和月利率，以空格分隔，均为非负数，其中 <span class="math inline"><em>d</em>，<em>p</em>，<em>r</em> &gt;  = 0</span></p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2024/11/11/SCAU%20%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80%20%E6%95%99%E6%9D%90%E4%B9%A0%E9%A2%98/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://jiejiejiang2004.github.io/2024/08/19/%E9%A2%98%E8%A7%A3%EF%BC%9A%E7%89%9B%E5%AE%A2%E5%91%A8%E8%B5%9B%20Round%2056%EF%BC%88A-E%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="jiejiejiang">
      <meta itemprop="description" content="现在开始，还来得及">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/08/19/%E9%A2%98%E8%A7%A3%EF%BC%9A%E7%89%9B%E5%AE%A2%E5%91%A8%E8%B5%9B%20Round%2056%EF%BC%88A-E%EF%BC%89/" class="post-title-link" itemprop="url">题解：牛客周赛 Round 56（A-E）</a>
        </h2>

        <div class="post-meta">

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-08-19 00:00:00" itemprop="dateCreated datePublished" datetime="2024-08-19T00:00:00+08:00">2024-08-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-10-29 23:27:25" itemprop="dateModified" datetime="2025-10-29T23:27:25+08:00">2025-10-29</time>
              </span>

          
            <span id="/2024/08/19/%E9%A2%98%E8%A7%A3%EF%BC%9A%E7%89%9B%E5%AE%A2%E5%91%A8%E8%B5%9B%20Round%2056%EF%BC%88A-E%EF%BC%89/" class="post-meta-item leancloud_visitors" data-flag-title="题解：牛客周赛 Round 56（A-E）" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2024/08/19/%E9%A2%98%E8%A7%A3%EF%BC%9A%E7%89%9B%E5%AE%A2%E5%91%A8%E8%B5%9B%20Round%2056%EF%BC%88A-E%EF%BC%89/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2024/08/19/%E9%A2%98%E8%A7%A3%EF%BC%9A%E7%89%9B%E5%AE%A2%E5%91%A8%E8%B5%9B%20Round%2056%EF%BC%88A-E%EF%BC%89/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>13 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="题解牛客周赛-round-56a-e">题解：牛客周赛 Round 56（A-E）</h1>
<h2 id="a-面包店故事">A 面包店故事</h2>
<h3 id="题面">题面</h3>
<p>小镇上有一家面包店，面包以 <span class="math inline"><em>x</em></span> 元的价格出售，加 <span class="math inline"><em>y</em></span> 元可以多加几块培根。小歪带着 <span class="math inline"><em>n</em></span> 元来到了面包店，他想知道自己能不能买到加培根的面包？</p>
<h3 id="输入">输入</h3>
<p>在一行上输入三个整数 <span class="math inline"><em>x</em>, <em>y</em>, <em>n</em>(1≤<em>x</em>,<em>y</em>,<em>n</em>≤100)</span> 代表面包的价格、培根的价格和小歪带的钱。</p>
<h3 id="输出">输出</h3>
<p>如果小歪能加到培根，在一行上输出 <code>YES</code> ；否则，直接输出 <code>NO</code> 。</p>
<h3 id="样例1">样例1</h3>
<p><strong>输入</strong> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3 1 5</span><br></pre></td></tr></table></figure></p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2024/08/19/%E9%A2%98%E8%A7%A3%EF%BC%9A%E7%89%9B%E5%AE%A2%E5%91%A8%E8%B5%9B%20Round%2056%EF%BC%88A-E%EF%BC%89/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="jiejiejiang"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">jiejiejiang</p>
  <div class="site-description" itemprop="description">现在开始，还来得及</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">5</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>


<!-- CloudCalendar -->
<div class="widget-wrap" style="width: 90%;margin-left: auto;margin-right: auto; opacity: 0.97;">
	<div class="widget" id="CloudCalendar"></div>
</div>
      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">jiejiejiang</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">39k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">2:21</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
          load: ['[tex]/mhchem'],
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        displayMath: {'[+]': [['$$', '$$']]},
          packages: {'[+]': ['mhchem']},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  
<!-- calendar widget -->

<script src="https://cdn.jsdelivr.net/npm/darkmode-js@1.5.7/lib/darkmode-js.min.js"></script>

<script>
var options = {
  bottom: '64px',
  right: 'unset',
  left: '32px',
  time: '0.5s',
  mixColor: 'transparent',
  backgroundColor: 'transparent',
  buttonColorDark: '#100f2c',
  buttonColorLight: '#fff',
  saveInCookies: true,
  label: '🌓',
  autoMatchOsTheme: true
}
const darkmode = new Darkmode(options);
window.darkmode = darkmode;
darkmode.showWidget();
</script>


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'nS57E3JRn6eYspCCr9pXSVn5-gzGzoHsz',
      appKey     : 'L8rQJuf9mDfJkhZvlLa9UhPq',
      placeholder: "Just go go",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : true,
      lang       : 'zh-cn' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>


  <!-- calendar widget -->


</body>
</html>
